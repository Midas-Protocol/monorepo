{
  "language": "Solidity",
  "sources": {
    "contracts/compound/CarefulMath.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\n/**\n  * @title Careful Math\n  * @author Compound\n  * @notice Derived from OpenZeppelin's SafeMath library\n  *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n  */\ncontract CarefulMath {\n\n    /**\n     * @dev Possible error codes that we can return\n     */\n    enum MathError {\n        NO_ERROR,\n        DIVISION_BY_ZERO,\n        INTEGER_OVERFLOW,\n        INTEGER_UNDERFLOW\n    }\n\n    /**\n    * @dev Multiplies two numbers, returns an error on overflow.\n    */\n    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (a == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        uint c = a * b;\n\n        if (c / a != b) {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        } else {\n            return (MathError.NO_ERROR, c);\n        }\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (b == 0) {\n            return (MathError.DIVISION_BY_ZERO, 0);\n        }\n\n        return (MathError.NO_ERROR, a / b);\n    }\n\n    /**\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (b <= a) {\n            return (MathError.NO_ERROR, a - b);\n        } else {\n            return (MathError.INTEGER_UNDERFLOW, 0);\n        }\n    }\n\n    /**\n    * @dev Adds two numbers, returns an error on overflow.\n    */\n    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        uint c = a + b;\n\n        if (c >= a) {\n            return (MathError.NO_ERROR, c);\n        } else {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        }\n    }\n\n    /**\n    * @dev add a and b and then subtract c\n    */\n    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n        (MathError err0, uint sum) = addUInt(a, b);\n\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        return subUInt(sum, c);\n    }\n}\n"
    },
    "contracts/compound/Exponential.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"./CarefulMath.sol\";\nimport \"./ExponentialNoError.sol\";\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @dev Legacy contract for compatibility reasons with existing contracts that still use MathError\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract Exponential is CarefulMath, ExponentialNoError {\n    /**\n     * @dev Creates an exponential from numerator and denominator values.\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n     *            or if `denom` is zero.\n     */\n    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\n    }\n\n    /**\n     * @dev Adds two exponentials, returning a new exponential.\n     */\n    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n        (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Subtracts two exponentials, returning a new exponential.\n     */\n    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n        (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\n     */\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(product));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return addUInt(truncate(product), addend);\n    }\n\n    /**\n     * @dev Divide an Exp by a scalar, returning a new Exp.\n     */\n    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, returning a new Exp.\n     */\n    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n        /*\n          We are doing this as:\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n\n          How it works:\n          Exp = a / b;\n          Scalar = s;\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n        */\n        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n        return getExp(numerator, divisor.mantissa);\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\n     */\n    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(fraction));\n    }\n\n    /**\n     * @dev Multiplies two exponentials, returning a new exponential.\n     */\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n\n        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        // We add half the scale before dividing so that we get rounding instead of truncation.\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n        assert(err2 == MathError.NO_ERROR);\n\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\n    }\n\n    /**\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\n     */\n    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\n    }\n\n    /**\n     * @dev Multiplies three exponentials, returning a new exponential.\n     */\n    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n        (MathError err, Exp memory ab) = mulExp(a, b);\n        if (err != MathError.NO_ERROR) {\n            return (err, ab);\n        }\n        return mulExp(ab, c);\n    }\n\n    /**\n     * @dev Divides two exponentials, returning a new exponential.\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n     */\n    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n        return getExp(a.mantissa, b.mantissa);\n    }\n}\n"
    },
    "contracts/compound/ExponentialNoError.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract ExponentialNoError {\n    uint constant expScale = 1e18;\n    uint constant doubleScale = 1e36;\n    uint constant halfExpScale = expScale/2;\n    uint constant mantissaOne = expScale;\n\n    struct Exp {\n        uint mantissa;\n    }\n\n    struct Double {\n        uint mantissa;\n    }\n\n    /**\n     * @dev Truncates the given exp to a whole number value.\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n     */\n    function truncate(Exp memory exp) pure internal returns (uint) {\n        // Note: We are not using careful math here as we're performing a division that cannot fail\n        return exp.mantissa / expScale;\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mul_ScalarTruncate(Exp memory a, uint scalar) pure internal returns (uint) {\n        Exp memory product = mul_(a, scalar);\n        return truncate(product);\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {\n        Exp memory product = mul_(a, scalar);\n        return add_(truncate(product), addend);\n    }\n\n    /**\n     * @dev Checks if first Exp is less than second Exp.\n     */\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa < right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp <= right Exp.\n     */\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa <= right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp > right Exp.\n     */\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa > right.mantissa;\n    }\n\n    /**\n     * @dev returns true if Exp is exactly zero\n     */\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\n        return value.mantissa == 0;\n    }\n\n    function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {\n        require(n < 2**224, errorMessage);\n        return uint224(n);\n    }\n\n    function safe32(uint n, string memory errorMessage) pure internal returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\n    }\n\n    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\n    }\n\n    function add_(uint a, uint b) pure internal returns (uint) {\n        return add_(a, b, \"addition overflow\");\n    }\n\n    function add_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n        uint c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\n    }\n\n    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\n    }\n\n    function sub_(uint a, uint b) pure internal returns (uint) {\n        return sub_(a, b, \"subtraction underflow\");\n    }\n\n    function sub_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\n    }\n\n    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\n        return Exp({mantissa: mul_(a.mantissa, b)});\n    }\n\n    function mul_(uint a, Exp memory b) pure internal returns (uint) {\n        return mul_(a, b.mantissa) / expScale;\n    }\n\n    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\n    }\n\n    function mul_(Double memory a, uint b) pure internal returns (Double memory) {\n        return Double({mantissa: mul_(a.mantissa, b)});\n    }\n\n    function mul_(uint a, Double memory b) pure internal returns (uint) {\n        return mul_(a, b.mantissa) / doubleScale;\n    }\n\n    function mul_(uint a, uint b) pure internal returns (uint) {\n        return mul_(a, b, \"multiplication overflow\");\n    }\n\n    function mul_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n        if (a == 0 || b == 0) {\n            return 0;\n        }\n        uint c = a * b;\n        require(c / a == b, errorMessage);\n        return c;\n    }\n\n    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\n    }\n\n    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\n        return Exp({mantissa: div_(a.mantissa, b)});\n    }\n\n    function div_(uint a, Exp memory b) pure internal returns (uint) {\n        return div_(mul_(a, expScale), b.mantissa);\n    }\n\n    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\n    }\n\n    function div_(Double memory a, uint b) pure internal returns (Double memory) {\n        return Double({mantissa: div_(a.mantissa, b)});\n    }\n\n    function div_(uint a, Double memory b) pure internal returns (uint) {\n        return div_(mul_(a, doubleScale), b.mantissa);\n    }\n\n    function div_(uint a, uint b) pure internal returns (uint) {\n        return div_(a, b, \"divide by zero\");\n    }\n\n    function div_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    function fraction(uint a, uint b) pure internal returns (Double memory) {\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\n    }\n}\n"
    },
    "contracts/compound/Comptroller.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"./CToken.sol\";\nimport \"./CErc20.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./Exponential.sol\";\nimport \"./PriceOracle.sol\";\nimport \"./ComptrollerInterface.sol\";\nimport \"./ComptrollerStorage.sol\";\nimport \"./Unitroller.sol\";\nimport \"./RewardsDistributorDelegate.sol\";\n\n/**\n * @title Compound's Comptroller Contract\n * @author Compound\n * @dev This contract should not to be deployed alone; instead, deploy `Unitroller` (proxy contract) on top of this `Comptroller` (logic/implementation contract).\n */\ncontract Comptroller is ComptrollerV3Storage, ComptrollerInterface, ComptrollerErrorReporter, Exponential {\n    /// @notice Emitted when an admin supports a market\n    event MarketListed(CToken cToken);\n\n    /// @notice Emitted when an admin unsupports a market\n    event MarketUnlisted(CToken cToken);\n\n    /// @notice Emitted when an account enters a market\n    event MarketEntered(CToken cToken, address account);\n\n    /// @notice Emitted when an account exits a market\n    event MarketExited(CToken cToken, address account);\n\n    /// @notice Emitted when close factor is changed by admin\n    event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);\n\n    /// @notice Emitted when a collateral factor is changed by admin\n    event NewCollateralFactor(CToken cToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\n\n    /// @notice Emitted when liquidation incentive is changed by admin\n    event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\n\n    /// @notice Emitted when price oracle is changed\n    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\n\n    /// @notice Emitted when pause guardian is changed\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n    /// @notice Emitted when an action is paused globally\n    event ActionPaused(string action, bool pauseState);\n\n    /// @notice Emitted when an action is paused on a market\n    event ActionPaused(CToken cToken, string action, bool pauseState);\n\n    /// @notice Emitted when the whitelist enforcement is changed\n    event WhitelistEnforcementChanged(bool enforce);\n\n    /// @notice Emitted when auto implementations are toggled\n    event AutoImplementationsToggled(bool enabled);\n\n    /// @notice Emitted when supply cap for a cToken is changed\n    event NewSupplyCap(CToken indexed cToken, uint newSupplyCap);\n\n    /// @notice Emitted when borrow cap for a cToken is changed\n    event NewBorrowCap(CToken indexed cToken, uint newBorrowCap);\n\n    /// @notice Emitted when borrow cap guardian is changed\n    event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);\n\n    /// @notice Emitted when a new RewardsDistributor contract is added to hooks\n    event AddedRewardsDistributor(address rewardsDistributor);\n\n    // closeFactorMantissa must be strictly greater than this value\n    uint internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n\n    // closeFactorMantissa must not exceed this value\n    uint internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n\n    // No collateralFactorMantissa may exceed this value\n    uint internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\n\n    // liquidationIncentiveMantissa must be no less than this value\n    uint internal constant liquidationIncentiveMinMantissa = 1.0e18; // 1.0\n\n    // liquidationIncentiveMantissa must be no greater than this value\n    uint internal constant liquidationIncentiveMaxMantissa = 1.5e18; // 1.5\n\n    /*** Assets You Are In ***/\n\n    /**\n     * @notice Returns the assets an account has entered\n     * @param account The address of the account to pull assets for\n     * @return A dynamic list with the assets the account has entered\n     */\n    function getAssetsIn(address account) external view returns (CToken[] memory) {\n        CToken[] memory assetsIn = accountAssets[account];\n\n        return assetsIn;\n    }\n\n    /**\n     * @notice Returns whether the given account is entered in the given asset\n     * @param account The address of the account to check\n     * @param cToken The cToken to check\n     * @return True if the account is in the asset, otherwise false.\n     */\n    function checkMembership(address account, CToken cToken) external view returns (bool) {\n        return markets[address(cToken)].accountMembership[account];\n    }\n\n    /**\n     * @notice Add assets to be included in account liquidity calculation\n     * @param cTokens The list of addresses of the cToken markets to be enabled\n     * @return Success indicator for whether each corresponding market was entered\n     */\n    function enterMarkets(address[] memory cTokens) override public returns (uint[] memory) {\n        uint len = cTokens.length;\n\n        uint[] memory results = new uint[](len);\n        for (uint i = 0; i < len; i++) {\n            CToken cToken = CToken(cTokens[i]);\n\n            results[i] = uint(addToMarketInternal(cToken, msg.sender));\n        }\n\n        return results;\n    }\n\n    /**\n     * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\n     * @param cToken The market to enter\n     * @param borrower The address of the account to modify\n     * @return Success indicator for whether the market was entered\n     */\n    function addToMarketInternal(CToken cToken, address borrower) internal returns (Error) {\n        Market storage marketToJoin = markets[address(cToken)];\n\n        if (!marketToJoin.isListed) {\n            // market is not listed, cannot join\n            return Error.MARKET_NOT_LISTED;\n        }\n\n        if (marketToJoin.accountMembership[borrower] == true) {\n            // already joined\n            return Error.NO_ERROR;\n        }\n\n        // survived the gauntlet, add to list\n        // NOTE: we store these somewhat redundantly as a significant optimization\n        //  this avoids having to iterate through the list for the most common use cases\n        //  that is, only when we need to perform liquidity checks\n        //  and not whenever we want to check if an account is in a particular market\n        marketToJoin.accountMembership[borrower] = true;\n        accountAssets[borrower].push(cToken);\n\n        // Add to allBorrowers\n        if (!borrowers[borrower]) {\n            allBorrowers.push(borrower);\n            borrowers[borrower] = true;\n            borrowerIndexes[borrower] = allBorrowers.length - 1;\n        }\n\n        emit MarketEntered(cToken, borrower);\n\n        return Error.NO_ERROR;\n    }\n\n    /**\n     * @notice Removes asset from sender's account liquidity calculation\n     * @dev Sender must not have an outstanding borrow balance in the asset,\n     *  or be providing neccessary collateral for an outstanding borrow.\n     * @param cTokenAddress The address of the asset to be removed\n     * @return Whether or not the account successfully exited the market\n     */\n    function exitMarket(address cTokenAddress) override external returns (uint) {\n        CToken cToken = CToken(cTokenAddress);\n        /* Get sender tokensHeld and amountOwed underlying from the cToken */\n        (uint oErr, uint tokensHeld, uint amountOwed, ) = cToken.getAccountSnapshot(msg.sender);\n        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n\n        /* Fail if the sender has a borrow balance */\n        if (amountOwed != 0) {\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n        }\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n        uint allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\n        if (allowed != 0) {\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n        }\n\n        Market storage marketToExit = markets[address(cToken)];\n\n        /* Return true if the sender is not already ‘in’ the market */\n        if (!marketToExit.accountMembership[msg.sender]) {\n            return uint(Error.NO_ERROR);\n        }\n\n        /* Set cToken account membership to false */\n        delete marketToExit.accountMembership[msg.sender];\n\n        /* Delete cToken from the account’s list of assets */\n        // load into memory for faster iteration\n        CToken[] memory userAssetList = accountAssets[msg.sender];\n        uint len = userAssetList.length;\n        uint assetIndex = len;\n        for (uint i = 0; i < len; i++) {\n            if (userAssetList[i] == cToken) {\n                assetIndex = i;\n                break;\n            }\n        }\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n        assert(assetIndex < len);\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n        CToken[] storage storedList = accountAssets[msg.sender];\n        storedList[assetIndex] = storedList[storedList.length - 1];\n        storedList.pop();\n\n        // If the user has exited all markets, remove them from the `allBorrowers` array\n        if (storedList.length == 0) {\n            allBorrowers[borrowerIndexes[msg.sender]] = allBorrowers[allBorrowers.length - 1]; // Copy last item in list to location of item to be removed\n            allBorrowers.pop(); // Reduce length by 1\n            borrowerIndexes[allBorrowers[borrowerIndexes[msg.sender]]] = borrowerIndexes[msg.sender]; // Set borrower index of moved item to correct index\n            borrowerIndexes[msg.sender] = 0; // Reset sender borrower index to 0 for a gas refund\n            borrowers[msg.sender] = false; // Tell the contract that the sender is no longer a borrower (so it knows to add the borrower back if they enter a market in the future)\n        }\n\n        emit MarketExited(cToken, msg.sender);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /*** Policy Hooks ***/\n\n    /**\n     * @notice Checks if the account should be allowed to mint tokens in the given market\n     * @param cToken The market to verify the mint against\n     * @param minter The account which would get the minted tokens\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function mintAllowed(address cToken, address minter, uint mintAmount) override external returns (uint) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!mintGuardianPaused[cToken], \"mint is paused\");\n\n        // Shh - currently unused\n        minter;\n        mintAmount;\n\n        // Make sure market is listed\n        if (!markets[cToken].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        // Make sure minter is whitelisted\n        if (enforceWhitelist && !whitelist[minter]) {\n            return uint(Error.SUPPLIER_NOT_WHITELISTED);\n        }\n\n        // Check supply cap\n        uint supplyCap = supplyCaps[cToken];\n        // Supply cap of 0 corresponds to unlimited supplying\n        if (supplyCap != 0) {\n            uint totalCash = CToken(cToken).getCash();\n            uint totalBorrows = CToken(cToken).totalBorrows();\n            uint totalReserves = CToken(cToken).totalReserves();\n            uint totalFuseFees = CToken(cToken).totalFuseFees();\n            uint totalAdminFees = CToken(cToken).totalAdminFees();\n\n            // totalUnderlyingSupply = totalCash + totalBorrows - (totalReserves + totalFuseFees + totalAdminFees)\n            (MathError mathErr, uint totalUnderlyingSupply) = addThenSubUInt(totalCash, totalBorrows, add_(add_(totalReserves, totalFuseFees), totalAdminFees));\n            if (mathErr != MathError.NO_ERROR) return uint(Error.MATH_ERROR);\n\n            uint nextTotalUnderlyingSupply;\n            (mathErr, nextTotalUnderlyingSupply) = addUInt(totalUnderlyingSupply, mintAmount);\n            if (mathErr != MathError.NO_ERROR) return uint(Error.MATH_ERROR);\n\n            require(nextTotalUnderlyingSupply < supplyCap, \"market supply cap reached\");\n        }\n\n        // Keep the flywheel moving\n        flywheelPreSupplierAction(cToken, minter);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates mint and reverts on rejection. May emit logs.\n     * @param cToken Asset being minted\n     * @param minter The address minting the tokens\n     * @param actualMintAmount The amount of the underlying asset being minted\n     * @param mintTokens The number of tokens being minted\n     */\n    function mintVerify(address cToken, address minter, uint actualMintAmount, uint mintTokens) override external {\n        // Shh - currently unused\n        cToken;\n        minter;\n        actualMintAmount;\n        mintTokens;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            maxAssets = maxAssets;\n        }\n\n        // Add minter to suppliers mapping\n        suppliers[minter] = true;\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\n     * @param cToken The market to verify the redeem against\n     * @param redeemer The account which would redeem the tokens\n     * @param redeemTokens The number of cTokens to exchange for the underlying asset in the market\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function redeemAllowed(address cToken, address redeemer, uint redeemTokens) override external returns (uint) {\n        uint allowed = redeemAllowedInternal(cToken, redeemer, redeemTokens);\n        if (allowed != uint(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        // Keep the flywheel moving\n        flywheelPreSupplierAction(cToken, redeemer);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    function redeemAllowedInternal(address cToken, address redeemer, uint redeemTokens) internal view returns (uint) {\n        if (!markets[cToken].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\n        if (!markets[cToken].accountMembership[redeemer]) {\n            return uint(Error.NO_ERROR);\n        }\n\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(redeemer, CToken(cToken), redeemTokens, 0);\n        if (err != Error.NO_ERROR) {\n            return uint(err);\n        }\n        if (shortfall > 0) {\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\n        }\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates redeem and reverts on rejection. May emit logs.\n     * @param cToken Asset being redeemed\n     * @param redeemer The address redeeming the tokens\n     * @param redeemAmount The amount of the underlying asset being redeemed\n     * @param redeemTokens The number of tokens being redeemed\n     */\n    function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) override external {\n        // Shh - currently unused\n        cToken;\n        redeemer;\n\n        // Require tokens is zero or amount is also zero\n        if (redeemTokens == 0 && redeemAmount > 0) {\n            revert(\"redeemTokens zero\");\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n     * @param cToken The market to verify the borrow against\n     * @param borrower The account which would borrow the asset\n     * @param borrowAmount The amount of underlying the account would borrow\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function borrowAllowed(address cToken, address borrower, uint borrowAmount) override external returns (uint) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!borrowGuardianPaused[cToken], \"borrow is paused\");\n\n        // Make sure market is listed\n        if (!markets[cToken].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        if (!markets[cToken].accountMembership[borrower]) {\n            // only cTokens may call borrowAllowed if borrower not in market\n            require(msg.sender == cToken, \"sender must be cToken\");\n\n            // attempt to add borrower to the market\n            Error err = addToMarketInternal(CToken(msg.sender), borrower);\n            if (err != Error.NO_ERROR) {\n                return uint(err);\n            }\n\n            // it should be impossible to break the important invariant\n            assert(markets[cToken].accountMembership[borrower]);\n        }\n\n        // Make sure oracle price is available\n        if (oracle.getUnderlyingPrice(CToken(cToken)) == 0) {\n            return uint(Error.PRICE_ERROR);\n        }\n\n        // Make sure borrower is whitelisted\n        if (enforceWhitelist && !whitelist[borrower]) {\n            return uint(Error.SUPPLIER_NOT_WHITELISTED);\n        }\n\n        // Check borrow cap\n        uint borrowCap = borrowCaps[cToken];\n        // Borrow cap of 0 corresponds to unlimited borrowing\n        if (borrowCap != 0) {\n            uint totalBorrows = CToken(cToken).totalBorrows();\n            (MathError mathErr, uint nextTotalBorrows) = addUInt(totalBorrows, borrowAmount);\n            if (mathErr != MathError.NO_ERROR) return uint(Error.MATH_ERROR);\n            require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");\n        }\n\n        // Keep the flywheel moving\n        flywheelPreBorrowerAction(cToken, borrower);\n\n        // Perform a hypothetical liquidity check to guard against shortfall\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, CToken(cToken), 0, borrowAmount);\n        if (err != Error.NO_ERROR) {\n            return uint(err);\n        }\n        if (shortfall > 0) {\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\n        }\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n     * @param cToken Asset whose underlying is being borrowed\n     * @param accountBorrowsNew The user's new borrow balance of the underlying asset\n     */\n    function borrowWithinLimits(address cToken, uint accountBorrowsNew) override external returns (uint) {\n        // Check if min borrow exists\n        uint minBorrowEth = fuseAdmin.minBorrowEth();\n\n        if (minBorrowEth > 0) {\n            // Get new underlying borrow balance of account for this cToken\n            uint oraclePriceMantissa = oracle.getUnderlyingPrice(CToken(cToken));\n            if (oraclePriceMantissa == 0) return uint(Error.PRICE_ERROR);\n            (MathError mathErr, uint borrowBalanceEth) = mulScalarTruncate(Exp({mantissa: oraclePriceMantissa}), accountBorrowsNew);\n            if (mathErr != MathError.NO_ERROR) return uint(Error.MATH_ERROR);\n\n            // Check against min borrow\n            if (borrowBalanceEth < minBorrowEth) return uint(Error.BORROW_BELOW_MIN);\n        }\n\n        // Return no error\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n     * @param cToken Asset whose underlying is being borrowed\n     * @param exchangeRateMantissa Underlying/cToken exchange rate\n     * @param accountTokens Initial account cToken balance\n     * @param accountTokens Underlying amount to mint\n     */\n    function mintWithinLimits(address cToken, uint exchangeRateMantissa, uint accountTokens, uint mintAmount) override external returns (uint) {\n        // Return no error\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates borrow and reverts on rejection. May emit logs.\n     * @param cToken Asset whose underlying is being borrowed\n     * @param borrower The address borrowing the underlying\n     * @param borrowAmount The amount of the underlying asset requested to borrow\n     */\n    function borrowVerify(address cToken, address borrower, uint borrowAmount) override external {\n        // Shh - currently unused\n        cToken;\n        borrower;\n        borrowAmount;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            maxAssets = maxAssets;\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\n     * @param cToken The market to verify the repay against\n     * @param payer The account which would repay the asset\n     * @param borrower The account which would borrowed the asset\n     * @param repayAmount The amount of the underlying asset the account would repay\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function repayBorrowAllowed(\n        address cToken,\n        address payer,\n        address borrower,\n        uint repayAmount) override external returns (uint) {\n        // Shh - currently unused\n        payer;\n        borrower;\n        repayAmount;\n\n        // Make sure market is listed\n        if (!markets[cToken].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        // Keep the flywheel moving\n        flywheelPreBorrowerAction(cToken, borrower);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates repayBorrow and reverts on rejection. May emit logs.\n     * @param cToken Asset being repaid\n     * @param payer The address repaying the borrow\n     * @param borrower The address of the borrower\n     * @param actualRepayAmount The amount of underlying being repaid\n     */\n    function repayBorrowVerify(\n        address cToken,\n        address payer,\n        address borrower,\n        uint actualRepayAmount,\n        uint borrowerIndex) override external {\n        // Shh - currently unused\n        cToken;\n        payer;\n        borrower;\n        actualRepayAmount;\n        borrowerIndex;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            maxAssets = maxAssets;\n        }\n    }\n\n    /**\n     * @notice Checks if the liquidation should be allowed to occur\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     */\n    function liquidateBorrowAllowed(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint repayAmount) override external returns (uint) {\n        // Shh - currently unused\n        liquidator;\n\n        // Make sure markets are listed\n        if (!markets[cTokenBorrowed].isListed || !markets[cTokenCollateral].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        // Get borrowers's underlying borrow balance\n        uint borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(borrower);\n\n        /* allow accounts to be liquidated if the market is deprecated */\n        if (isDeprecated(CToken(cTokenBorrowed))) {\n            require(borrowBalance >= repayAmount, \"Can not repay more than the total borrow\");\n        } else {\n            /* The borrower must have shortfall in order to be liquidatable */\n            (Error err, , uint shortfall) = getAccountLiquidityInternal(borrower);\n            if (err != Error.NO_ERROR) {\n                return uint(err);\n            }\n\n            if (shortfall == 0) {\n                return uint(Error.INSUFFICIENT_SHORTFALL);\n            }\n\n            /* The liquidator may not repay more than what is allowed by the closeFactor */\n            uint maxClose = mul_ScalarTruncate(Exp({mantissa: closeFactorMantissa}), borrowBalance);\n            if (repayAmount > maxClose) {\n                return uint(Error.TOO_MUCH_REPAY);\n            }\n        }\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates liquidateBorrow and reverts on rejection. May emit logs.\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param actualRepayAmount The amount of underlying being repaid\n     */\n    function liquidateBorrowVerify(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint actualRepayAmount,\n        uint seizeTokens) override external {\n        // Shh - currently unused\n        cTokenBorrowed;\n        cTokenCollateral;\n        liquidator;\n        borrower;\n        actualRepayAmount;\n        seizeTokens;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            maxAssets = maxAssets;\n        }\n    }\n\n    /**\n     * @notice Checks if the seizing of assets should be allowed to occur\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    function seizeAllowed(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint seizeTokens) override external returns (uint) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!seizeGuardianPaused, \"seize is paused\");\n\n        // Shh - currently unused\n        liquidator;\n        borrower;\n        seizeTokens;\n\n        // Make sure markets are listed\n        if (!markets[cTokenCollateral].isListed || !markets[cTokenBorrowed].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        // Make sure cToken Comptrollers are identical\n        if (CToken(cTokenCollateral).comptroller() != CToken(cTokenBorrowed).comptroller()) {\n            return uint(Error.COMPTROLLER_MISMATCH);\n        }\n\n        // Keep the flywheel moving\n        flywheelPreTransferAction(cTokenCollateral, borrower, liquidator);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates seize and reverts on rejection. May emit logs.\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    function seizeVerify(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint seizeTokens) override external {\n        // Shh - currently unused\n        cTokenCollateral;\n        cTokenBorrowed;\n        liquidator;\n        borrower;\n        seizeTokens;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            maxAssets = maxAssets;\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\n     * @param cToken The market to verify the transfer against\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of cTokens to transfer\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function transferAllowed(address cToken, address src, address dst, uint transferTokens) override external returns (uint) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!transferGuardianPaused, \"transfer is paused\");\n\n        // Currently the only consideration is whether or not\n        //  the src is allowed to redeem this many tokens\n        uint allowed = redeemAllowedInternal(cToken, src, transferTokens);\n        if (allowed != uint(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        // Keep the flywheel moving\n        flywheelPreTransferAction(cToken, src, dst);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates transfer and reverts on rejection. May emit logs.\n     * @param cToken Asset being transferred\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of cTokens to transfer\n     */\n    function transferVerify(address cToken, address src, address dst, uint transferTokens) override external {\n        // Shh - currently unused\n        cToken;\n        src;\n        dst;\n        transferTokens;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            maxAssets = maxAssets;\n        }\n    }\n\n    /*** Flywheel Hooks ***/\n\n    /**\n     * @notice Keeps the flywheel moving pre-mint and pre-redeem\n     * @param cToken The relevant market\n     * @param supplier The minter/redeemer\n     */\n    function flywheelPreSupplierAction(address cToken, address supplier) internal {\n        for (uint256 i = 0; i < rewardsDistributors.length; i++) RewardsDistributorDelegate(rewardsDistributors[i]).flywheelPreSupplierAction(cToken, supplier);\n    }\n\n    /**\n     * @notice Keeps the flywheel moving pre-borrow and pre-repay\n     * @param cToken The relevant market\n     * @param borrower The borrower\n     */\n    function flywheelPreBorrowerAction(address cToken, address borrower) internal {\n        for (uint256 i = 0; i < rewardsDistributors.length; i++) RewardsDistributorDelegate(rewardsDistributors[i]).flywheelPreBorrowerAction(cToken, borrower);\n    }\n\n    /**\n     * @notice Keeps the flywheel moving pre-transfer and pre-seize\n     * @param cToken The relevant market\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     */\n    function flywheelPreTransferAction(address cToken, address src, address dst) internal {\n        for (uint256 i = 0; i < rewardsDistributors.length; i++) RewardsDistributorDelegate(rewardsDistributors[i]).flywheelPreTransferAction(cToken, src, dst);\n    }\n\n    /*** Liquidity/Liquidation Calculations ***/\n\n    /**\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\n     *  Note that `cTokenBalance` is the number of cTokens the account owns in the market,\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n     */\n    struct AccountLiquidityLocalVars {\n        uint sumCollateral;\n        uint sumBorrowPlusEffects;\n        uint cTokenBalance;\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n        uint oraclePriceMantissa;\n        Exp collateralFactor;\n        Exp exchangeRate;\n        Exp oraclePrice;\n        Exp tokensToDenom;\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code (semi-opaque),\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);\n\n        return (uint(err), liquidity, shortfall);\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code,\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getAccountLiquidityInternal(address account) internal view returns (Error, uint, uint) {\n        return getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @return (possible error code (semi-opaque),\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidity(\n        address account,\n        address cTokenModify,\n        uint redeemTokens,\n        uint borrowAmount) public view returns (uint, uint, uint) {\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(cTokenModify), redeemTokens, borrowAmount);\n        return (uint(err), liquidity, shortfall);\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @dev Note that we calculate the exchangeRateStored for each collateral cToken using stored data,\n     *  without calculating accumulated interest.\n     * @return (possible error code,\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidityInternal(\n        address account,\n        CToken cTokenModify,\n        uint redeemTokens,\n        uint borrowAmount) internal view returns (Error, uint, uint) {\n\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\n        uint oErr;\n\n        // For each asset the account is in\n        CToken[] memory assets = accountAssets[account];\n        for (uint i = 0; i < assets.length; i++) {\n            CToken asset = assets[i];\n\n            // Read the balances and exchange rate from the cToken\n            (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);\n            if (oErr != 0) { // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\n                return (Error.SNAPSHOT_ERROR, 0, 0);\n            }\n            vars.collateralFactor = Exp({mantissa: markets[address(asset)].collateralFactorMantissa});\n            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});\n\n            // Get the normalized price of the asset\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\n            if (vars.oraclePriceMantissa == 0) {\n                return (Error.PRICE_ERROR, 0, 0);\n            }\n            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});\n\n            // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n            vars.tokensToDenom = mul_(mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);\n\n            // sumCollateral += tokensToDenom * cTokenBalance\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(vars.tokensToDenom, vars.cTokenBalance, vars.sumCollateral);\n\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\n            vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, vars.borrowBalance, vars.sumBorrowPlusEffects);\n\n            // Calculate effects of interacting with cTokenModify\n            if (asset == cTokenModify) {\n                // redeem effect\n                // sumBorrowPlusEffects += tokensToDenom * redeemTokens\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.tokensToDenom, redeemTokens, vars.sumBorrowPlusEffects);\n\n                // borrow effect\n                // sumBorrowPlusEffects += oraclePrice * borrowAmount\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, borrowAmount, vars.sumBorrowPlusEffects);\n            }\n        }\n\n        // These are safe, as the underflow condition is checked first\n        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\n            return (Error.NO_ERROR, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\n        } else {\n            return (Error.NO_ERROR, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\n        }\n    }\n\n    /**\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n     * @dev Used in liquidation (called in cToken.liquidateBorrowFresh)\n     * @param cTokenBorrowed The address of the borrowed cToken\n     * @param cTokenCollateral The address of the collateral cToken\n     * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\n     * @return (errorCode, number of cTokenCollateral tokens to be seized in a liquidation)\n     */\n    function liquidateCalculateSeizeTokens(address cTokenBorrowed, address cTokenCollateral, uint actualRepayAmount) override external view returns (uint, uint) {\n        /* Read oracle prices for borrowed and collateral markets */\n        uint priceBorrowedMantissa = oracle.getUnderlyingPrice(CToken(cTokenBorrowed));\n        uint priceCollateralMantissa = oracle.getUnderlyingPrice(CToken(cTokenCollateral));\n        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\n            return (uint(Error.PRICE_ERROR), 0);\n        }\n\n        /*\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\n         *  seizeTokens = seizeAmount / exchangeRate\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\n         */\n        uint exchangeRateMantissa = CToken(cTokenCollateral).exchangeRateStored(); // Note: reverts on error\n        uint seizeTokens;\n        Exp memory numerator;\n        Exp memory denominator;\n        Exp memory ratio;\n\n        numerator = mul_(Exp({mantissa: liquidationIncentiveMantissa}), Exp({mantissa: priceBorrowedMantissa}));\n        denominator = mul_(Exp({mantissa: priceCollateralMantissa}), Exp({mantissa: exchangeRateMantissa}));\n        ratio = div_(numerator, denominator);\n\n        seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\n        return (uint(Error.NO_ERROR), seizeTokens);\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n      * @notice Add a RewardsDistributor contracts.\n      * @dev Admin function to add a RewardsDistributor contract\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _addRewardsDistributor(address distributor) external returns (uint) {\n        // Check caller is admin\n        if (!hasAdminRights()) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ADD_REWARDS_DISTRIBUTOR_OWNER_CHECK);\n        }\n\n        // Check marker method\n        require(RewardsDistributorDelegate(distributor).isRewardsDistributor(), \"marker method returned false\");\n\n        // Check for existing RewardsDistributor\n        for (uint i = 0; i < rewardsDistributors.length; i++) require(distributor != rewardsDistributors[i], \"RewardsDistributor contract already added\");\n\n        // Add RewardsDistributor to array\n        rewardsDistributors.push(distributor);\n        emit AddedRewardsDistributor(distributor);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Sets the whitelist enforcement for the comptroller\n      * @dev Admin function to set a new whitelist enforcement boolean\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _setWhitelistEnforcement(bool enforce) external returns (uint) {\n        // Check caller is admin\n        if (!hasAdminRights()) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_WHITELIST_ENFORCEMENT_OWNER_CHECK);\n        }\n\n        // Check if `enforceWhitelist` already equals `enforce`\n        if (enforceWhitelist == enforce) {\n            return uint(Error.NO_ERROR);\n        }\n\n        // Set comptroller's `enforceWhitelist` to `enforce`\n        enforceWhitelist = enforce;\n\n        // Emit WhitelistEnforcementChanged(bool enforce);\n        emit WhitelistEnforcementChanged(enforce);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Sets the whitelist `statuses` for `suppliers`\n      * @dev Admin function to set the whitelist `statuses` for `suppliers`\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _setWhitelistStatuses(address[] calldata suppliers, bool[] calldata statuses) external returns (uint) {\n        // Check caller is admin\n        if (!hasAdminRights()) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_WHITELIST_STATUS_OWNER_CHECK);\n        }\n\n        // Set whitelist statuses for suppliers\n        for (uint i = 0; i < suppliers.length; i++) {\n            address supplier = suppliers[i];\n\n            if (statuses[i]) {\n                // If not already whitelisted, add to whitelist\n                if (!whitelist[supplier]) {\n                    whitelist[supplier] = true;\n                    whitelistArray.push(supplier);\n                    whitelistIndexes[supplier] = whitelistArray.length - 1;\n                }\n            } else {\n                // If whitelisted, remove from whitelist\n                if (whitelist[supplier]) {\n                    whitelistArray[whitelistIndexes[supplier]] = whitelistArray[whitelistArray.length - 1]; // Copy last item in list to location of item to be removed\n                    whitelistArray.pop(); // Reduce length by 1\n                    whitelistIndexes[whitelistArray[whitelistIndexes[supplier]]] = whitelistIndexes[supplier]; // Set whitelist index of moved item to correct index\n                    whitelistIndexes[supplier] = 0; // Reset supplier whitelist index to 0 for a gas refund\n                    whitelist[supplier] = false; // Tell the contract that the supplier is no longer whitelisted\n                }\n            }\n        }\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Sets a new price oracle for the comptroller\n      * @dev Admin function to set a new price oracle\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\n        // Check caller is admin\n        if (!hasAdminRights()) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n        }\n\n        // Track the old oracle for the comptroller\n        PriceOracle oldOracle = oracle;\n\n        // Set comptroller's oracle to newOracle\n        oracle = newOracle;\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n        emit NewPriceOracle(oldOracle, newOracle);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Sets the closeFactor used when liquidating borrows\n      * @dev Admin function to set closeFactor\n      * @param newCloseFactorMantissa New close factor, scaled by 1e18\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n      */\n    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint256) {\n        // Check caller is admin\n        if (!hasAdminRights()) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_CLOSE_FACTOR_OWNER_CHECK);\n        }\n\n        // Check limits\n        Exp memory newCloseFactorExp = Exp({mantissa: newCloseFactorMantissa});\n        Exp memory lowLimit = Exp({mantissa: closeFactorMinMantissa});\n        if (lessThanOrEqualExp(newCloseFactorExp, lowLimit)) {\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n        }\n\n        Exp memory highLimit = Exp({mantissa: closeFactorMaxMantissa});\n        if (lessThanExp(highLimit, newCloseFactorExp)) {\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n        }\n\n        // Set pool close factor to new close factor, remember old value\n        uint oldCloseFactorMantissa = closeFactorMantissa;\n        closeFactorMantissa = newCloseFactorMantissa;\n\n        // Emit event\n        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Sets the collateralFactor for a market\n      * @dev Admin function to set per-market collateralFactor\n      * @param cToken The market to set the factor on\n      * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n      */\n    function _setCollateralFactor(CToken cToken, uint newCollateralFactorMantissa) public returns (uint256) {\n        // Check caller is admin\n        if (!hasAdminRights()) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\n        }\n\n        // Verify market is listed\n        Market storage market = markets[address(cToken)];\n        if (!market.isListed) {\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\n        }\n\n        Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});\n\n        // Check collateral factor <= 0.9\n        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n        }\n\n        // If collateral factor != 0, fail if price == 0\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n        }\n\n        // Set market's collateral factor to new collateral factor, remember old value\n        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n        // Emit event with asset, old collateral factor, and new collateral factor\n        emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Sets liquidationIncentive\n      * @dev Admin function to set liquidationIncentive\n      * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n      */\n    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\n        // Check caller is admin\n        if (!hasAdminRights()) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\n        }\n\n        // Check de-scaled min <= newLiquidationIncentive <= max\n        Exp memory newLiquidationIncentive = Exp({mantissa: newLiquidationIncentiveMantissa});\n        Exp memory minLiquidationIncentive = Exp({mantissa: liquidationIncentiveMinMantissa});\n        if (lessThanExp(newLiquidationIncentive, minLiquidationIncentive)) {\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n        }\n\n        Exp memory maxLiquidationIncentive = Exp({mantissa: liquidationIncentiveMaxMantissa});\n        if (lessThanExp(maxLiquidationIncentive, newLiquidationIncentive)) {\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n        }\n\n        // Save current value for use in log\n        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n\n        // Set liquidation incentive to new incentive\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n        // Emit event with old incentive, new incentive\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Add the market to the markets mapping and set it as listed\n      * @dev Admin function to set isListed and add support for the market\n      * @param cToken The address of the market (token) to list\n      * @return uint 0=success, otherwise a failure. (See enum Error for details)\n      */\n    function _supportMarket(CToken cToken) internal returns (uint) {\n        // Check caller is admin\n        if (!hasAdminRights()) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n        }\n\n        // Is market already listed?\n        if (markets[address(cToken)].isListed) {\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n        }\n        // Sanity check to make sure its really a CToken\n        require(cToken.isCToken(), \"marker method returned false\");\n\n        // Check cToken.comptroller == this\n        require(address(cToken.comptroller()) == address(this), \"Cannot support a market with a different Comptroller.\");\n\n        // Make sure market is not already listed\n        address underlying = cToken.isCEther() ? address(0) : CErc20(address(cToken)).underlying();\n\n        if (address(cTokensByUnderlying[underlying]) != address(0)) {\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n        }\n\n        // List market and emit event\n        Market storage market = markets[address(cToken)];\n        market.isListed = true;\n        market.collateralFactorMantissa = 0;\n        allMarkets.push(cToken);\n        cTokensByUnderlying[underlying] = cToken;\n        emit MarketListed(cToken);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Deploy cToken, add the market to the markets mapping, and set it as listed and set the collateral factor\n      * @dev Admin function to deploy cToken, set isListed, and add support for the market and set the collateral factor\n      * @return uint 0=success, otherwise a failure. (See enum Error for details)\n      */\n    function _deployMarket(\n        bool isCEther,\n        bytes calldata constructorData,\n        uint collateralFactorMantissa\n    ) external returns (uint) {\n        // Check caller is admin\n        if (!hasAdminRights()) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n        }\n\n        // Temporarily enable Fuse admin rights for asset deployment (storing the original value)\n        bool oldFuseAdminHasRights = fuseAdminHasRights;\n        fuseAdminHasRights = true;\n\n        // Deploy via Fuse admin\n        CToken cToken = CToken(isCEther ? fuseAdmin.deployCEther(constructorData) : fuseAdmin.deployCErc20(constructorData));\n        // Reset Fuse admin rights to the original value\n        fuseAdminHasRights = oldFuseAdminHasRights;\n        // Support market here in the Comptroller\n        uint256 err = _supportMarket(cToken);\n\n        // Set collateral factor\n        return err == uint(Error.NO_ERROR) ? _setCollateralFactor(cToken, collateralFactorMantissa) : err;\n    }\n\n    /**\n      * @notice Removed a market from the markets mapping and sets it as unlisted\n      * @dev Admin function unset isListed and collateralFactorMantissa and unadd support for the market\n      * @param cToken The address of the market (token) to unlist\n      * @return uint 0=success, otherwise a failure. (See enum Error for details)\n      */\n    function _unsupportMarket(CToken cToken) external returns (uint) {\n        // Check admin rights\n        if (!hasAdminRights()) return fail(Error.UNAUTHORIZED, FailureInfo.UNSUPPORT_MARKET_OWNER_CHECK);\n\n        // Check if market is already unlisted\n        if (!markets[address(cToken)].isListed) return fail(Error.MARKET_NOT_LISTED, FailureInfo.UNSUPPORT_MARKET_DOES_NOT_EXIST);\n\n        // Check if market is in use\n        if (cToken.totalSupply() > 0) return fail(Error.NONZERO_TOTAL_SUPPLY, FailureInfo.UNSUPPORT_MARKET_IN_USE);\n\n        // Unlist market\n        delete markets[address(cToken)];\n\n        /* Delete cToken from allMarkets */\n        // load into memory for faster iteration\n        CToken[] memory _allMarkets = allMarkets;\n        uint len = _allMarkets.length;\n        uint assetIndex = len;\n        for (uint i = 0; i < len; i++) {\n            if (_allMarkets[i] == cToken) {\n                assetIndex = i;\n                break;\n            }\n        }\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n        assert(assetIndex < len);\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n        allMarkets[assetIndex] = allMarkets[allMarkets.length - 1];\n        allMarkets.pop();\n\n        cTokensByUnderlying[cToken.isCEther() ? address(0) : CErc20(address(cToken)).underlying()] = CToken(address(0));\n        emit MarketUnlisted(cToken);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Toggles the auto-implementation feature\n     * @param enabled If the feature is to be enabled\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _toggleAutoImplementations(bool enabled) public returns (uint) {\n        if (!hasAdminRights()) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.TOGGLE_AUTO_IMPLEMENTATIONS_ENABLED_OWNER_CHECK);\n        }\n\n        // Return no error if already set to the desired value\n        if (autoImplementation == enabled) return uint(Error.NO_ERROR);\n\n        // Store autoImplementation with value enabled\n        autoImplementation = enabled;\n\n        // Emit AutoImplementationsToggled(enabled)\n        emit AutoImplementationsToggled(enabled);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Set the given supply caps for the given cToken markets. Supplying that brings total underlying supply to or above supply cap will revert.\n      * @dev Admin or borrowCapGuardian function to set the supply caps. A supply cap of 0 corresponds to unlimited supplying.\n      * @param cTokens The addresses of the markets (tokens) to change the supply caps for\n      * @param newSupplyCaps The new supply cap values in underlying to be set. A value of 0 corresponds to unlimited supplying.\n      */\n    function _setMarketSupplyCaps(CToken[] calldata cTokens, uint[] calldata newSupplyCaps) external {\n        require(msg.sender == admin || msg.sender == borrowCapGuardian, \"only admin or borrow cap guardian can set supply caps\");\n\n        uint numMarkets = cTokens.length;\n        uint numSupplyCaps = newSupplyCaps.length;\n\n        require(numMarkets != 0 && numMarkets == numSupplyCaps, \"invalid input\");\n\n        for(uint i = 0; i < numMarkets; i++) {\n            supplyCaps[address(cTokens[i])] = newSupplyCaps[i];\n            emit NewSupplyCap(cTokens[i], newSupplyCaps[i]);\n        }\n    }\n\n    /**\n      * @notice Set the given borrow caps for the given cToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\n      * @dev Admin or borrowCapGuardian function to set the borrow caps. A borrow cap of 0 corresponds to unlimited borrowing.\n      * @param cTokens The addresses of the markets (tokens) to change the borrow caps for\n      * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\n      */\n    function _setMarketBorrowCaps(CToken[] calldata cTokens, uint[] calldata newBorrowCaps) external {\n        require(msg.sender == admin || msg.sender == borrowCapGuardian, \"only admin or borrow cap guardian can set borrow caps\");\n\n        uint numMarkets = cTokens.length;\n        uint numBorrowCaps = newBorrowCaps.length;\n\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n\n        for(uint i = 0; i < numMarkets; i++) {\n            borrowCaps[address(cTokens[i])] = newBorrowCaps[i];\n            emit NewBorrowCap(cTokens[i], newBorrowCaps[i]);\n        }\n    }\n\n    /**\n     * @notice Admin function to change the Borrow Cap Guardian\n     * @param newBorrowCapGuardian The address of the new Borrow Cap Guardian\n     */\n    function _setBorrowCapGuardian(address newBorrowCapGuardian) external {\n        require(msg.sender == admin, \"only admin can set borrow cap guardian\");\n\n        // Save current value for inclusion in log\n        address oldBorrowCapGuardian = borrowCapGuardian;\n\n        // Store borrowCapGuardian with value newBorrowCapGuardian\n        borrowCapGuardian = newBorrowCapGuardian;\n\n        // Emit NewBorrowCapGuardian(OldBorrowCapGuardian, NewBorrowCapGuardian)\n        emit NewBorrowCapGuardian(oldBorrowCapGuardian, newBorrowCapGuardian);\n    }\n\n    /**\n     * @notice Admin function to change the Pause Guardian\n     * @param newPauseGuardian The address of the new Pause Guardian\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _setPauseGuardian(address newPauseGuardian) public returns (uint) {\n        if (!hasAdminRights()) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\n        }\n\n        // Save current value for inclusion in log\n        address oldPauseGuardian = pauseGuardian;\n\n        // Store pauseGuardian with value newPauseGuardian\n        pauseGuardian = newPauseGuardian;\n\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n        emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    function _setMintPaused(CToken cToken, bool state) public returns (bool) {\n        require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\n        require(msg.sender == pauseGuardian || hasAdminRights(), \"only pause guardian and admin can pause\");\n        require(hasAdminRights() || state == true, \"only admin can unpause\");\n\n        mintGuardianPaused[address(cToken)] = state;\n        emit ActionPaused(cToken, \"Mint\", state);\n        return state;\n    }\n\n    function _setBorrowPaused(CToken cToken, bool state) public returns (bool) {\n        require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\n        require(msg.sender == pauseGuardian || hasAdminRights(), \"only pause guardian and admin can pause\");\n        require(hasAdminRights() || state == true, \"only admin can unpause\");\n\n        borrowGuardianPaused[address(cToken)] = state;\n        emit ActionPaused(cToken, \"Borrow\", state);\n        return state;\n    }\n\n    function _setTransferPaused(bool state) public returns (bool) {\n        require(msg.sender == pauseGuardian || hasAdminRights(), \"only pause guardian and admin can pause\");\n        require(hasAdminRights() || state == true, \"only admin can unpause\");\n\n        transferGuardianPaused = state;\n        emit ActionPaused(\"Transfer\", state);\n        return state;\n    }\n\n    function _setSeizePaused(bool state) public returns (bool) {\n        require(msg.sender == pauseGuardian || hasAdminRights(), \"only pause guardian and admin can pause\");\n        require(hasAdminRights() || state == true, \"only admin can unpause\");\n\n        seizeGuardianPaused = state;\n        emit ActionPaused(\"Seize\", state);\n        return state;\n    }\n\n    function _become(Unitroller unitroller) public {\n        require((msg.sender == address(fuseAdmin) && unitroller.fuseAdminHasRights()) || (msg.sender == unitroller.admin() && unitroller.adminHasRights()), \"only unitroller admin can change brains\");\n\n        uint changeStatus = unitroller._acceptImplementation();\n        require(changeStatus == 0, \"change not authorized\");\n\n        Comptroller(address(unitroller))._becomeImplementation();\n    }\n\n    function _becomeImplementation() external {\n        require(msg.sender == comptrollerImplementation, \"only implementation may call _becomeImplementation\");\n\n        if (!_notEnteredInitialized) {\n            _notEntered = true;\n            _notEnteredInitialized = true;\n        }\n    }\n\n    /*** Helper Functions ***/\n\n    /**\n     * @notice Return all of the markets\n     * @dev The automatic getter may be used to access an individual market.\n     * @return The list of market addresses\n     */\n    function getAllMarkets() public view returns (CToken[] memory) {\n        return allMarkets;\n    }\n\n    /**\n     * @notice Return all of the borrowers\n     * @dev The automatic getter may be used to access an individual borrower.\n     * @return The list of borrower account addresses\n     */\n    function getAllBorrowers() public view returns (address[] memory) {\n        return allBorrowers;\n    }\n\n    /**\n     * @notice Return all of the whitelist\n     * @dev The automatic getter may be used to access an individual whitelist status.\n     * @return The list of borrower account addresses\n     */\n    function getWhitelist() external view returns (address[] memory) {\n        return whitelistArray;\n    }\n\n    /**\n     * @notice Returns an array of all RewardsDistributors\n     */\n    function getRewardsDistributors() external view returns (address[] memory) {\n        return rewardsDistributors;\n    }\n\n    /**\n     * @notice Returns true if the given cToken market has been deprecated\n     * @dev All borrows in a deprecated cToken market can be immediately liquidated\n     * @param cToken The market to check if deprecated\n     */\n    function isDeprecated(CToken cToken) public view returns (bool) {\n        return\n        markets[address(cToken)].collateralFactorMantissa == 0 &&\n        borrowGuardianPaused[address(cToken)] == true &&\n        add_(add_(cToken.reserveFactorMantissa(), cToken.adminFeeMantissa()), cToken.fuseFeeMantissa()) == 1e18\n        ;\n    }\n\n    /*** Pool-Wide/Cross-Asset Reentrancy Prevention ***/\n\n    /**\n     * @dev Called by cTokens before a non-reentrant function for pool-wide reentrancy prevention.\n     * Prevents pool-wide/cross-asset reentrancy exploits like AMP on Cream.\n     */\n    function _beforeNonReentrant() override external {\n        require(markets[msg.sender].isListed, \"Comptroller:_beforeNonReentrant: caller not listed as market\");\n        require(_notEntered, \"re-entered across assets\");\n        _notEntered = false;\n    }\n\n    /**\n     * @dev Called by cTokens after a non-reentrant function for pool-wide reentrancy prevention.\n     * Prevents pool-wide/cross-asset reentrancy exploits like AMP on Cream.\n     */\n    function _afterNonReentrant() override external {\n        require(markets[msg.sender].isListed, \"Comptroller:_afterNonReentrant: caller not listed as market\");\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }\n}"
    },
    "contracts/compound/CToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./CTokenInterfaces.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./Exponential.sol\";\nimport \"./EIP20Interface.sol\";\nimport \"./EIP20NonStandardInterface.sol\";\nimport \"./InterestRateModel.sol\";\n\n/**\n * @title Compound's CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n */\ncontract CToken is CTokenInterface, Exponential, TokenErrorReporter {\n    /**\n     * @notice Returns a boolean indicating if the sender has admin rights\n     */\n    function hasAdminRights() internal view returns (bool) {\n        ComptrollerV3Storage comptrollerStorage = ComptrollerV3Storage(address(comptroller));\n        return (msg.sender == comptrollerStorage.admin() && comptrollerStorage.adminHasRights()) || (msg.sender == address(fuseAdmin) && comptrollerStorage.fuseAdminHasRights());\n    }\n\n    /**\n     * @notice Initialize the money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     */\n    function initialize(ComptrollerInterface comptroller_,\n                        InterestRateModel interestRateModel_,\n                        uint initialExchangeRateMantissa_,\n                        string memory name_,\n                        string memory symbol_,\n                        uint8 decimals_,\n                        uint256 reserveFactorMantissa_,\n                        uint256 adminFeeMantissa_) public {\n        require(msg.sender == address(fuseAdmin), \"only Fuse admin may initialize the market\");\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n        // Set the comptroller\n        uint err = _setComptroller(comptroller_);\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = mantissaOne;\n\n        // Set the interest rate model (depends on block number / borrow index)\n        err = _setInterestRateModelFresh(interestRateModel_);\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        // Set reserve factor\n        err = _setReserveFactorFresh(reserveFactorMantissa_);\n        require(err == uint(Error.NO_ERROR), \"setting reserve factor failed\");\n\n        // Set admin fee\n        err = _setAdminFeeFresh(adminFeeMantissa_);\n        require(err == uint(Error.NO_ERROR), \"setting admin fee failed\");\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n        _notEntered = true;\n    }\n    \n    /**\n     * @dev Returns latest pending Fuse fee (to be set with `_setFuseFeeFresh`)\n     */\n    function getPendingFuseFeeFromAdmin() internal view returns (uint) {\n        return fuseAdmin.interestFeeRate();\n    }\n\n    /**\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n        /* Fail if transfer not allowed */\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Do not allow self-transfers */\n        if (src == dst) {\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        /* Get the allowance, infinite for the account owner */\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(-1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        MathError mathErr;\n        uint allowanceNew;\n        uint srcTokensNew;\n        uint dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n        }\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != uint(-1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.transferVerify(address(this), src, dst, tokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) override external nonReentrant(false) returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint256 amount) override external nonReentrant(false) returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) override external returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     */\n    function allowance(address owner, address spender) override external view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /**\n     * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) override external view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) override external returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\n        return balance;\n    }\n\n    /**\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account) override external view returns (uint, uint, uint, uint) {\n        uint cTokenBalance = accountTokens[account];\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /**\n     * @notice Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() override external view returns (uint) {\n        return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, add_(totalReserves, add_(totalAdminFees, totalFuseFees)));\n    }\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() override external view returns (uint) {\n        return interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, add_(totalReserves, add_(totalAdminFees, totalFuseFees)), reserveFactorMantissa + fuseFeeMantissa + adminFeeMantissa);\n    }\n\n    /**\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent() override external nonReentrant(false) returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n        return totalBorrows;\n    }\n\n    /**\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) override external nonReentrant(false) returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n        return borrowBalanceStored(account);\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     */\n    function borrowBalanceStored(address account) override public view returns (uint) {\n        (MathError err, uint result) = borrowBalanceStoredInternal(account);\n        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n        return result;\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        /* Note: we do not assert that the market is up to date */\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n\n        /* Get borrowBalance and borrowIndex */\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        /* Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         */\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() override public nonReentrant(false) returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n        return exchangeRateStored();\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() override public view returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n        return result;\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return (error code, calculated exchange rate scaled by 1e18)\n     */\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /*\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             */\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /*\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - (totalReserves + totalFuseFees + totalAdminFees)) / totalSupply\n             */\n            uint totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, add_(totalReserves, add_(totalAdminFees, totalFuseFees)));\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    /**\n     * @notice Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() override external view returns (uint) {\n        return getCashPrior();\n    }\n\n    /**\n     * @notice Applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     *   up to the current block and writes new checkpoint to storage.\n     */\n    function accrueInterest() override virtual public returns (uint) {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumber == currentBlockNumber) {\n            return uint(Error.NO_ERROR);\n        }\n\n        /* Read the previous values out of storage */\n        uint cashPrior = getCashPrior();\n\n        /* Calculate the current borrow interest rate */\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, totalBorrows, add_(totalReserves, add_(totalAdminFees, totalFuseFees)));\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumber);\n        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n\n        return finishInterestAccrual(currentBlockNumber, cashPrior, borrowRateMantissa, blockDelta);\n    }\n\n    /**\n     * @dev Split off from `accrueInterest` to avoid \"stack too deep\" error\".\n     */\n    function finishInterestAccrual(uint currentBlockNumber, uint cashPrior, uint borrowRateMantissa, uint blockDelta) private returns (uint) {\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n         *  totalFuseFeesNew = interestAccumulated * fuseFee + totalFuseFees\n         *  totalAdminFeesNew = interestAccumulated * adminFee + totalAdminFees\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n\n        Exp memory simpleInterestFactor = mul_(Exp({mantissa: borrowRateMantissa}), blockDelta);\n        uint interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, totalBorrows);\n        uint totalBorrowsNew = add_(interestAccumulated, totalBorrows);\n        uint totalReservesNew = mul_ScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, totalReserves);\n        uint totalFuseFeesNew = mul_ScalarTruncateAddUInt(Exp({mantissa: fuseFeeMantissa}), interestAccumulated, totalFuseFees);\n        uint totalAdminFeesNew = mul_ScalarTruncateAddUInt(Exp({mantissa: adminFeeMantissa}), interestAccumulated, totalAdminFees);\n        uint borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n        totalFuseFees = totalFuseFeesNew;\n        totalAdminFees = totalAdminFeesNew;\n\n        /* We emit an AccrueInterest event */\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintInternal(uint mintAmount) internal nonReentrant(false) returns (uint, uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return (fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED), 0);\n        }\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        return mintFresh(msg.sender, mintAmount);\n    }\n\n    struct MintLocalVars {\n        Error err;\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n        uint actualMintAmount;\n    }\n\n    /**\n     * @notice User supplies assets into the market and receives cTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n        /* Fail if mint not allowed */\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n        }\n\n        MintLocalVars memory vars;\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr)), 0);\n        }\n\n        // Check max supply\n        // unused function\n        /* allowed = comptroller.mintWithinLimits(address(this), vars.exchangeRateMantissa, accountTokens[minter], mintAmount);\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n        } */\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         *  We call `doTransferIn` for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n        /*\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n\n        /*\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         */\n        vars.totalSupplyNew = add_(totalSupply, vars.mintTokens);\n\n        vars.accountTokensNew = add_(accountTokens[minter], vars.mintTokens);\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        /* We call the defense hook */\n        comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemInternal(uint redeemTokens) internal nonReentrant(false) returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        return redeemFresh(msg.sender, redeemTokens, 0);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to receive from redeeming cTokens\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant(false) returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        return redeemFresh(msg.sender, 0, redeemAmount);\n    }\n\n    struct RedeemLocalVars {\n        Error err;\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    /**\n     * @notice User redeems cTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n        RedeemLocalVars memory vars;\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n        }\n\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            vars.redeemTokens = redeemTokensIn;\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n            }\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n            }\n\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        /* Fail if redeem not allowed */\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n        }\n\n        /*\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /* Fail gracefully if protocol has insufficient cash */\n        if (getCashPrior() < vars.redeemAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(redeemer, vars.redeemAmount);\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        /* We call the defense hook */\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Sender borrows assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function borrowInternal(uint borrowAmount) internal nonReentrant(false) returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n        }\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n        return borrowFresh(msg.sender, borrowAmount);\n    }\n\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n\n    /**\n      * @notice Users borrow assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n        /* Fail if borrow not allowed */\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n        }\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n        uint cashPrior = getCashPrior();\n\n        if (cashPrior < borrowAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n        }\n\n        BorrowLocalVars memory vars;\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        // Check min borrow for this user for this asset\n        allowed = comptroller.borrowWithinLimits(address(this), vars.accountBorrowsNew);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n        }\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken borrowAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(borrower, borrowAmount);\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a Borrow event */\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function repayBorrowInternal(uint repayAmount) internal nonReentrant(false) returns (uint, uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);\n        }\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant(false) returns (uint, uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);\n        }\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n    }\n\n    struct RepayBorrowLocalVars {\n        Error err;\n        MathError mathErr;\n        uint repayAmount;\n        uint borrowerIndex;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n        uint actualRepayAmount;\n    }\n\n    /**\n     * @notice Borrows are repaid by another user (possibly the borrower).\n     * @param payer the account paying off the borrow\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount the amount of undelrying tokens being returned\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {\n        /* Fail if repayBorrow not allowed */\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed), 0);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\n        }\n\n        RepayBorrowLocalVars memory vars;\n\n        /* We remember the original borrowerIndex for verification purposes */\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr)), 0);\n        }\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n        if (repayAmount == uint(-1)) {\n            vars.repayAmount = vars.accountBorrows;\n        } else {\n            vars.repayAmount = repayAmount;\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We call doTransferIn for the payer and the repayAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional repayAmount of cash.\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *   it returns the amount actually transferred, in case of a fee.\n         */\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n         */\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a RepayBorrow event */\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\n\n        return (uint(Error.NO_ERROR), vars.actualRepayAmount);\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function liquidateBorrowInternal(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal nonReentrant(false) returns (uint, uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\n        }\n\n        error = cTokenCollateral.accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\n        }\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n    }\n\n    /**\n     * @notice The liquidator liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param liquidator The address repaying the borrow and seizing collateral\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal returns (uint, uint) {\n        /* Fail if liquidate not allowed */\n        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed), 0);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK), 0);\n        }\n\n        /* Verify cTokenCollateral market's block number equals current block number */\n        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK), 0);\n        }\n\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            return (fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER), 0);\n        }\n\n        /* Fail if repayAmount = 0 */\n        if (repayAmount == 0) {\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO), 0);\n        }\n\n        /* Fail if repayAmount = -1 */\n        if (repayAmount == uint(-1)) {\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX), 0);\n        }\n\n\n        /* Fail if repayBorrow fails */\n        (uint repayBorrowError, uint actualRepayAmount) = repayBorrowFresh(liquidator, borrower, repayAmount);\n        if (repayBorrowError != uint(Error.NO_ERROR)) {\n            return (fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED), 0);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We calculate the number of collateral tokens that will be seized */\n        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), actualRepayAmount);\n        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n\n        /* Revert if borrower collateral token balance < seizeTokens */\n        require(cTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n\n        // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\n        uint seizeError;\n        if (address(cTokenCollateral) == address(this)) {\n            seizeError = seizeInternal(address(this), liquidator, borrower, seizeTokens);\n        } else {\n            seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);\n        }\n\n        /* Revert if seize tokens fails (since we cannot be sure of side effects) */\n        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n\n        /* We emit a LiquidateBorrow event */\n        emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(cTokenCollateral), seizeTokens);\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, actualRepayAmount, seizeTokens);\n\n        return (uint(Error.NO_ERROR), actualRepayAmount);\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Will fail unless called by another cToken during the process of liquidation.\n     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function seize(address liquidator, address borrower, uint seizeTokens) override external nonReentrant(true) returns (uint) {\n        return seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\n    }\n\n    struct SeizeInternalLocalVars {\n        MathError mathErr;\n        uint borrowerTokensNew;\n        uint liquidatorTokensNew;\n        uint liquidatorSeizeTokens;\n        uint protocolSeizeTokens;\n        uint protocolSeizeAmount;\n        uint exchangeRateMantissa;\n        uint totalReservesNew;\n        uint totalFuseFeeNew;\n        uint totalSupplyNew;\n        uint feeSeizeTokens;\n        uint feeSeizeAmount;\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\n     *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\n     * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {\n        /* Fail if seize not allowed */\n        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n        }\n\n        SeizeInternalLocalVars memory vars;\n\n        /*\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n         */\n        (vars.mathErr, vars.borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(vars.mathErr));\n        }\n\n        vars.protocolSeizeTokens = mul_(seizeTokens, Exp({mantissa: protocolSeizeShareMantissa}));\n        vars.feeSeizeTokens = mul_(seizeTokens, Exp({mantissa: feeSeizeShareMantissa}));\n        vars.liquidatorSeizeTokens = sub_(sub_(seizeTokens, vars.protocolSeizeTokens), vars.feeSeizeTokens);\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, \"exchange rate math error\");\n\n        vars.protocolSeizeAmount = mul_ScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), vars.protocolSeizeTokens);\n        vars.feeSeizeAmount = mul_ScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), vars.feeSeizeTokens);\n\n        vars.totalReservesNew = add_(totalReserves, vars.protocolSeizeAmount);\n        vars.totalSupplyNew = sub_(sub_(totalSupply, vars.protocolSeizeTokens), vars.feeSeizeTokens);\n        vars.totalFuseFeeNew = add_(totalFuseFees, vars.feeSeizeAmount);\n\n        (vars.mathErr, vars.liquidatorTokensNew) = addUInt(accountTokens[liquidator], vars.liquidatorSeizeTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(vars.mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        totalReserves = vars.totalReservesNew;\n        totalSupply = vars.totalSupplyNew;\n        totalFuseFees = vars.totalFuseFeeNew;\n\n        accountTokens[borrower] = vars.borrowerTokensNew;\n        accountTokens[liquidator] = vars.liquidatorTokensNew;\n\n        /* Emit a Transfer event */\n        emit Transfer(borrower, liquidator, vars.liquidatorSeizeTokens);\n        emit Transfer(borrower, address(this), vars.protocolSeizeTokens);\n        emit ReservesAdded(address(this), vars.protocolSeizeAmount, vars.totalReservesNew);\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n\n    /*** Admin Functions ***/\n\n    /**\n      * @notice Sets a new comptroller for the market\n      * @dev Internal function to set a new comptroller\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _setComptroller(ComptrollerInterface newComptroller) internal returns (uint) {\n        ComptrollerInterface oldComptroller = comptroller;\n        // Ensure invoke comptroller.isComptroller() returns true\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n        // Set market's comptroller to newComptroller\n        comptroller = newComptroller;\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n        emit NewComptroller(oldComptroller, newComptroller);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice accrues interest and sets a new admin fee for the protocol using _setAdminFeeFresh\n      * @dev Admin function to accrue interest and set a new admin fee\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _setAdminFee(uint newAdminFeeMantissa) external nonReentrant(false) returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted admin fee change failed.\n            return fail(Error(error), FailureInfo.SET_ADMIN_FEE_ACCRUE_INTEREST_FAILED);\n        }\n        // _setAdminFeeFresh emits reserve-factor-specific logs on errors, so we don't need to.\n        return _setAdminFeeFresh(newAdminFeeMantissa);\n    }\n\n    /**\n      * @notice Sets a new admin fee for the protocol (*requires fresh interest accrual)\n      * @dev Admin function to set a new admin fee\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _setAdminFeeFresh(uint newAdminFeeMantissa) internal returns (uint) {\n        // Verify market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_ADMIN_FEE_FRESH_CHECK);\n        }\n\n        // Sanitize newAdminFeeMantissa\n        if (newAdminFeeMantissa == uint(-1)) newAdminFeeMantissa = adminFeeMantissa;\n\n        // Get latest Fuse fee\n        uint newFuseFeeMantissa = getPendingFuseFeeFromAdmin();\n\n        // Check reserveFactorMantissa + newAdminFeeMantissa + newFuseFeeMantissa ≤ reserveFactorPlusFeesMaxMantissa\n        if (add_(add_(reserveFactorMantissa, newAdminFeeMantissa), newFuseFeeMantissa) > reserveFactorPlusFeesMaxMantissa) {\n            return fail(Error.BAD_INPUT, FailureInfo.SET_ADMIN_FEE_BOUNDS_CHECK);\n        }\n\n        // If setting admin fee\n        if (adminFeeMantissa != newAdminFeeMantissa) {\n            // Check caller is admin\n            if (!hasAdminRights()) {\n                return fail(Error.UNAUTHORIZED, FailureInfo.SET_ADMIN_FEE_ADMIN_CHECK);\n            }\n\n            // Set admin fee\n            uint oldAdminFeeMantissa = adminFeeMantissa;\n            adminFeeMantissa = newAdminFeeMantissa;\n\n            // Emit event\n            emit NewAdminFee(oldAdminFeeMantissa, newAdminFeeMantissa);\n        }\n\n        // If setting Fuse fee\n        if (fuseFeeMantissa != newFuseFeeMantissa) {\n            // Set Fuse fee\n            uint oldFuseFeeMantissa = fuseFeeMantissa;\n            fuseFeeMantissa = newFuseFeeMantissa;\n\n            // Emit event\n            emit NewFuseFee(oldFuseFeeMantissa, newFuseFeeMantissa);\n        }\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n      * @dev Admin function to accrue interest and set a new reserve factor\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _setReserveFactor(uint newReserveFactorMantissa) override external nonReentrant(false) returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n        }\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n    }\n\n    /**\n      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\n      * @dev Admin function to set a new reserve factor\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n        // Check caller is admin\n        if (!hasAdminRights()) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n        }\n\n        // Verify market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n        }\n\n        // Check newReserveFactor ≤ maxReserveFactor\n        if (add_(add_(newReserveFactorMantissa, adminFeeMantissa), fuseFeeMantissa) > reserveFactorPlusFeesMaxMantissa) {\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n        }\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accrues interest and reduces reserves by transferring to admin\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _reduceReserves(uint reduceAmount) override external nonReentrant(false) returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n        }\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n        return _reduceReservesFresh(reduceAmount);\n    }\n\n    /**\n     * @notice Reduces reserves by transferring to admin\n     * @dev Requires fresh interest accrual\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n        // totalReserves - reduceAmount\n        uint totalReservesNew;\n\n        // Check caller is admin\n        if (!hasAdminRights()) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n        }\n\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n        }\n\n        // Fail gracefully if protocol has insufficient underlying cash\n        if (getCashPrior() < reduceAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n        }\n\n        // Check reduceAmount ≤ reserves[n] (totalReserves)\n        if (reduceAmount > totalReserves) {\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n        totalReservesNew = sub_(totalReserves, reduceAmount);\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n        totalReserves = totalReservesNew;\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n        doTransferOut(msg.sender, reduceAmount);\n\n        emit ReservesReduced(msg.sender, reduceAmount, totalReservesNew);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accrues interest and reduces Fuse fees by transferring to Fuse\n     * @param withdrawAmount Amount of fees to withdraw\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _withdrawFuseFees(uint withdrawAmount) external nonReentrant(false) returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted Fuse fee withdrawal failed.\n            return fail(Error(error), FailureInfo.WITHDRAW_FUSE_FEES_ACCRUE_INTEREST_FAILED);\n        }\n        // _withdrawFuseFeesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n        return _withdrawFuseFeesFresh(withdrawAmount);\n    }\n\n    /**\n     * @notice Reduces Fuse fees by transferring to Fuse\n     * @dev Requires fresh interest accrual\n     * @param withdrawAmount Amount of fees to withdraw\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _withdrawFuseFeesFresh(uint withdrawAmount) internal returns (uint) {\n        // totalFuseFees - reduceAmount\n        uint totalFuseFeesNew;\n\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.WITHDRAW_FUSE_FEES_FRESH_CHECK);\n        }\n\n        // Fail gracefully if protocol has insufficient underlying cash\n        if (getCashPrior() < withdrawAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.WITHDRAW_FUSE_FEES_CASH_NOT_AVAILABLE);\n        }\n\n        // Check withdrawAmount ≤ fuseFees[n] (totalFuseFees)\n        if (withdrawAmount > totalFuseFees) {\n            return fail(Error.BAD_INPUT, FailureInfo.WITHDRAW_FUSE_FEES_VALIDATION);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        // We checked withdrawAmount <= totalFuseFees above, so this should never revert.\n        totalFuseFeesNew = sub_(totalFuseFees, withdrawAmount);\n\n        // Store fuseFees[n+1] = fuseFees[n] - withdrawAmount\n        totalFuseFees = totalFuseFeesNew;\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n        doTransferOut(address(fuseAdmin), withdrawAmount);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accrues interest and reduces admin fees by transferring to admin\n     * @param withdrawAmount Amount of fees to withdraw\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _withdrawAdminFees(uint withdrawAmount) external nonReentrant(false) returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted admin fee withdrawal failed.\n            return fail(Error(error), FailureInfo.WITHDRAW_ADMIN_FEES_ACCRUE_INTEREST_FAILED);\n        }\n        // _withdrawAdminFeesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n        return _withdrawAdminFeesFresh(withdrawAmount);\n    }\n\n    /**\n     * @notice Reduces admin fees by transferring to admin\n     * @dev Requires fresh interest accrual\n     * @param withdrawAmount Amount of fees to withdraw\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _withdrawAdminFeesFresh(uint withdrawAmount) internal returns (uint) {\n        // totalAdminFees - reduceAmount\n        uint totalAdminFeesNew;\n\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.WITHDRAW_ADMIN_FEES_FRESH_CHECK);\n        }\n\n        // Fail gracefully if protocol has insufficient underlying cash\n        if (getCashPrior() < withdrawAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.WITHDRAW_ADMIN_FEES_CASH_NOT_AVAILABLE);\n        }\n\n        // Check withdrawAmount ≤ adminFees[n] (totalAdminFees)\n        if (withdrawAmount > totalAdminFees) {\n            return fail(Error.BAD_INPUT, FailureInfo.WITHDRAW_ADMIN_FEES_VALIDATION);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        // We checked withdrawAmount <= totalAdminFees above, so this should never revert.\n        totalAdminFeesNew = sub_(totalAdminFees, withdrawAmount);\n\n        // Store adminFees[n+1] = adminFees[n] - withdrawAmount\n        totalAdminFees = totalAdminFeesNew;\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n        doTransferOut(address(uint160(UnitrollerAdminStorage(address(comptroller)).admin())), withdrawAmount);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\n     * @dev Admin function to accrue interest and update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) override public returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n        }\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n        return _setInterestRateModelFresh(newInterestRateModel);\n    }\n\n    /**\n     * @notice updates the interest rate model (*requires fresh interest accrual)\n     * @dev Admin function to update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n        // Used to store old model for use in the event that is emitted on success\n        InterestRateModel oldInterestRateModel;\n\n        // Check caller is admin\n        if (!hasAdminRights()) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n        }\n\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n        }\n\n        // Track the market's current interest rate model\n        oldInterestRateModel = interestRateModel;\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n        // Set the interest rate model to newInterestRateModel\n        interestRateModel = newInterestRateModel;\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n        // Attempt to reset interest checkpoints on old IRM\n        if (address(oldInterestRateModel) != address(0)) address(oldInterestRateModel).call(abi.encodeWithSignature(\"resetInterestCheckpoints()\"));\n\n        // Attempt to add first interest checkpoint on new IRM\n        address(newInterestRateModel).call(abi.encodeWithSignature(\"checkpointInterest()\"));\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice updates the cToken ERC20 name and symbol\n     * @dev Admin function to update the cToken ERC20 name and symbol\n     * @param _name the new ERC20 token name to use\n     * @param _symbol the new ERC20 token symbol to use\n     */\n    function _setNameAndSymbol(string calldata _name, string calldata _symbol) external {\n        // Check caller is admin\n        require(hasAdminRights(), \"caller not admin\");\n\n        // Set ERC20 name and symbol\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying owned by this contract\n     */\n    function getCashPrior() virtual internal view returns (uint) {\n        return 0;\n    }\n\n    /**\n     * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\n     *  This may revert due to insufficient balance or insufficient allowance.\n     */\n    function doTransferIn(address from, uint amount) virtual internal returns (uint) {\n      return 1;\n    }\n\n    /**\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.\n     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\n     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\n     */\n    function doTransferOut(address payable to, uint amount) virtual internal {}\n\n\n    /*** Reentrancy Guard ***/\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     */\n    modifier nonReentrant(bool localOnly) {\n        _beforeNonReentrant(localOnly);\n        _;\n        _afterNonReentrant(localOnly);\n    }\n\n    /**\n     * @dev Split off from `nonReentrant` to keep contract below the 24 KB size limit.\n     * Saves space because function modifier code is \"inlined\" into every function with the modifier).\n     * In this specific case, the optimization saves around 1500 bytes of that valuable 24 KB limit.\n     */\n    function _beforeNonReentrant(bool localOnly) private {\n        require(_notEntered, \"re-entered\");\n        if (!localOnly) comptroller._beforeNonReentrant();\n        _notEntered = false;\n    }\n\n    /**\n     * @dev Split off from `nonReentrant` to keep contract below the 24 KB size limit.\n     * Saves space because function modifier code is \"inlined\" into every function with the modifier).\n     * In this specific case, the optimization saves around 150 bytes of that valuable 24 KB limit.\n     */\n    function _afterNonReentrant(bool localOnly) private {\n        _notEntered = true; // get a gas-refund post-Istanbul\n        if (!localOnly) comptroller._afterNonReentrant();\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     * @param errorMessage The revert string to return on failure.\n     */\n    function _functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.call(data);\n\n        if (!success) {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n\n        return returndata;\n    }\n}\n"
    },
    "contracts/compound/CErc20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"./CToken.sol\";\n\ninterface CompLike {\n  function delegate(address delegatee) external;\n}\n\n/**\n * @title Compound's CErc20 Contract\n * @notice CTokens which wrap an EIP-20 underlying\n * @dev This contract should not to be deployed on its own; instead, deploy `CErc20Delegator` (proxy contract) and `CErc20Delegate` (logic/implementation contract).\n * @author Compound\n */\ncontract CErc20 is CToken, CErc20Interface {\n    /**\n     * @notice Initialize the new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     */\n    function initialize(address underlying_,\n                        ComptrollerInterface comptroller_,\n                        InterestRateModel interestRateModel_,\n                        string memory name_,\n                        string memory symbol_,\n                        uint256 reserveFactorMantissa_,\n                        uint256 adminFeeMantissa_) public {\n        // CToken initialize does the bulk of the work\n        uint256 initialExchangeRateMantissa_ = 0.2e18;\n        uint8 decimals_ = EIP20Interface(underlying_).decimals();\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, reserveFactorMantissa_, adminFeeMantissa_);\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        EIP20Interface(underlying).totalSupply();\n    }\n\n    /*** User Interface ***/\n\n    /**\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function mint(uint mintAmount) override external returns (uint) {\n        (uint err,) = mintInternal(mintAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeem(uint redeemTokens) override external returns (uint) {\n        return redeemInternal(redeemTokens);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlying(uint redeemAmount) override external returns (uint) {\n        return redeemUnderlyingInternal(redeemAmount);\n    }\n\n    /**\n      * @notice Sender borrows assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function borrow(uint borrowAmount) override external returns (uint) {\n        return borrowInternal(borrowAmount);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrow(uint repayAmount) override external returns (uint) {\n        (uint err,) = repayBorrowInternal(repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrowBehalf(address borrower, uint repayAmount) override external returns (uint) {\n        (uint err,) = repayBorrowBehalfInternal(borrower, repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) override external returns (uint) {\n        (uint err,) = liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\n        return err;\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior() override virtual internal view returns (uint) {\n        EIP20Interface token = EIP20Interface(underlying);\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferIn(address from, uint amount) override virtual internal returns (uint) {\n        uint balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n        _callOptionalReturn(abi.encodeWithSelector(EIP20NonStandardInterface(underlying).transferFrom.selector, from, address(this), amount), \"TOKEN_TRANSFER_IN_FAILED\");\n\n        // Calculate the amount that was *actually* transferred\n        uint balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n        require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\n        return balanceAfter - balanceBefore;   // underflow already checked above, just subtract\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n     *      it is >= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferOut(address payable to, uint amount) override virtual internal {\n        _callOptionalReturn(abi.encodeWithSelector(EIP20NonStandardInterface(underlying).transfer.selector, to, amount), \"TOKEN_TRANSFER_OUT_FAILED\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     * @param errorMessage The revert string to return on failure.\n     */\n    function _callOptionalReturn(bytes memory data, string memory errorMessage) internal {\n        bytes memory returndata = _functionCall(underlying, data, errorMessage);\n        if (returndata.length > 0) require(abi.decode(returndata, (bool)), errorMessage);\n    }\n\n    /**\n    * @notice Admin call to delegate the votes of the COMP-like underlying\n    * @param compLikeDelegatee The address to delegate votes to\n    * @dev CTokens whose underlying are not CompLike should revert here\n    */\n    function _delegateCompLikeTo(address compLikeDelegatee) external {\n        require(hasAdminRights(), \"only the admin may set the comp-like delegate\");\n        CompLike(underlying).delegate(compLikeDelegatee);\n    }\n}\n"
    },
    "contracts/compound/ErrorReporter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\ncontract ComptrollerErrorReporter {\n    enum Error {\n        NO_ERROR,\n        UNAUTHORIZED,\n        COMPTROLLER_MISMATCH,\n        INSUFFICIENT_SHORTFALL,\n        INSUFFICIENT_LIQUIDITY,\n        INVALID_CLOSE_FACTOR,\n        INVALID_COLLATERAL_FACTOR,\n        INVALID_LIQUIDATION_INCENTIVE,\n        MARKET_NOT_ENTERED, // no longer possible\n        MARKET_NOT_LISTED,\n        MARKET_ALREADY_LISTED,\n        MATH_ERROR,\n        NONZERO_BORROW_BALANCE,\n        PRICE_ERROR,\n        REJECTION,\n        SNAPSHOT_ERROR,\n        TOO_MANY_ASSETS,\n        TOO_MUCH_REPAY,\n        SUPPLIER_NOT_WHITELISTED,\n        BORROW_BELOW_MIN,\n        SUPPLY_ABOVE_MAX,\n        NONZERO_TOTAL_SUPPLY\n    }\n\n    enum FailureInfo {\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\n        ADD_REWARDS_DISTRIBUTOR_OWNER_CHECK,\n        EXIT_MARKET_BALANCE_OWED,\n        EXIT_MARKET_REJECTION,\n        TOGGLE_ADMIN_RIGHTS_OWNER_CHECK,\n        TOGGLE_AUTO_IMPLEMENTATIONS_ENABLED_OWNER_CHECK,\n        SET_CLOSE_FACTOR_OWNER_CHECK,\n        SET_CLOSE_FACTOR_VALIDATION,\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\n        SET_COLLATERAL_FACTOR_NO_EXISTS,\n        SET_COLLATERAL_FACTOR_VALIDATION,\n        SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\n        SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\n        SET_LIQUIDATION_INCENTIVE_VALIDATION,\n        SET_MAX_ASSETS_OWNER_CHECK,\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SET_PENDING_IMPLEMENTATION_CONTRACT_CHECK,\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\n        SET_PRICE_ORACLE_OWNER_CHECK,\n        SET_WHITELIST_ENFORCEMENT_OWNER_CHECK,\n        SET_WHITELIST_STATUS_OWNER_CHECK,\n        SUPPORT_MARKET_EXISTS,\n        SUPPORT_MARKET_OWNER_CHECK,\n        SET_PAUSE_GUARDIAN_OWNER_CHECK,\n        UNSUPPORT_MARKET_OWNER_CHECK,\n        UNSUPPORT_MARKET_DOES_NOT_EXIST,\n        UNSUPPORT_MARKET_IN_USE\n    }\n\n    /**\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n      **/\n    event Failure(uint error, uint info, uint detail);\n\n    /**\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n      */\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n        emit Failure(uint(err), uint(info), 0);\n\n        return uint(err);\n    }\n\n    /**\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n      */\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\n        emit Failure(uint(err), uint(info), opaqueError);\n\n        return uint(err);\n    }\n}\n\ncontract TokenErrorReporter {\n    enum Error {\n        NO_ERROR,\n        UNAUTHORIZED,\n        BAD_INPUT,\n        COMPTROLLER_REJECTION,\n        COMPTROLLER_CALCULATION_ERROR,\n        INTEREST_RATE_MODEL_ERROR,\n        INVALID_ACCOUNT_PAIR,\n        INVALID_CLOSE_AMOUNT_REQUESTED,\n        INVALID_COLLATERAL_FACTOR,\n        MATH_ERROR,\n        MARKET_NOT_FRESH,\n        MARKET_NOT_LISTED,\n        TOKEN_INSUFFICIENT_ALLOWANCE,\n        TOKEN_INSUFFICIENT_BALANCE,\n        TOKEN_INSUFFICIENT_CASH,\n        TOKEN_TRANSFER_IN_FAILED,\n        TOKEN_TRANSFER_OUT_FAILED,\n        UTILIZATION_ABOVE_MAX\n    }\n\n    /*\n     * Note: FailureInfo (but not Error) is kept in alphabetical order\n     *       This is because FailureInfo grows significantly faster, and\n     *       the order of Error has some meaning, while the order of FailureInfo\n     *       is entirely arbitrary.\n     */\n    enum FailureInfo {\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n        ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_TOTAL_FUSE_FEES_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_TOTAL_ADMIN_FEES_CALCULATION_FAILED,\n        ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        BORROW_ACCRUE_INTEREST_FAILED,\n        BORROW_CASH_NOT_AVAILABLE,\n        BORROW_FRESHNESS_CHECK,\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n        BORROW_MARKET_NOT_LISTED,\n        BORROW_COMPTROLLER_REJECTION,\n        LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\n        LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\n        LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\n        LIQUIDATE_COMPTROLLER_REJECTION,\n        LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\n        LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\n        LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\n        LIQUIDATE_FRESHNESS_CHECK,\n        LIQUIDATE_LIQUIDATOR_IS_BORROWER,\n        LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\n        LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\n        LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\n        LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,\n        LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\n        LIQUIDATE_SEIZE_TOO_MUCH,\n        MINT_ACCRUE_INTEREST_FAILED,\n        MINT_COMPTROLLER_REJECTION,\n        MINT_EXCHANGE_CALCULATION_FAILED,\n        MINT_EXCHANGE_RATE_READ_FAILED,\n        MINT_FRESHNESS_CHECK,\n        MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n        MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n        MINT_TRANSFER_IN_FAILED,\n        MINT_TRANSFER_IN_NOT_POSSIBLE,\n        NEW_UTILIZATION_RATE_ABOVE_MAX,\n        REDEEM_ACCRUE_INTEREST_FAILED,\n        REDEEM_COMPTROLLER_REJECTION,\n        REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n        REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n        REDEEM_EXCHANGE_RATE_READ_FAILED,\n        REDEEM_FRESHNESS_CHECK,\n        REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n        REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n        REDEEM_TRANSFER_OUT_NOT_POSSIBLE,\n        WITHDRAW_FUSE_FEES_ACCRUE_INTEREST_FAILED,\n        WITHDRAW_FUSE_FEES_CASH_NOT_AVAILABLE,\n        WITHDRAW_FUSE_FEES_FRESH_CHECK,\n        WITHDRAW_FUSE_FEES_VALIDATION,\n        WITHDRAW_ADMIN_FEES_ACCRUE_INTEREST_FAILED,\n        WITHDRAW_ADMIN_FEES_CASH_NOT_AVAILABLE,\n        WITHDRAW_ADMIN_FEES_FRESH_CHECK,\n        WITHDRAW_ADMIN_FEES_VALIDATION,\n        REDUCE_RESERVES_ACCRUE_INTEREST_FAILED,\n        REDUCE_RESERVES_ADMIN_CHECK,\n        REDUCE_RESERVES_CASH_NOT_AVAILABLE,\n        REDUCE_RESERVES_FRESH_CHECK,\n        REDUCE_RESERVES_VALIDATION,\n        REPAY_BEHALF_ACCRUE_INTEREST_FAILED,\n        REPAY_BORROW_ACCRUE_INTEREST_FAILED,\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_COMPTROLLER_REJECTION,\n        REPAY_BORROW_FRESHNESS_CHECK,\n        REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\n        SET_COLLATERAL_FACTOR_VALIDATION,\n        SET_COMPTROLLER_OWNER_CHECK,\n        SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,\n        SET_INTEREST_RATE_MODEL_FRESH_CHECK,\n        SET_INTEREST_RATE_MODEL_OWNER_CHECK,\n        SET_MAX_ASSETS_OWNER_CHECK,\n        SET_ORACLE_MARKET_NOT_LISTED,\n        TOGGLE_ADMIN_RIGHTS_OWNER_CHECK,\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SET_ADMIN_FEE_ACCRUE_INTEREST_FAILED,\n        SET_ADMIN_FEE_ADMIN_CHECK,\n        SET_ADMIN_FEE_FRESH_CHECK,\n        SET_ADMIN_FEE_BOUNDS_CHECK,\n        SET_FUSE_FEE_ACCRUE_INTEREST_FAILED,\n        SET_FUSE_FEE_FRESH_CHECK,\n        SET_FUSE_FEE_BOUNDS_CHECK,\n        SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\n        SET_RESERVE_FACTOR_ADMIN_CHECK,\n        SET_RESERVE_FACTOR_FRESH_CHECK,\n        SET_RESERVE_FACTOR_BOUNDS_CHECK,\n        TRANSFER_COMPTROLLER_REJECTION,\n        TRANSFER_NOT_ALLOWED,\n        TRANSFER_NOT_ENOUGH,\n        TRANSFER_TOO_MUCH,\n        ADD_RESERVES_ACCRUE_INTEREST_FAILED,\n        ADD_RESERVES_FRESH_CHECK,\n        ADD_RESERVES_TRANSFER_IN_NOT_POSSIBLE\n    }\n\n    /**\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n      **/\n    event Failure(uint error, uint info, uint detail);\n\n    /**\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n      */\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n        emit Failure(uint(err), uint(info), 0);\n\n        return uint(err);\n    }\n\n    /**\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n      */\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\n        emit Failure(uint(err), uint(info), opaqueError);\n\n        return err == Error.COMPTROLLER_REJECTION ? 1000 + opaqueError : uint(err);\n    }\n}"
    },
    "contracts/compound/PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"./CToken.sol\";\n\nabstract contract PriceOracle {\n    /// @notice Indicator that this is a PriceOracle contract (for inspection)\n    bool public constant isPriceOracle = true;\n\n    /**\n      * @notice Get the underlying price of a cToken asset\n      * @param cToken The cToken to get the underlying price of\n      * @return The underlying asset price mantissa (scaled by 1e18).\n      *  Zero means the price is unavailable.\n      */\n    function getUnderlyingPrice(CToken cToken) virtual external view returns (uint);\n}\n"
    },
    "contracts/compound/ComptrollerInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nabstract contract ComptrollerInterface {\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\n    bool public constant isComptroller = true;\n\n    /*** Assets You Are In ***/\n\n    function enterMarkets(address[] calldata cTokens) virtual external returns (uint[] memory);\n    function exitMarket(address cToken) virtual external returns (uint);\n\n    /*** Policy Hooks ***/\n\n    function mintAllowed(address cToken, address minter, uint mintAmount) virtual external returns (uint);\n    function mintWithinLimits(address cToken, uint exchangeRateMantissa, uint accountTokens, uint mintAmount) virtual external returns (uint);\n    function mintVerify(address cToken, address minter, uint mintAmount, uint mintTokens) virtual external;\n\n    function redeemAllowed(address cToken, address redeemer, uint redeemTokens) virtual external returns (uint);\n    function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) virtual external;\n\n    function borrowAllowed(address cToken, address borrower, uint borrowAmount) virtual external returns (uint);\n    function borrowWithinLimits(address cToken, uint accountBorrowsNew) virtual external returns (uint);\n    function borrowVerify(address cToken, address borrower, uint borrowAmount) virtual external;\n\n    function repayBorrowAllowed(\n        address cToken,\n        address payer,\n        address borrower,\n        uint repayAmount) virtual external returns (uint);\n    function repayBorrowVerify(\n        address cToken,\n        address payer,\n        address borrower,\n        uint repayAmount,\n        uint borrowerIndex) virtual external;\n\n    function liquidateBorrowAllowed(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint repayAmount) virtual external returns (uint);\n    function liquidateBorrowVerify(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint repayAmount,\n        uint seizeTokens) virtual external;\n\n    function seizeAllowed(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint seizeTokens) virtual external returns (uint);\n    function seizeVerify(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint seizeTokens) virtual external;\n\n    function transferAllowed(address cToken, address src, address dst, uint transferTokens) virtual external returns (uint);\n    function transferVerify(address cToken, address src, address dst, uint transferTokens) virtual external;\n\n    /*** Liquidity/Liquidation Calculations ***/\n\n    function liquidateCalculateSeizeTokens(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        uint repayAmount) virtual external view returns (uint, uint);\n    \n    /*** Pool-Wide/Cross-Asset Reentrancy Prevention ***/\n\n    function _beforeNonReentrant() virtual external;\n    function _afterNonReentrant() virtual external;\n}\n"
    },
    "contracts/compound/ComptrollerStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"./IFuseFeeDistributor.sol\";\nimport \"./CToken.sol\";\nimport \"./PriceOracle.sol\";\n\ncontract UnitrollerAdminStorage {\n    /*\n     * Administrator for Fuse\n     */\n    IFuseFeeDistributor internal constant fuseAdmin = IFuseFeeDistributor(0x374aDc9EC5a177694AC805cB57E5a2A61217C1AB);\n\n    /**\n    * @notice Administrator for this contract\n    */\n    address public admin;\n\n    /**\n    * @notice Pending administrator for this contract\n    */\n    address public pendingAdmin;\n\n    /**\n     * @notice Whether or not the Fuse admin has admin rights\n     */\n    bool public fuseAdminHasRights = true;\n\n    /**\n     * @notice Whether or not the admin has admin rights\n     */\n    bool public adminHasRights = true;\n\n    /**\n     * @notice Returns a boolean indicating if the sender has admin rights\n     */\n    function hasAdminRights() internal view returns (bool) {\n        return (msg.sender == admin && adminHasRights) || (msg.sender == address(fuseAdmin) && fuseAdminHasRights);\n    }\n\n    /**\n    * @notice Active brains of Unitroller\n    */\n    address public comptrollerImplementation;\n\n    /**\n    * @notice Pending brains of Unitroller\n    */\n    address public pendingComptrollerImplementation;\n}\n\ncontract ComptrollerV1Storage is UnitrollerAdminStorage {\n    /**\n     * @notice Oracle which gives the price of any given asset\n     */\n    PriceOracle public oracle;\n\n    /**\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n     */\n    uint public closeFactorMantissa;\n\n    /**\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\n     */\n    uint public liquidationIncentiveMantissa;\n\n    /*\n     * UNUSED AFTER UPGRADE: Max number of assets a single account can participate in (borrow or use as collateral)\n     */\n    uint internal maxAssets;\n\n    /**\n     * @notice Per-account mapping of \"assets you are in\", capped by maxAssets\n     */\n    mapping(address => CToken[]) public accountAssets;\n\n}\n\ncontract ComptrollerV2Storage is ComptrollerV1Storage {\n    struct Market {\n        // Whether or not this market is listed\n        bool isListed;\n\n        // Multiplier representing the most one can borrow against their collateral in this market.\n        // For instance, 0.9 to allow borrowing 90% of collateral value.\n        // Must be between 0 and 1, and stored as a mantissa.\n        uint collateralFactorMantissa;\n\n        // Per-market mapping of \"accounts in this asset\"\n        mapping(address => bool) accountMembership;\n    }\n\n    /**\n     * @notice Official mapping of cTokens -> Market metadata\n     * @dev Used e.g. to determine if a market is supported\n     */\n    mapping(address => Market) public markets;\n\n    /// @notice A list of all markets\n    CToken[] public allMarkets;\n\n    /**\n     * @dev Maps borrowers to booleans indicating if they have entered any markets\n     */\n    mapping(address => bool) internal borrowers;\n\n    /// @notice A list of all borrowers who have entered markets\n    address[] public allBorrowers;\n\n    // Indexes of borrower account addresses in the `allBorrowers` array\n    mapping(address => uint256) internal borrowerIndexes;\n\n    /**\n     * @dev Maps suppliers to booleans indicating if they have ever supplied to any markets\n     */\n    mapping(address => bool) public suppliers;\n\n    /// @notice All cTokens addresses mapped by their underlying token addresses\n    mapping(address => CToken) public cTokensByUnderlying;\n\n    /// @notice Whether or not the supplier whitelist is enforced\n    bool public enforceWhitelist;\n\n    /// @notice Maps addresses to booleans indicating if they are allowed to supply assets (i.e., mint cTokens)\n    mapping(address => bool) public whitelist;\n\n    /// @notice An array of all whitelisted accounts\n    address[] public whitelistArray;\n\n    // Indexes of account addresses in the `whitelistArray` array\n    mapping(address => uint256) internal whitelistIndexes;\n\n    /**\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\n     *  Actions which allow users to remove their own assets cannot be paused.\n     *  Liquidation / seizing / transfer can only be paused globally, not by market.\n     */\n    address public pauseGuardian;\n    bool public _mintGuardianPaused;\n    bool public _borrowGuardianPaused;\n    bool public transferGuardianPaused;\n    bool public seizeGuardianPaused;\n    mapping(address => bool) public mintGuardianPaused;\n    mapping(address => bool) public borrowGuardianPaused;\n}\n\ncontract ComptrollerV3Storage is ComptrollerV2Storage {\n    /**\n     * @dev Whether or not the implementation should be auto-upgraded.\n     */\n    bool public autoImplementation;\n\n    /// @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\n    address public borrowCapGuardian;\n\n    /// @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.\n    mapping(address => uint) public borrowCaps;\n\n    /// @notice Supply caps enforced by mintAllowed for each cToken address. Defaults to zero which corresponds to unlimited supplying.\n    mapping(address => uint) public supplyCaps;\n\n    /// @notice RewardsDistributor contracts to notify of flywheel changes.\n    address[] public rewardsDistributors;\n\n    /// @dev Guard variable for pool-wide/cross-asset re-entrancy checks\n    bool internal _notEntered;\n\n    /// @dev Whether or not _notEntered has been initialized\n    bool internal _notEnteredInitialized;\n}\n"
    },
    "contracts/compound/Unitroller.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"./ErrorReporter.sol\";\nimport \"./ComptrollerStorage.sol\";\n\n/**\n * @title Unitroller\n * @dev Storage for the comptroller is at this address, while execution is delegated to the `comptrollerImplementation`.\n * CTokens should reference this contract as their comptroller.\n */\ncontract Unitroller is UnitrollerAdminStorage, ComptrollerErrorReporter {\n    /**\n      * @notice Emitted when pendingComptrollerImplementation is changed\n      */\n    event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\n\n    /**\n      * @notice Emitted when pendingComptrollerImplementation is accepted, which means comptroller implementation is updated\n      */\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n    /**\n      * @notice Event emitted when the Fuse admin rights are changed\n      */\n    event FuseAdminRightsToggled(bool hasRights);\n\n    /**\n      * @notice Event emitted when the admin rights are changed\n      */\n    event AdminRightsToggled(bool hasRights);\n\n    /**\n      * @notice Emitted when pendingAdmin is changed\n      */\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /**\n      * @notice Emitted when pendingAdmin is accepted, which means admin is updated\n      */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    constructor() {\n        // Set admin to caller\n        admin = msg.sender;\n    }\n\n    /*** Admin Functions ***/\n\n    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n        if (!hasAdminRights()) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n        }\n        if (!fuseAdmin.comptrollerImplementationWhitelist(comptrollerImplementation, newPendingImplementation)) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_CONTRACT_CHECK);\n        }\n        address oldPendingImplementation = pendingComptrollerImplementation;\n        pendingComptrollerImplementation = newPendingImplementation;\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n    * @notice Accepts new implementation of comptroller. msg.sender must be pendingImplementation\n    * @dev Admin function for new implementation to accept it's role as implementation\n    * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n    */\n    function _acceptImplementation() public returns (uint) {\n        // Check caller is pendingImplementation and pendingImplementation ≠ address(0)\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n        }\n\n        // Save current values for inclusion in log\n        address oldImplementation = comptrollerImplementation;\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n        pendingComptrollerImplementation = address(0);\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Toggles Fuse admin rights.\n      * @param hasRights Boolean indicating if the Fuse admin is to have rights.\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _toggleFuseAdminRights(bool hasRights) external returns (uint) {\n        // Check caller = admin\n        if (!hasAdminRights()) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.TOGGLE_ADMIN_RIGHTS_OWNER_CHECK);\n        }\n\n        // Check that rights have not already been set to the desired value\n        if (fuseAdminHasRights == hasRights) return uint(Error.NO_ERROR);\n\n        // Set fuseAdminHasRights\n        fuseAdminHasRights = hasRights;\n\n        // Emit FuseAdminRightsToggled()\n        emit FuseAdminRightsToggled(fuseAdminHasRights);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Toggles admin rights.\n      * @param hasRights Boolean indicating if the admin is to have rights.\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _toggleAdminRights(bool hasRights) external returns (uint) {\n        // Check caller = admin\n        if (!hasAdminRights()) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.TOGGLE_ADMIN_RIGHTS_OWNER_CHECK);\n        }\n\n        // Check that rights have not already been set to the desired value\n        if (adminHasRights == hasRights) return uint(Error.NO_ERROR);\n\n        // Set adminHasRights\n        adminHasRights = hasRights;\n\n        // Emit AdminRightsToggled()\n        emit AdminRightsToggled(hasRights);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n      * @param newPendingAdmin New pending admin.\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n        // Check caller = admin\n        if (!hasAdminRights()) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n        }\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n      * @dev Admin function for pending admin to accept role and update admin\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _acceptAdmin() public returns (uint) {\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n        }\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Delegates execution to an implementation contract.\n     * It returns to the external caller whatever the implementation returns\n     * or forwards reverts.\n     */\n    fallback () payable external {\n        // Check for automatic implementation\n        if (msg.sender != address(this)) {\n            (bool callSuccess, bytes memory data) = address(this).staticcall(abi.encodeWithSignature(\"autoImplementation()\"));\n            bool autoImplementation;\n            if (callSuccess) (autoImplementation) = abi.decode(data, (bool));\n\n            if (autoImplementation) {\n                address latestComptrollerImplementation = fuseAdmin.latestComptrollerImplementation(comptrollerImplementation);\n\n                if (comptrollerImplementation != latestComptrollerImplementation) {\n                    address oldImplementation = comptrollerImplementation; // Save current value for inclusion in log\n                    comptrollerImplementation = latestComptrollerImplementation;\n                    emit NewImplementation(oldImplementation, comptrollerImplementation);\n                }\n            }\n        }\n\n        // delegate all other functions to current implementation\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n        assembly {\n              let free_mem_ptr := mload(0x40)\n              returndatacopy(free_mem_ptr, 0, returndatasize())\n\n              switch success\n              case 0 { revert(free_mem_ptr, returndatasize()) }\n              default { return(free_mem_ptr, returndatasize()) }\n        }\n    }\n}\n"
    },
    "contracts/compound/RewardsDistributorDelegate.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"./CToken.sol\";\nimport \"./ExponentialNoError.sol\";\nimport \"./Comptroller.sol\";\nimport \"./RewardsDistributorStorage.sol\";\n\n/**\n * @title RewardsDistributorDelegate (COMP distribution logic extracted from `Comptroller`)\n * @author Compound\n */\ncontract RewardsDistributorDelegate is RewardsDistributorDelegateStorageV1, ExponentialNoError {\n    /// @dev Notice that this contract is a RewardsDistributor\n    bool public constant isRewardsDistributor = true;\n\n    /// @notice Emitted when pendingAdmin is changed\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /// @notice Emitted when pendingAdmin is accepted, which means admin is updated\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /// @notice Emitted when a new COMP speed is calculated for a market\n    event CompSupplySpeedUpdated(CToken indexed cToken, uint newSpeed);\n\n    /// @notice Emitted when a new COMP speed is calculated for a market\n    event CompBorrowSpeedUpdated(CToken indexed cToken, uint newSpeed);\n\n    /// @notice Emitted when a new COMP speed is set for a contributor\n    event ContributorCompSpeedUpdated(address indexed contributor, uint newSpeed);\n\n    /// @notice Emitted when COMP is distributed to a supplier\n    event DistributedSupplierComp(CToken indexed cToken, address indexed supplier, uint compDelta, uint compSupplyIndex);\n\n    /// @notice Emitted when COMP is distributed to a borrower\n    event DistributedBorrowerComp(CToken indexed cToken, address indexed borrower, uint compDelta, uint compBorrowIndex);\n\n    /// @notice Emitted when COMP is granted by admin\n    event CompGranted(address recipient, uint amount);\n\n    /// @notice The initial COMP index for a market\n    uint224 public constant compInitialIndex = 1e36;\n\n    /// @dev Intitializer to set admin to caller and set reward token\n    function initialize(address _rewardToken) external {\n        require(msg.sender == admin, \"Only admin can initialize.\");\n        require(rewardToken == address(0), \"Already initialized.\");\n        require(_rewardToken != address(0), \"Cannot initialize reward token to the zero address.\");\n        rewardToken = _rewardToken;\n    }\n\n    /*** Set Admin ***/\n\n    /**\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n      * @param newPendingAdmin New pending admin.\n      */\n    function _setPendingAdmin(address newPendingAdmin) external {\n        // Check caller = admin\n        require(msg.sender == admin, \"RewardsDistributor:_setPendingAdmin: admin only\");\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n    }\n\n    /**\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n      * @dev Admin function for pending admin to accept role and update admin\n      */\n    function _acceptAdmin() external {\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n        require(msg.sender == pendingAdmin && msg.sender != address(0), \"RewardsDistributor:_acceptAdmin: pending admin only\");\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n    }\n\n    /*** Comp Distribution ***/\n\n    /**\n     * @notice Check the cToken before adding\n     * @param cToken The market to add\n     */\n    function checkCToken(CToken cToken) internal view {\n        // Make sure cToken is listed\n        Comptroller comptroller = Comptroller(address(cToken.comptroller()));\n        (bool isListed, ) = comptroller.markets(address(cToken));\n        require(isListed == true, \"comp market is not listed\");\n\n        // Make sure distributor is added\n        bool distributorAdded = false;\n        address[] memory distributors = comptroller.getRewardsDistributors();\n        for (uint256 i = 0; i < distributors.length; i++) if (distributors[i] == address(this)) distributorAdded = true; \n        require(distributorAdded == true, \"distributor not added\");\n    }\n\n    /**\n     * @notice Set COMP speed for a single market\n     * @param cToken The market whose COMP speed to update\n     * @param compSpeed New COMP speed for market\n     */\n    function setCompSupplySpeedInternal(CToken cToken, uint compSpeed) internal {\n        uint currentCompSpeed = compSupplySpeeds[address(cToken)];\n        if (currentCompSpeed != 0) {\n            // note that COMP speed could be set to 0 to halt liquidity rewards for a market\n            updateCompSupplyIndex(address(cToken));\n        } else if (compSpeed != 0) {\n            // Make sure cToken is listed and distributor is added\n            checkCToken(cToken);\n\n            // Add the COMP market\n            if (compSupplyState[address(cToken)].index == 0) {\n                compSupplyState[address(cToken)] = CompMarketState({\n                    index: compInitialIndex,\n                    block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n                });\n\n                // Add to allMarkets array if not already there\n                if (compBorrowState[address(cToken)].index == 0) {\n                    allMarkets.push(cToken);\n                }\n            } else {\n                // Update block number to ensure extra interest is not accrued during the prior period\n                compSupplyState[address(cToken)].block = safe32(getBlockNumber(), \"block number exceeds 32 bits\");\n            }\n        }\n\n        if (currentCompSpeed != compSpeed) {\n            compSupplySpeeds[address(cToken)] = compSpeed;\n            emit CompSupplySpeedUpdated(cToken, compSpeed);\n        }\n    }\n\n    /**\n     * @notice Set COMP speed for a single market\n     * @param cToken The market whose COMP speed to update\n     * @param compSpeed New COMP speed for market\n     */\n    function setCompBorrowSpeedInternal(CToken cToken, uint compSpeed) internal {\n        uint currentCompSpeed = compBorrowSpeeds[address(cToken)];\n        if (currentCompSpeed != 0) {\n            // note that COMP speed could be set to 0 to halt liquidity rewards for a market\n            Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});\n            updateCompBorrowIndex(address(cToken), borrowIndex);\n        } else if (compSpeed != 0) {\n            // Make sure cToken is listed and distributor is added\n            checkCToken(cToken);\n\n            // Add the COMP market\n            if (compBorrowState[address(cToken)].index == 0) {\n                compBorrowState[address(cToken)] = CompMarketState({\n                    index: compInitialIndex,\n                    block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n                });\n\n                // Add to allMarkets array if not already there\n                if (compSupplyState[address(cToken)].index == 0) {\n                    allMarkets.push(cToken);\n                }\n            } else {\n                // Update block number to ensure extra interest is not accrued during the prior period\n                compBorrowState[address(cToken)].block = safe32(getBlockNumber(), \"block number exceeds 32 bits\");\n            }\n        }\n\n        if (currentCompSpeed != compSpeed) {\n            compBorrowSpeeds[address(cToken)] = compSpeed;\n            emit CompBorrowSpeedUpdated(cToken, compSpeed);\n        }\n    }\n\n    /**\n     * @notice Accrue COMP to the market by updating the supply index\n     * @param cToken The market whose supply index to update\n     */\n    function updateCompSupplyIndex(address cToken) internal {\n        CompMarketState storage supplyState = compSupplyState[cToken];\n        uint supplySpeed = compSupplySpeeds[cToken];\n        uint blockNumber = getBlockNumber();\n        uint deltaBlocks = sub_(blockNumber, uint(supplyState.block));\n        if (deltaBlocks > 0 && supplySpeed > 0) {\n            uint supplyTokens = CToken(cToken).totalSupply();\n            uint compAccrued_ = mul_(deltaBlocks, supplySpeed);\n            Double memory ratio = supplyTokens > 0 ? fraction(compAccrued_, supplyTokens) : Double({mantissa: 0});\n            Double memory index = add_(Double({mantissa: supplyState.index}), ratio);\n            compSupplyState[cToken] = CompMarketState({\n                index: safe224(index.mantissa, \"new index exceeds 224 bits\"),\n                block: safe32(blockNumber, \"block number exceeds 32 bits\")\n            });\n        } else if (deltaBlocks > 0 && supplyState.index > 0) {\n            supplyState.block = safe32(blockNumber, \"block number exceeds 32 bits\");\n        }\n    }\n\n    /**\n     * @notice Accrue COMP to the market by updating the borrow index\n     * @param cToken The market whose borrow index to update\n     */\n    function updateCompBorrowIndex(address cToken, Exp memory marketBorrowIndex) internal {\n        CompMarketState storage borrowState = compBorrowState[cToken];\n        uint borrowSpeed = compBorrowSpeeds[cToken];\n        uint blockNumber = getBlockNumber();\n        uint deltaBlocks = sub_(blockNumber, uint(borrowState.block));\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\n            uint borrowAmount = div_(CToken(cToken).totalBorrows(), marketBorrowIndex);\n            uint compAccrued_ = mul_(deltaBlocks, borrowSpeed);\n            Double memory ratio = borrowAmount > 0 ? fraction(compAccrued_, borrowAmount) : Double({mantissa: 0});\n            Double memory index = add_(Double({mantissa: borrowState.index}), ratio);\n            compBorrowState[cToken] = CompMarketState({\n                index: safe224(index.mantissa, \"new index exceeds 224 bits\"),\n                block: safe32(blockNumber, \"block number exceeds 32 bits\")\n            });\n        } else if (deltaBlocks > 0 && borrowState.index > 0) {\n            borrowState.block = safe32(blockNumber, \"block number exceeds 32 bits\");\n        }\n    }\n\n    /**\n     * @notice Calculate COMP accrued by a supplier and possibly transfer it to them\n     * @param cToken The market in which the supplier is interacting\n     * @param supplier The address of the supplier to distribute COMP to\n     */\n    function distributeSupplierComp(address cToken, address supplier) internal {\n        CompMarketState storage supplyState = compSupplyState[cToken];\n        Double memory supplyIndex = Double({mantissa: supplyState.index});\n        Double memory supplierIndex = Double({mantissa: compSupplierIndex[cToken][supplier]});\n        compSupplierIndex[cToken][supplier] = supplyIndex.mantissa;\n\n        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\n            supplierIndex.mantissa = compInitialIndex;\n        }\n\n        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\n        uint supplierTokens = CToken(cToken).balanceOf(supplier);\n        uint supplierDelta = mul_(supplierTokens, deltaIndex);\n        uint supplierAccrued = add_(compAccrued[supplier], supplierDelta);\n        compAccrued[supplier] = supplierAccrued;\n        emit DistributedSupplierComp(CToken(cToken), supplier, supplierDelta, supplyIndex.mantissa);\n    }\n\n    /**\n     * @notice Calculate COMP accrued by a borrower and possibly transfer it to them\n     * @dev Borrowers will not begin to accrue until after the first interaction with the protocol.\n     * @param cToken The market in which the borrower is interacting\n     * @param borrower The address of the borrower to distribute COMP to\n     */\n    function distributeBorrowerComp(address cToken, address borrower, Exp memory marketBorrowIndex) internal {\n        CompMarketState storage borrowState = compBorrowState[cToken];\n        Double memory borrowIndex = Double({mantissa: borrowState.index});\n        Double memory borrowerIndex = Double({mantissa: compBorrowerIndex[cToken][borrower]});\n        compBorrowerIndex[cToken][borrower] = borrowIndex.mantissa;\n\n        if (borrowerIndex.mantissa > 0) {\n            Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\n            uint borrowerAmount = div_(CToken(cToken).borrowBalanceStored(borrower), marketBorrowIndex);\n            uint borrowerDelta = mul_(borrowerAmount, deltaIndex);\n            uint borrowerAccrued = add_(compAccrued[borrower], borrowerDelta);\n            compAccrued[borrower] = borrowerAccrued;\n            emit DistributedBorrowerComp(CToken(cToken), borrower, borrowerDelta, borrowIndex.mantissa);\n        }\n    }\n\n    /**\n     * @notice Keeps the flywheel moving pre-mint and pre-redeem\n     * @dev Called by the Comptroller\n     * @param cToken The relevant market\n     * @param supplier The minter/redeemer\n     */\n    function flywheelPreSupplierAction(address cToken, address supplier) external {\n        if (compSupplyState[cToken].index > 0) {\n            updateCompSupplyIndex(cToken);\n            distributeSupplierComp(cToken, supplier);\n        }\n    }\n\n    /**\n     * @notice Keeps the flywheel moving pre-borrow and pre-repay\n     * @dev Called by the Comptroller\n     * @param cToken The relevant market\n     * @param borrower The borrower\n     */\n    function flywheelPreBorrowerAction(address cToken, address borrower) external {\n        if (compBorrowState[cToken].index > 0) {\n            Exp memory borrowIndex = Exp({mantissa: CToken(cToken).borrowIndex()});\n            updateCompBorrowIndex(cToken, borrowIndex);\n            distributeBorrowerComp(cToken, borrower, borrowIndex);\n        }\n    }\n\n    /**\n     * @notice Keeps the flywheel moving pre-transfer and pre-seize\n     * @dev Called by the Comptroller\n     * @param cToken The relevant market\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     */\n    function flywheelPreTransferAction(address cToken, address src, address dst) external {\n        if (compSupplyState[cToken].index > 0) {\n            updateCompSupplyIndex(cToken);\n            distributeSupplierComp(cToken, src);\n            distributeSupplierComp(cToken, dst);\n        }\n    }\n\n    /**\n     * @notice Calculate additional accrued COMP for a contributor since last accrual\n     * @param contributor The address to calculate contributor rewards for\n     */\n    function updateContributorRewards(address contributor) public {\n        uint compSpeed = compContributorSpeeds[contributor];\n        uint blockNumber = getBlockNumber();\n        uint deltaBlocks = sub_(blockNumber, lastContributorBlock[contributor]);\n        if (deltaBlocks > 0 && compSpeed > 0) {\n            uint newAccrued = mul_(deltaBlocks, compSpeed);\n            uint contributorAccrued = add_(compAccrued[contributor], newAccrued);\n\n            compAccrued[contributor] = contributorAccrued;\n            lastContributorBlock[contributor] = blockNumber;\n        }\n    }\n\n    /**\n     * @notice Claim all the comp accrued by holder in all markets\n     * @param holder The address to claim COMP for\n     */\n    function claimRewards(address holder) public {\n        return claimRewards(holder, allMarkets);\n    }\n\n    /**\n     * @notice Claim all the comp accrued by holder in the specified markets\n     * @param holder The address to claim COMP for\n     * @param cTokens The list of markets to claim COMP in\n     */\n    function claimRewards(address holder, CToken[] memory cTokens) public {\n        address[] memory holders = new address[](1);\n        holders[0] = holder;\n        claimRewards(holders, cTokens, true, true);\n    }\n\n    /**\n     * @notice Claim all comp accrued by the holders\n     * @param holders The addresses to claim COMP for\n     * @param cTokens The list of markets to claim COMP in\n     * @param borrowers Whether or not to claim COMP earned by borrowing\n     * @param suppliers Whether or not to claim COMP earned by supplying\n     */\n    function claimRewards(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {\n        for (uint i = 0; i < cTokens.length; i++) {\n            CToken cToken = cTokens[i];\n            if (borrowers == true && compBorrowState[address(cToken)].index > 0) {\n                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});\n                updateCompBorrowIndex(address(cToken), borrowIndex);\n                for (uint j = 0; j < holders.length; j++) {\n                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);\n                }\n            }\n            if (suppliers == true && compSupplyState[address(cToken)].index > 0) {\n                updateCompSupplyIndex(address(cToken));\n                for (uint j = 0; j < holders.length; j++) {\n                    distributeSupplierComp(address(cToken), holders[j]);\n                }\n            }\n        }\n        for (uint j = 0; j < holders.length; j++) {\n            compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);\n        }\n    }\n\n    /**\n     * @notice Transfer COMP to the user\n     * @dev Note: If there is not enough COMP, we do not perform the transfer all.\n     * @param user The address of the user to transfer COMP to\n     * @param amount The amount of COMP to (possibly) transfer\n     * @return The amount of COMP which was NOT transferred to the user\n     */\n    function grantCompInternal(address user, uint amount) internal returns (uint) {\n        EIP20NonStandardInterface comp = EIP20NonStandardInterface(rewardToken);\n        uint compRemaining = comp.balanceOf(address(this));\n        if (amount > 0 && amount <= compRemaining) {\n            comp.transfer(user, amount);\n            return 0;\n        }\n        return amount;\n    }\n\n    /*** Comp Distribution Admin ***/\n\n    /**\n     * @notice Transfer COMP to the recipient\n     * @dev Note: If there is not enough COMP, we do not perform the transfer all.\n     * @param recipient The address of the recipient to transfer COMP to\n     * @param amount The amount of COMP to (possibly) transfer\n     */\n    function _grantComp(address recipient, uint amount) public {\n        require(msg.sender == admin, \"only admin can grant comp\");\n        uint amountLeft = grantCompInternal(recipient, amount);\n        require(amountLeft == 0, \"insufficient comp for grant\");\n        emit CompGranted(recipient, amount);\n    }\n\n    /**\n     * @notice Set COMP speed for a single market\n     * @param cToken The market whose COMP speed to update\n     * @param compSpeed New COMP speed for market\n     */\n    function _setCompSupplySpeed(CToken cToken, uint compSpeed) public {\n        require(msg.sender == admin, \"only admin can set comp speed\");\n        setCompSupplySpeedInternal(cToken, compSpeed);\n    }\n\n    /**\n     * @notice Set COMP speed for a single market\n     * @param cToken The market whose COMP speed to update\n     * @param compSpeed New COMP speed for market\n     */\n    function _setCompBorrowSpeed(CToken cToken, uint compSpeed) public {\n        require(msg.sender == admin, \"only admin can set comp speed\");\n        setCompBorrowSpeedInternal(cToken, compSpeed);\n    }\n\n    /**\n     * @notice Set COMP borrow and supply speeds for the specified markets.\n     * @param cTokens The markets whose COMP speed to update.\n     * @param supplySpeeds New supply-side COMP speed for the corresponding market.\n     * @param borrowSpeeds New borrow-side COMP speed for the corresponding market.\n     */\n    function _setCompSpeeds(CToken[] memory cTokens, uint[] memory supplySpeeds, uint[] memory borrowSpeeds) public {\n        require(msg.sender == admin, \"only admin can set comp speed\");\n\n        uint numTokens = cTokens.length;\n        require(numTokens == supplySpeeds.length && numTokens == borrowSpeeds.length, \"RewardsDistributor::_setCompSpeeds invalid input\");\n\n        for (uint i = 0; i < numTokens; ++i) {\n            setCompSupplySpeedInternal(cTokens[i], supplySpeeds[i]);\n            setCompBorrowSpeedInternal(cTokens[i], borrowSpeeds[i]);\n        }\n    }\n\n    /**\n     * @notice Set COMP speed for a single contributor\n     * @param contributor The contributor whose COMP speed to update\n     * @param compSpeed New COMP speed for contributor\n     */\n    function _setContributorCompSpeed(address contributor, uint compSpeed) public {\n        require(msg.sender == admin, \"only admin can set comp speed\");\n\n        // note that COMP speed could be set to 0 to halt liquidity rewards for a contributor\n        updateContributorRewards(contributor);\n        if (compSpeed == 0) {\n            // release storage\n            delete lastContributorBlock[contributor];\n        } else {\n            lastContributorBlock[contributor] = getBlockNumber();\n        }\n        compContributorSpeeds[contributor] = compSpeed;\n\n        emit ContributorCompSpeedUpdated(contributor, compSpeed);\n    }\n\n    /*** Helper Functions */\n\n    function getBlockNumber() public view returns (uint) {\n        return block.number;\n    }\n\n    /**\n     * @notice Returns an array of all markets.\n     */\n    function getAllMarkets() external view returns (CToken[] memory) {\n        return allMarkets;\n    }\n}\n"
    },
    "contracts/compound/CTokenInterfaces.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"./IFuseFeeDistributor.sol\";\nimport \"./ComptrollerStorage.sol\";\nimport \"./ComptrollerInterface.sol\";\nimport \"./InterestRateModel.sol\";\n\ncontract CTokenAdminStorage {\n    /*\n     * Administrator for Fuse\n     */\n    IFuseFeeDistributor internal constant fuseAdmin = IFuseFeeDistributor(0x374aDc9EC5a177694AC805cB57E5a2A61217C1AB);\n\n    /**\n     * @dev LEGACY USE ONLY: Administrator for this contract\n     */\n    address payable internal __admin;\n\n    /**\n     * @dev LEGACY USE ONLY: Whether or not the Fuse admin has admin rights\n     */\n    bool internal __fuseAdminHasRights;\n\n    /**\n     * @dev LEGACY USE ONLY: Whether or not the admin has admin rights\n     */\n    bool internal __adminHasRights;\n}\n\ncontract CTokenStorage is CTokenAdminStorage {\n    /**\n     * @dev Guard variable for re-entrancy checks\n     */\n    bool internal _notEntered;\n\n    /**\n     * @notice EIP-20 token name for this token\n     */\n    string public name;\n\n    /**\n     * @notice EIP-20 token symbol for this token\n     */\n    string public symbol;\n\n    /**\n     * @notice EIP-20 token decimals for this token\n     */\n    uint8 public decimals;\n\n    /*\n     * Maximum borrow rate that can ever be applied (.0005% / block)\n     */\n    uint internal constant borrowRateMaxMantissa = 0.0005e16;\n\n    /*\n     * Maximum fraction of interest that can be set aside for reserves + fees\n     */\n    uint internal constant reserveFactorPlusFeesMaxMantissa = 1e18;\n\n    /*\n     * LEGACY USE ONLY: Pending administrator for this contract\n     */\n    address payable private __pendingAdmin;\n\n    /**\n     * @notice Contract which oversees inter-cToken operations\n     */\n    ComptrollerInterface public comptroller;\n\n    /**\n     * @notice Model which tells what the current interest rate should be\n     */\n    InterestRateModel public interestRateModel;\n\n    /*\n     * Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\n     */\n    uint internal initialExchangeRateMantissa;\n\n    /**\n     * @notice Fraction of interest currently set aside for admin fees\n     */\n    uint public adminFeeMantissa;\n\n    /**\n     * @notice Fraction of interest currently set aside for Fuse fees\n     */\n    uint public fuseFeeMantissa;\n\n    /**\n     * @notice Fraction of interest currently set aside for reserves\n     */\n    uint public reserveFactorMantissa;\n\n    /**\n     * @notice Block number that interest was last accrued at\n     */\n    uint public accrualBlockNumber;\n\n    /**\n     * @notice Accumulator of the total earned interest rate since the opening of the market\n     */\n    uint public borrowIndex;\n\n    /**\n     * @notice Total amount of outstanding borrows of the underlying in this market\n     */\n    uint public totalBorrows;\n\n    /**\n     * @notice Total amount of reserves of the underlying held in this market\n     */\n    uint public totalReserves;\n\n    /**\n     * @notice Total amount of admin fees of the underlying held in this market\n     */\n    uint public totalAdminFees;\n\n    /**\n     * @notice Total amount of Fuse fees of the underlying held in this market\n     */\n    uint public totalFuseFees;\n\n    /**\n     * @notice Total number of tokens in circulation\n     */\n    uint public totalSupply;\n\n    /*\n     * Official record of token balances for each account\n     */\n    mapping (address => uint) internal accountTokens;\n\n    /*\n     * Approved token transfer amounts on behalf of others\n     */\n    mapping (address => mapping (address => uint)) internal transferAllowances;\n\n    /**\n     * @notice Container for borrow balance information\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\n     */\n    struct BorrowSnapshot {\n        uint principal;\n        uint interestIndex;\n    }\n\n    /*\n     * Mapping of account addresses to outstanding borrow balances\n     */\n    mapping(address => BorrowSnapshot) internal accountBorrows;\n\n    /*\n     * Share of seized collateral that is added to reserves\n     */\n    uint public constant protocolSeizeShareMantissa = 2.8e16; //2.8%\n\n    /*\n     * Share of seized collateral taken as fees\n     */\n    uint public constant feeSeizeShareMantissa = 1e17; //10%\n}\n\nabstract contract CTokenInterface is CTokenStorage {\n    /**\n     * @notice Indicator that this is a CToken contract (for inspection)\n     */\n    function isCToken() external virtual returns (bool) {\n        return true;\n    }\n\n    /**\n     * @notice Indicator that this is or is not a CEther contract (for inspection)\n     */\n    function isCEther() external virtual returns (bool) {\n        return false;\n    }\n\n    /*** Market Events ***/\n\n    /**\n     * @notice Event emitted when interest is accrued\n     */\n    event AccrueInterest(uint cashPrior, uint interestAccumulated, uint borrowIndex, uint totalBorrows);\n\n    /**\n     * @notice Event emitted when tokens are minted\n     */\n    event Mint(address minter, uint mintAmount, uint mintTokens);\n\n    /**\n     * @notice Event emitted when tokens are redeemed\n     */\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\n\n    /**\n     * @notice Event emitted when underlying is borrowed\n     */\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\n\n    /**\n     * @notice Event emitted when a borrow is repaid\n     */\n    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\n\n    /**\n     * @notice Event emitted when a borrow is liquidated\n     */\n    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);\n\n\n    /*** Admin Events ***/\n\n    /**\n     * @notice Event emitted when comptroller is changed\n     */\n    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\n\n    /**\n     * @notice Event emitted when interestRateModel is changed\n     */\n    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\n\n    /**\n     * @notice Event emitted when the reserve factor is changed\n     */\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\n\n    /**\n     * @notice Event emitted when the reserves are added\n     */\n    event ReservesAdded(address benefactor, uint addAmount, uint newTotalReserves);\n\n    /**\n     * @notice Event emitted when the reserves are reduced\n     */\n    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);\n\n    /**\n     * @notice Event emitted when the admin fee is changed\n     */\n    event NewAdminFee(uint oldAdminFeeMantissa, uint newAdminFeeMantissa);\n\n    /**\n     * @notice Event emitted when the Fuse fee is changed\n     */\n    event NewFuseFee(uint oldFuseFeeMantissa, uint newFuseFeeMantissa);\n\n    /**\n     * @notice EIP20 Transfer event\n     */\n    event Transfer(address indexed from, address indexed to, uint amount);\n\n    /**\n     * @notice EIP20 Approval event\n     */\n    event Approval(address indexed owner, address indexed spender, uint amount);\n\n\n    /*** User Interface ***/\n\n    function transfer(address dst, uint amount) virtual external returns (bool);\n    function transferFrom(address src, address dst, uint amount) virtual external returns (bool);\n    function approve(address spender, uint amount) virtual external returns (bool);\n    function allowance(address owner, address spender) external virtual view returns (uint);\n    function balanceOf(address owner) external virtual view returns (uint);\n    function balanceOfUnderlying(address owner) virtual external returns (uint);\n    function getAccountSnapshot(address account) virtual external view returns (uint, uint, uint, uint);\n    function borrowRatePerBlock() external virtual view returns (uint);\n    function supplyRatePerBlock() external virtual view returns (uint);\n    function totalBorrowsCurrent() virtual external returns (uint);\n    function borrowBalanceCurrent(address account) virtual external returns (uint);\n    function borrowBalanceStored(address account) public virtual view returns (uint);\n    function exchangeRateCurrent() virtual public returns (uint);\n    function exchangeRateStored() public virtual view returns (uint);\n    function getCash() external virtual view returns (uint);\n    function accrueInterest() virtual public returns (uint);\n    function seize(address liquidator, address borrower, uint seizeTokens) virtual external returns (uint);\n\n\n    /*** Admin Functions ***/\n\n    function _setReserveFactor(uint newReserveFactorMantissa) virtual external returns (uint);\n    function _reduceReserves(uint reduceAmount) virtual external returns (uint);\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) virtual public returns (uint);\n}\n\ncontract CErc20Storage {\n    /**\n     * @notice Underlying asset for this CToken\n     */\n    address public underlying;\n}\n\nabstract contract CErc20Interface is CErc20Storage {\n\n    /*** User Interface ***/\n\n    function mint(uint mintAmount) virtual external returns (uint);\n    function redeem(uint redeemTokens) virtual external returns (uint);\n    function redeemUnderlying(uint redeemAmount) virtual external returns (uint);\n    function borrow(uint borrowAmount) virtual external returns (uint);\n    function repayBorrow(uint repayAmount) virtual external returns (uint);\n    function repayBorrowBehalf(address borrower, uint repayAmount) virtual external returns (uint);\n    function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) virtual external returns (uint);\n\n}\n\ncontract CEtherInterface is CErc20Storage {}\n"
    },
    "contracts/compound/EIP20Interface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\n/**\n * @title ERC 20 Token Standard Interface\n *  https://eips.ethereum.org/EIPS/eip-20\n */\ninterface EIP20Interface {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n\n    /**\n      * @notice Get the total number of tokens in circulation\n      * @return uint256 The supply of tokens\n      */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice Gets the balance of the specified address\n     * @param owner The address from which the balance will be retrieved\n     * @return balance uint256 The balance\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n      * @param dst The address of the destination account\n      * @param amount The number of tokens to transfer\n      * @return success bool Whether or not the transfer succeeded\n      */\n    function transfer(address dst, uint256 amount) external returns (bool success);\n\n    /**\n      * @notice Transfer `amount` tokens from `src` to `dst`\n      * @param src The address of the source account\n      * @param dst The address of the destination account\n      * @param amount The number of tokens to transfer\n      * @return success bool Whether or not the transfer succeeded\n      */\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool success);\n\n    /**\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n      * @dev This will overwrite the approval amount for `spender`\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n      * @param spender The address of the account which may transfer tokens\n      * @param amount The number of tokens that are approved (-1 means infinite)\n      * @return success bool Whether or not the approval succeeded\n      */\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n    /**\n      * @notice Get the current allowance from `owner` for `spender`\n      * @param owner The address of the account which owns the tokens to be spent\n      * @param spender The address of the account which may transfer tokens\n      * @return remaining uint256 The number of tokens allowed to be spent (-1 means infinite)\n      */\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n}\n"
    },
    "contracts/compound/EIP20NonStandardInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\n/**\n * @title EIP20NonStandardInterface\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n */\ninterface EIP20NonStandardInterface {\n\n    /**\n     * @notice Get the total number of tokens in circulation\n     * @return The supply of tokens\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice Gets the balance of the specified address\n     * @param owner The address from which the balance will be retrieved\n     * @return balance uint256 The balance\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    ///\n    /// !!!!!!!!!!!!!!\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n    /// !!!!!!!!!!!!!!\n    ///\n\n    /**\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n      * @param dst The address of the destination account\n      * @param amount The number of tokens to transfer\n      */\n    function transfer(address dst, uint256 amount) external;\n\n    ///\n    /// !!!!!!!!!!!!!!\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n    /// !!!!!!!!!!!!!!\n    ///\n\n    /**\n      * @notice Transfer `amount` tokens from `src` to `dst`\n      * @param src The address of the source account\n      * @param dst The address of the destination account\n      * @param amount The number of tokens to transfer\n      */\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n    /**\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n      * @dev This will overwrite the approval amount for `spender`\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n      * @param spender The address of the account which may transfer tokens\n      * @param amount The number of tokens that are approved\n      * @return success bool Whether or not the approval succeeded\n      */\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n    /**\n      * @notice Get the current allowance from `owner` for `spender`\n      * @param owner The address of the account which owns the tokens to be spent\n      * @param spender The address of the account which may transfer tokens\n      * @return remaining uint256 The number of tokens allowed to be spent\n      */\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n}\n"
    },
    "contracts/compound/InterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\n/**\n  * @title Compound's InterestRateModel Interface\n  * @author Compound\n  */\nabstract contract InterestRateModel {\n    /// @notice Indicator that this is an InterestRateModel contract (for inspection)\n    bool public constant isInterestRateModel = true;\n\n    /**\n      * @notice Calculates the current borrow interest rate per block\n      * @param cash The total amount of cash the market has\n      * @param borrows The total amount of borrows the market has outstanding\n      * @param reserves The total amount of reserves the market has\n      * @return The borrow rate per block (as a percentage, and scaled by 1e18)\n      */\n    function getBorrowRate(uint cash, uint borrows, uint reserves) virtual public view returns (uint);\n\n    /**\n      * @notice Calculates the current supply interest rate per block\n      * @param cash The total amount of cash the market has\n      * @param borrows The total amount of borrows the market has outstanding\n      * @param reserves The total amount of reserves the market has\n      * @param reserveFactorMantissa The current reserve factor the market has\n      * @return The supply rate per block (as a percentage, and scaled by 1e18)\n      */\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) virtual public view returns (uint);\n\n}\n"
    },
    "contracts/compound/IFuseFeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\ninterface IFuseFeeDistributor {\n    function minBorrowEth() external view returns (uint256);\n    function maxSupplyEth() external view returns (uint256);\n    function maxUtilizationRate() external view returns (uint256);\n    function interestFeeRate() external view returns (uint256);\n    function comptrollerImplementationWhitelist(address oldImplementation, address newImplementation) external view returns (bool);\n    function cErc20DelegateWhitelist(address oldImplementation, address newImplementation, bool allowResign) external view returns (bool);\n    function cEtherDelegateWhitelist(address oldImplementation, address newImplementation, bool allowResign) external view returns (bool);\n    function latestComptrollerImplementation(address oldImplementation) external view returns (address);\n    function latestCErc20Delegate(address oldImplementation) external view returns (address cErc20Delegate, bool allowResign, bytes memory becomeImplementationData);\n    function latestCEtherDelegate(address oldImplementation) external view returns (address cEtherDelegate, bool allowResign, bytes memory becomeImplementationData);\n    function deployCEther(bytes calldata constructorData) external returns (address);\n    function deployCErc20(bytes calldata constructorData) external returns (address);\n    fallback () external payable;\n}\n"
    },
    "contracts/compound/RewardsDistributorStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./CToken.sol\";\n\ncontract RewardsDistributorDelegatorStorage {\n    /// @notice Administrator for this contract\n    address public admin;\n\n    /// @notice Pending administrator for this contract\n    address public pendingAdmin;\n\n    /// @notice Active brains of RewardsDistributor\n    address public implementation;\n}\n\n/**\n * @title Storage for RewardsDistributorDelegate\n * @notice For future upgrades, do not change RewardsDistributorDelegateStorageV1. Create a new\n * contract which implements RewardsDistributorDelegateStorageV1 and following the naming convention\n * RewardsDistributorDelegateStorageVX.\n */\ncontract RewardsDistributorDelegateStorageV1 is RewardsDistributorDelegatorStorage {\n    /// @dev The token to reward (i.e., COMP)\n    address public rewardToken;\n\n    struct CompMarketState {\n        // The market's last updated compBorrowIndex or compSupplyIndex\n        uint224 index;\n\n        // The block number the index was last updated at\n        uint32 block;\n    }\n\n    /// @notice A list of all markets\n    CToken[] public allMarkets;\n\n    /// @notice The portion of compRate that each market currently receives\n    mapping(address => uint) public compSupplySpeeds;\n\n    /// @notice The portion of compRate that each market currently receives\n    mapping(address => uint) public compBorrowSpeeds;\n\n    /// @notice The COMP market supply state for each market\n    mapping(address => CompMarketState) public compSupplyState;\n\n    /// @notice The COMP market borrow state for each market\n    mapping(address => CompMarketState) public compBorrowState;\n\n    /// @notice The COMP borrow index for each market for each supplier as of the last time they accrued COMP\n    mapping(address => mapping(address => uint)) public compSupplierIndex;\n\n    /// @notice The COMP borrow index for each market for each borrower as of the last time they accrued COMP\n    mapping(address => mapping(address => uint)) public compBorrowerIndex;\n\n    /// @notice The COMP accrued but not yet transferred to each user\n    mapping(address => uint) public compAccrued;\n\n    /// @notice The portion of COMP that each contributor receives per block\n    mapping(address => uint) public compContributorSpeeds;\n\n    /// @notice Last block at which a contributor's COMP rewards have been allocated\n    mapping(address => uint) public lastContributorBlock;\n}\n"
    },
    "contracts/compound/Lens/CompoundLens.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../CErc20.sol\";\nimport \"../CToken.sol\";\nimport \"../Comptroller.sol\";\nimport \"../EIP20Interface.sol\";\nimport \"../Governance/GovernorAlpha.sol\";\nimport \"../Governance/Comp.sol\";\n\ncontract CompoundLens {\n    struct CTokenMetadata {\n        address cToken;\n        uint exchangeRateCurrent;\n        uint supplyRatePerBlock;\n        uint borrowRatePerBlock;\n        uint reserveFactorMantissa;\n        uint totalBorrows;\n        uint totalReserves;\n        uint totalSupply;\n        uint totalCash;\n        bool isListed;\n        uint collateralFactorMantissa;\n        address underlyingAssetAddress;\n        uint cTokenDecimals;\n        uint underlyingDecimals;\n    }\n\n    function cTokenMetadata(CToken cToken) public returns (CTokenMetadata memory) {\n        uint exchangeRateCurrent = cToken.exchangeRateCurrent();\n        Comptroller comptroller = Comptroller(address(cToken.comptroller()));\n        (bool isListed, uint collateralFactorMantissa) = comptroller.markets(address(cToken));\n        address underlyingAssetAddress;\n        uint underlyingDecimals;\n\n        if (compareStrings(cToken.symbol(), \"cETH\")) {\n            underlyingAssetAddress = address(0);\n            underlyingDecimals = 18;\n        } else {\n            CErc20 cErc20 = CErc20(address(cToken));\n            underlyingAssetAddress = cErc20.underlying();\n            underlyingDecimals = EIP20Interface(cErc20.underlying()).decimals();\n        }\n\n        return CTokenMetadata({\n            cToken: address(cToken),\n            exchangeRateCurrent: exchangeRateCurrent,\n            supplyRatePerBlock: cToken.supplyRatePerBlock(),\n            borrowRatePerBlock: cToken.borrowRatePerBlock(),\n            reserveFactorMantissa: cToken.reserveFactorMantissa(),\n            totalBorrows: cToken.totalBorrows(),\n            totalReserves: cToken.totalReserves(),\n            totalSupply: cToken.totalSupply(),\n            totalCash: cToken.getCash(),\n            isListed: isListed,\n            collateralFactorMantissa: collateralFactorMantissa,\n            underlyingAssetAddress: underlyingAssetAddress,\n            cTokenDecimals: cToken.decimals(),\n            underlyingDecimals: underlyingDecimals\n        });\n    }\n\n    function cTokenMetadataAll(CToken[] calldata cTokens) external returns (CTokenMetadata[] memory) {\n        uint cTokenCount = cTokens.length;\n        CTokenMetadata[] memory res = new CTokenMetadata[](cTokenCount);\n        for (uint i = 0; i < cTokenCount; i++) {\n            res[i] = cTokenMetadata(cTokens[i]);\n        }\n        return res;\n    }\n\n    struct CTokenBalances {\n        address cToken;\n        uint balanceOf;\n        uint borrowBalanceCurrent;\n        uint balanceOfUnderlying;\n        uint tokenBalance;\n        uint tokenAllowance;\n    }\n\n    function cTokenBalances(CToken cToken, address payable account) public returns (CTokenBalances memory) {\n        uint balanceOf = cToken.balanceOf(account);\n        uint borrowBalanceCurrent = cToken.borrowBalanceCurrent(account);\n        uint balanceOfUnderlying = cToken.balanceOfUnderlying(account);\n        uint tokenBalance;\n        uint tokenAllowance;\n\n        if (compareStrings(cToken.symbol(), \"cETH\")) {\n            tokenBalance = account.balance;\n            tokenAllowance = account.balance;\n        } else {\n            CErc20 cErc20 = CErc20(address(cToken));\n            EIP20Interface underlying = EIP20Interface(cErc20.underlying());\n            tokenBalance = underlying.balanceOf(account);\n            tokenAllowance = underlying.allowance(account, address(cToken));\n        }\n\n        return CTokenBalances({\n            cToken: address(cToken),\n            balanceOf: balanceOf,\n            borrowBalanceCurrent: borrowBalanceCurrent,\n            balanceOfUnderlying: balanceOfUnderlying,\n            tokenBalance: tokenBalance,\n            tokenAllowance: tokenAllowance\n        });\n    }\n\n    function cTokenBalancesAll(CToken[] calldata cTokens, address payable account) external returns (CTokenBalances[] memory) {\n        uint cTokenCount = cTokens.length;\n        CTokenBalances[] memory res = new CTokenBalances[](cTokenCount);\n        for (uint i = 0; i < cTokenCount; i++) {\n            res[i] = cTokenBalances(cTokens[i], account);\n        }\n        return res;\n    }\n\n    struct CTokenUnderlyingPrice {\n        address cToken;\n        uint underlyingPrice;\n    }\n\n    function cTokenUnderlyingPrice(CToken cToken) public returns (CTokenUnderlyingPrice memory) {\n        Comptroller comptroller = Comptroller(address(cToken.comptroller()));\n        PriceOracle priceOracle = comptroller.oracle();\n\n        return CTokenUnderlyingPrice({\n            cToken: address(cToken),\n            underlyingPrice: priceOracle.getUnderlyingPrice(cToken)\n        });\n    }\n\n    function cTokenUnderlyingPriceAll(CToken[] calldata cTokens) external returns (CTokenUnderlyingPrice[] memory) {\n        uint cTokenCount = cTokens.length;\n        CTokenUnderlyingPrice[] memory res = new CTokenUnderlyingPrice[](cTokenCount);\n        for (uint i = 0; i < cTokenCount; i++) {\n            res[i] = cTokenUnderlyingPrice(cTokens[i]);\n        }\n        return res;\n    }\n\n    struct AccountLimits {\n        CToken[] markets;\n        uint liquidity;\n        uint shortfall;\n    }\n\n    function getAccountLimits(Comptroller comptroller, address account) public returns (AccountLimits memory) {\n        (uint errorCode, uint liquidity, uint shortfall) = comptroller.getAccountLiquidity(account);\n        require(errorCode == 0);\n\n        return AccountLimits({\n            markets: comptroller.getAssetsIn(account),\n            liquidity: liquidity,\n            shortfall: shortfall\n        });\n    }\n\n    struct GovReceipt {\n        uint proposalId;\n        bool hasVoted;\n        bool support;\n        uint96 votes;\n    }\n\n    function getGovReceipts(GovernorAlpha governor, address voter, uint[] memory proposalIds) public view returns (GovReceipt[] memory) {\n        uint proposalCount = proposalIds.length;\n        GovReceipt[] memory res = new GovReceipt[](proposalCount);\n        for (uint i = 0; i < proposalCount; i++) {\n            GovernorAlpha.Receipt memory receipt = governor.getReceipt(proposalIds[i], voter);\n            res[i] = GovReceipt({\n                proposalId: proposalIds[i],\n                hasVoted: receipt.hasVoted,\n                support: receipt.support,\n                votes: receipt.votes\n            });\n        }\n        return res;\n    }\n\n    struct GovProposal {\n        uint proposalId;\n        address proposer;\n        uint eta;\n        address[] targets;\n        uint[] values;\n        string[] signatures;\n        bytes[] calldatas;\n        uint startBlock;\n        uint endBlock;\n        uint forVotes;\n        uint againstVotes;\n        bool canceled;\n        bool executed;\n    }\n\n    function setProposal(GovProposal memory res, GovernorAlpha governor, uint proposalId) internal view {\n        (\n            ,\n            address proposer,\n            uint eta,\n            uint startBlock,\n            uint endBlock,\n            uint forVotes,\n            uint againstVotes,\n            bool canceled,\n            bool executed\n        ) = governor.proposals(proposalId);\n        res.proposalId = proposalId;\n        res.proposer = proposer;\n        res.eta = eta;\n        res.startBlock = startBlock;\n        res.endBlock = endBlock;\n        res.forVotes = forVotes;\n        res.againstVotes = againstVotes;\n        res.canceled = canceled;\n        res.executed = executed;\n    }\n\n    function getGovProposals(GovernorAlpha governor, uint[] calldata proposalIds) external view returns (GovProposal[] memory) {\n        GovProposal[] memory res = new GovProposal[](proposalIds.length);\n        for (uint i = 0; i < proposalIds.length; i++) {\n            (\n                address[] memory targets,\n                uint[] memory values,\n                string[] memory signatures,\n                bytes[] memory calldatas\n            ) = governor.getActions(proposalIds[i]);\n            res[i] = GovProposal({\n                proposalId: 0,\n                proposer: address(0),\n                eta: 0,\n                targets: targets,\n                values: values,\n                signatures: signatures,\n                calldatas: calldatas,\n                startBlock: 0,\n                endBlock: 0,\n                forVotes: 0,\n                againstVotes: 0,\n                canceled: false,\n                executed: false\n            });\n            setProposal(res[i], governor, proposalIds[i]);\n        }\n        return res;\n    }\n\n    struct CompBalanceMetadata {\n        uint balance;\n        uint votes;\n        address delegate;\n    }\n\n    function getCompBalanceMetadata(Comp comp, address account) external view returns (CompBalanceMetadata memory) {\n        return CompBalanceMetadata({\n            balance: comp.balanceOf(account),\n            votes: uint256(comp.getCurrentVotes(account)),\n            delegate: comp.delegates(account)\n        });\n    }\n\n    struct CompVotes {\n        uint blockNumber;\n        uint votes;\n    }\n\n    function getCompVotes(Comp comp, address account, uint32[] calldata blockNumbers) external view returns (CompVotes[] memory) {\n        CompVotes[] memory res = new CompVotes[](blockNumbers.length);\n        for (uint i = 0; i < blockNumbers.length; i++) {\n            res[i] = CompVotes({\n                blockNumber: uint256(blockNumbers[i]),\n                votes: uint256(comp.getPriorVotes(account, blockNumbers[i]))\n            });\n        }\n        return res;\n    }\n\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n}\n"
    },
    "contracts/compound/Governance/GovernorAlpha.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\npragma experimental ABIEncoderV2;\n\ncontract GovernorAlpha {\n    /// @notice The name of this contract\n    string public constant name = \"Compound Governor Alpha\";\n\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n    function quorumVotes() public pure returns (uint) { return 400000e18; } // 400,000 = 4% of Comp\n\n    /// @notice The number of votes required in order for a voter to become a proposer\n    function proposalThreshold() public pure returns (uint) { return 100000e18; } // 100,000 = 1% of Comp\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    function proposalMaxOperations() public pure returns (uint) { return 10; } // 10 actions\n\n    /// @notice The delay before voting on a proposal may take place, once proposed\n    function votingDelay() public pure returns (uint) { return 1; } // 1 block\n\n    /// @notice The duration of voting on a proposal, in blocks\n    function votingPeriod() public pure returns (uint) { return 17280; } // ~3 days in blocks (assuming 15s blocks)\n\n    /// @notice The address of the Compound Protocol Timelock\n    TimelockInterface public timelock;\n\n    /// @notice The address of the Compound governance token\n    CompInterface public comp;\n\n    /// @notice The address of the Governor Guardian\n    address public guardian;\n\n    /// @notice The total number of proposals\n    uint public proposalCount;\n\n    struct Proposal {\n        // Unique id for looking up a proposal\n        uint id;\n\n        // Creator of the proposal\n        address proposer;\n\n        // The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint eta;\n\n        // the ordered list of target addresses for calls to be made\n        address[] targets;\n\n        // The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint[] values;\n\n        // The ordered list of function signatures to be called\n        string[] signatures;\n\n        // The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n\n        // The block at which voting begins: holders must delegate their votes prior to this block\n        uint startBlock;\n\n        // The block at which voting ends: votes must be cast prior to this block\n        uint endBlock;\n\n        // Current number of votes in favor of this proposal\n        uint forVotes;\n\n        // Current number of votes in opposition to this proposal\n        uint againstVotes;\n\n        // Flag marking whether the proposal has been canceled\n        bool canceled;\n\n        // Flag marking whether the proposal has been executed\n        bool executed;\n\n        // Receipts of ballots for the entire set of voters\n        mapping (address => Receipt) receipts;\n    }\n\n    /// @notice Ballot receipt record for a voter\n    struct Receipt {\n        // Whether or not a vote has been cast\n        bool hasVoted;\n\n        // Whether or not the voter supports the proposal\n        bool support;\n\n        // The number of votes the voter had, which were cast\n        uint96 votes;\n    }\n\n    /// @notice Possible states that a proposal may be in\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    }\n\n    /// @notice The official record of all proposals ever proposed\n    mapping (uint => Proposal) public proposals;\n\n    /// @notice The latest proposal for each proposer\n    mapping (address => uint) public latestProposalIds;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,bool support)\");\n\n    /// @notice An event emitted when a new proposal is created\n    event ProposalCreated(uint id, address proposer, address[] targets, uint[] values, string[] signatures, bytes[] calldatas, uint startBlock, uint endBlock, string description);\n\n    /// @notice An event emitted when a vote has been cast on a proposal\n    event VoteCast(address voter, uint proposalId, bool support, uint votes);\n\n    /// @notice An event emitted when a proposal has been canceled\n    event ProposalCanceled(uint id);\n\n    /// @notice An event emitted when a proposal has been queued in the Timelock\n    event ProposalQueued(uint id, uint eta);\n\n    /// @notice An event emitted when a proposal has been executed in the Timelock\n    event ProposalExecuted(uint id);\n\n    constructor(address timelock_, address comp_, address guardian_) {\n        timelock = TimelockInterface(timelock_);\n        comp = CompInterface(comp_);\n        guardian = guardian_;\n    }\n\n    function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) {\n        require(comp.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information arity mismatch\");\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n        require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n        uint latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) {\n          ProposalState proposersLatestProposalState = state(latestProposalId);\n          require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\n          require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\");\n        }\n\n        uint startBlock = add256(block.number, votingDelay());\n        uint endBlock = add256(startBlock, votingPeriod());\n\n        proposalCount++;\n        Proposal storage newProposal = proposals[proposalCount];\n        newProposal.id = proposalCount;\n        newProposal.proposer = msg.sender;\n        newProposal.eta = 0;\n        newProposal.targets = targets;\n        newProposal.values = values;\n        newProposal.signatures = signatures;\n        newProposal.calldatas = calldatas;\n        newProposal.startBlock = startBlock;\n        newProposal.endBlock = endBlock;\n        newProposal.forVotes = 0;\n        newProposal.againstVotes = 0;\n        newProposal.canceled = false;\n        newProposal.executed = false;\n\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n        return newProposal.id;\n    }\n\n    function queue(uint proposalId) public {\n        require(state(proposalId) == ProposalState.Succeeded, \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\");\n        Proposal storage proposal = proposals[proposalId];\n        uint eta = add256(block.timestamp, timelock.delay());\n        for (uint i = 0; i < proposal.targets.length; i++) {\n            _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    }\n\n    function _queueOrRevert(address target, uint value, string memory signature, bytes memory data, uint eta) internal {\n        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\");\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    function execute(uint proposalId) public payable {\n        require(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n        for (uint i = 0; i < proposal.targets.length; i++) {\n            timelock.executeTransaction{value:proposal.values[i]}(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    function cancel(uint proposalId) public {\n        ProposalState state = state(proposalId);\n        require(state != ProposalState.Executed, \"GovernorAlpha::cancel: cannot cancel executed proposal\");\n\n        Proposal storage proposal = proposals[proposalId];\n        require(msg.sender == guardian || comp.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold(), \"GovernorAlpha::cancel: proposer above threshold\");\n\n        proposal.canceled = true;\n        for (uint i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n        }\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    function getActions(uint proposalId) public view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas) {\n        Proposal storage p = proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }\n\n    function getReceipt(uint proposalId, address voter) public view returns (Receipt memory) {\n        return proposals[proposalId].receipts[voter];\n    }\n\n    function state(uint proposalId) public view returns (ProposalState) {\n        require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes()) {\n            return ProposalState.Defeated;\n        } else if (proposal.eta == 0) {\n            return ProposalState.Succeeded;\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    function castVote(uint proposalId, bool support) public {\n        return _castVote(msg.sender, proposalId, support);\n    }\n\n    function castVoteBySig(uint proposalId, bool support, uint8 v, bytes32 r, bytes32 s) public {\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"GovernorAlpha::castVoteBySig: invalid signature\");\n        return _castVote(signatory, proposalId, support);\n    }\n\n    function _castVote(address voter, uint proposalId, bool support) internal {\n        require(state(proposalId) == ProposalState.Active, \"GovernorAlpha::_castVote: voting is closed\");\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n        require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n        uint96 votes = comp.getPriorVotes(voter, proposal.startBlock);\n\n        if (support) {\n            proposal.forVotes = add256(proposal.forVotes, votes);\n        } else {\n            proposal.againstVotes = add256(proposal.againstVotes, votes);\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        emit VoteCast(voter, proposalId, support, votes);\n    }\n\n    function __acceptAdmin() public {\n        require(msg.sender == guardian, \"GovernorAlpha::__acceptAdmin: sender must be gov guardian\");\n        timelock.acceptAdmin();\n    }\n\n    function __abdicate() public {\n        require(msg.sender == guardian, \"GovernorAlpha::__abdicate: sender must be gov guardian\");\n        guardian = address(0);\n    }\n\n    function __queueSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\n        require(msg.sender == guardian, \"GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian\");\n        timelock.queueTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n    }\n\n    function __executeSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\n        require(msg.sender == guardian, \"GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian\");\n        timelock.executeTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n    }\n\n    function add256(uint256 a, uint256 b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    }\n\n    function sub256(uint256 a, uint256 b) internal pure returns (uint) {\n        require(b <= a, \"subtraction underflow\");\n        return a - b;\n    }\n\n    function getChainId() internal pure returns (uint) {\n        uint chainId;\n        assembly { chainId := chainid() }\n        return chainId;\n    }\n}\n\ninterface TimelockInterface {\n    function delay() external view returns (uint);\n    function GRACE_PERIOD() external view returns (uint);\n    function acceptAdmin() external;\n    function queuedTransactions(bytes32 hash) external view returns (bool);\n    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\n    function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external;\n    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\n}\n\ninterface CompInterface {\n    function getPriorVotes(address account, uint blockNumber) external view returns (uint96);\n}\n"
    },
    "contracts/compound/Governance/Comp.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\npragma experimental ABIEncoderV2;\n\ncontract Comp {\n    /// @notice EIP-20 token name for this token\n    string public constant name = \"Compound\";\n\n    /// @notice EIP-20 token symbol for this token\n    string public constant symbol = \"COMP\";\n\n    /// @notice EIP-20 token decimals for this token\n    uint8 public constant decimals = 18;\n\n    /// @notice Total number of tokens in circulation\n    uint public constant totalSupply = 10000000e18; // 10 million Comp\n\n    // Allowance amounts on behalf of others\n    mapping (address => mapping (address => uint96)) internal allowances;\n\n    // Official record of token balances for each account\n    mapping (address => uint96) internal balances;\n\n    /// @notice A record of each accounts delegate\n    mapping (address => address) public delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint96 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping (address => uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of states for signing / validating signatures\n    mapping (address => uint) public nonces;\n\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n\n    /// @notice The standard EIP-20 transfer event\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /// @notice The standard EIP-20 approval event\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /**\n     * @notice Construct a new Comp token\n     * @param account The initial account to grant all the tokens\n     */\n    constructor(address account) {\n        balances[account] = uint96(totalSupply);\n        emit Transfer(address(0), account, totalSupply);\n    }\n\n    /**\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n     * @param account The address of the account holding the funds\n     * @param spender The address of the account spending the funds\n     * @return The number of tokens approved\n     */\n    function allowance(address account, address spender) external view returns (uint) {\n        return allowances[account][spender];\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint rawAmount) external returns (bool) {\n        uint96 amount;\n        if (rawAmount == uint(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(rawAmount, \"Comp::approve: amount exceeds 96 bits\");\n        }\n\n        allowances[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the number of tokens held by the `account`\n     * @param account The address of the account to get the balance of\n     * @return The number of tokens held\n     */\n    function balanceOf(address account) external view returns (uint) {\n        return balances[account];\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint rawAmount) external returns (bool) {\n        uint96 amount = safe96(rawAmount, \"Comp::transfer: amount exceeds 96 bits\");\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint rawAmount) external returns (bool) {\n        address spender = msg.sender;\n        uint96 spenderAllowance = allowances[src][spender];\n        uint96 amount = safe96(rawAmount, \"Comp::approve: amount exceeds 96 bits\");\n\n        if (spender != src && spenderAllowance != uint96(-1)) {\n            uint96 newAllowance = sub96(spenderAllowance, amount, \"Comp::transferFrom: transfer amount exceeds spender allowance\");\n            allowances[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n\n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address delegatee) public {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public {\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"Comp::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"Comp::delegateBySig: invalid nonce\");\n        require(block.timestamp <= expiry, \"Comp::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account) external view returns (uint96) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {\n        require(blockNumber < block.number, \"Comp::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        address currentDelegate = delegates[delegator];\n        uint96 delegatorBalance = balances[delegator];\n        delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _transferTokens(address src, address dst, uint96 amount) internal {\n        require(src != address(0), \"Comp::_transferTokens: cannot transfer from the zero address\");\n        require(dst != address(0), \"Comp::_transferTokens: cannot transfer to the zero address\");\n\n        balances[src] = sub96(balances[src], amount, \"Comp::_transferTokens: transfer amount exceeds balance\");\n        balances[dst] = add96(balances[dst], amount, \"Comp::_transferTokens: transfer amount overflows\");\n        emit Transfer(src, dst, amount);\n\n        _moveDelegates(delegates[src], delegates[dst], amount);\n    }\n\n    function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint96 srcRepNew = sub96(srcRepOld, amount, \"Comp::_moveVotes: vote amount underflows\");\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint96 dstRepNew = add96(dstRepOld, amount, \"Comp::_moveVotes: vote amount overflows\");\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\n      uint32 blockNumber = safe32(block.number, \"Comp::_writeCheckpoint: block number exceeds 32 bits\");\n\n      if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n          checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n      } else {\n          checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n          numCheckpoints[delegatee] = nCheckpoints + 1;\n      }\n\n      emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function safe96(uint n, string memory errorMessage) internal pure returns (uint96) {\n        require(n < 2**96, errorMessage);\n        return uint96(n);\n    }\n\n    function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function getChainId() internal pure returns (uint) {\n        uint256 chainId;\n        assembly { chainId := chainid() }\n        return chainId;\n    }\n}\n"
    },
    "contracts/compound/Reservoir.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\n/**\n * @title Reservoir Contract\n * @notice Distributes a token to a different contract at a fixed rate.\n * @dev This contract must be poked via the `drip()` function every so often.\n * @author Compound\n */\ncontract Reservoir {\n\n  /// @notice The block number when the Reservoir started (immutable)\n  uint public dripStart;\n\n  /// @notice Tokens per block that to drip to target (immutable)\n  uint public dripRate;\n\n  /// @notice Reference to token to drip (immutable)\n  EIP20Interface public token;\n\n  /// @notice Target to receive dripped tokens (immutable)\n  address public target;\n\n  /// @notice Amount that has already been dripped\n  uint public dripped;\n\n  /**\n    * @notice Constructs a Reservoir\n    * @param dripRate_ Numer of tokens per block to drip\n    * @param token_ The token to drip\n    * @param target_ The recipient of dripped tokens\n    */\n  constructor(uint dripRate_, EIP20Interface token_, address target_) {\n    dripStart = block.number;\n    dripRate = dripRate_;\n    token = token_;\n    target = target_;\n    dripped = 0;\n  }\n\n  /**\n    * @notice Drips the maximum amount of tokens to match the drip rate since inception\n    * @dev Note: this will only drip up to the amount of tokens available.\n    * @return The amount of tokens dripped in this call\n    */\n  function drip() public returns (uint) {\n    // First, read storage into memory\n    EIP20Interface token_ = token;\n    uint reservoirBalance_ = token_.balanceOf(address(this)); // TODO: Verify this is a static call\n    uint dripRate_ = dripRate;\n    uint dripStart_ = dripStart;\n    uint dripped_ = dripped;\n    address target_ = target;\n    uint blockNumber_ = block.number;\n\n    // Next, calculate intermediate values\n    uint dripTotal_ = mul(dripRate_, blockNumber_ - dripStart_, \"dripTotal overflow\");\n    uint deltaDrip_ = sub(dripTotal_, dripped_, \"deltaDrip underflow\");\n    uint toDrip_ = min(reservoirBalance_, deltaDrip_);\n    uint drippedNext_ = add(dripped_, toDrip_, \"tautological\");\n\n    // Finally, write new `dripped` value and transfer tokens to target\n    dripped = drippedNext_;\n    token_.transfer(target_, toDrip_);\n\n    return toDrip_;\n  }\n\n  /* Internal helper functions for safe math */\n\n  function add(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n    uint c = a + b;\n    require(c >= a, errorMessage);\n    return c;\n  }\n\n  function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n    require(b <= a, errorMessage);\n    uint c = a - b;\n    return c;\n  }\n\n  function mul(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n    if (a == 0) {\n      return 0;\n    }\n    uint c = a * b;\n    require(c / a == b, errorMessage);\n    return c;\n  }\n\n  function min(uint a, uint b) internal pure returns (uint) {\n    if (a <= b) {\n      return a;\n    } else {\n      return b;\n    }\n  }\n}\n\nimport \"./EIP20Interface.sol\";\n"
    },
    "contracts/compound/RewardsDistributorDelegator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./RewardsDistributorStorage.sol\";\n\ncontract RewardsDistributorDelegator is RewardsDistributorDelegatorStorage {\n    /// @notice Emitted when implementation is changed\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n\tconstructor(\n\t\t\taddress admin_,\n\t\t\taddress rewardToken_,\n\t        address implementation_) {\n\n        // Admin set to msg.sender for initialization\n        admin = msg.sender;\n\n        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address)\", rewardToken_));\n\n        _setImplementation(implementation_);\n\n        admin = admin_;\n\t}\n\n\n\t/**\n     * @notice Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     */\n    function _setImplementation(address implementation_) public {\n        require(msg.sender == admin, \"RewardsDistributorDelegator::_setImplementation: admin only\");\n        require(implementation_ != address(0), \"RewardsDistributorDelegator::_setImplementation: invalid implementation address\");\n\n        address oldImplementation = implementation;\n        implementation = implementation_;\n\n        emit NewImplementation(oldImplementation, implementation);\n    }\n\n    /**\n     * @notice Internal method to delegate execution to another contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     * @param callee The contract to delegatecall\n     * @param data The raw data to delegatecall\n     */\n    function delegateTo(address callee, bytes memory data) internal {\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n        assembly {\n            if eq(success, 0) {\n                revert(add(returnData, 0x20), returndatasize())\n            }\n        }\n    }\n\n\t/**\n     * @dev Delegates execution to an implementation contract.\n     * It returns to the external caller whatever the implementation returns\n     * or forwards reverts.\n     */\n    receive() external payable {\n        // delegate all other functions to current implementation\n        (bool success, ) = implementation.delegatecall(msg.data);\n\n        assembly {\n              let free_mem_ptr := mload(0x40)\n              returndatacopy(free_mem_ptr, 0, returndatasize())\n\n              switch success\n              case 0 { revert(free_mem_ptr, returndatasize()) }\n              default { return(free_mem_ptr, returndatasize()) }\n        }\n    }\n}\n"
    },
    "contracts/compound/CEther.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"./CToken.sol\";\n\n/**\n * @title Compound's CEther Contract\n * @notice CToken which wraps Ether\n * @dev This contract should not to be deployed on its own; instead, deploy `CEtherDelegator` (proxy contract) and `CEtherDelegate` (logic/implementation contract).\n * @author Compound\n */\ncontract CEther is CToken, CEtherInterface {\n\n    bool public constant override isCEther = true;\n\n    /**\n     * @notice Initialize the new money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     */\n    function initialize(ComptrollerInterface comptroller_,\n                        InterestRateModel interestRateModel_,\n                        string memory name_,\n                        string memory symbol_,\n                        uint256 reserveFactorMantissa_,\n                        uint256 adminFeeMantissa_) public {\n        // CToken initialize does the bulk of the work\n        uint256 initialExchangeRateMantissa_ = 0.2e18;\n        uint8 decimals_ = 18;\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, reserveFactorMantissa_, adminFeeMantissa_);\n    }\n\n    /*** User Interface ***/\n\n    /**\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Reverts upon any failure\n     */\n    function mint() external payable {\n        (uint err,) = mintInternal(msg.value);\n        requireNoError(err, \"mint failed\");\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeem(uint redeemTokens) external returns (uint) {\n        return redeemInternal(redeemTokens);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\n        return redeemUnderlyingInternal(redeemAmount);\n    }\n\n    /**\n      * @notice Sender borrows assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function borrow(uint borrowAmount) external returns (uint) {\n        return borrowInternal(borrowAmount);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @dev Reverts upon any failure\n     */\n    function repayBorrow() external payable {\n        (uint err,) = repayBorrowInternal(msg.value);\n        requireNoError(err, \"repayBorrow failed\");\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @dev Reverts upon any failure\n     * @param borrower the account with the debt being payed off\n     */\n    function repayBorrowBehalf(address borrower) external payable {\n        (uint err,) = repayBorrowBehalfInternal(borrower, msg.value);\n        requireNoError(err, \"repayBorrowBehalf failed\");\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @dev Reverts upon any failure\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     */\n    function liquidateBorrow(address borrower, CToken cTokenCollateral) external payable {\n        (uint err,) = liquidateBorrowInternal(borrower, msg.value, cTokenCollateral);\n        requireNoError(err, \"liquidateBorrow failed\");\n    }\n\n    /**\n     * @notice Send Ether to CEther to mint\n     */\n    receive() external payable {\n        (uint err,) = mintInternal(msg.value);\n        requireNoError(err, \"mint failed\");\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets balance of this contract in terms of Ether, before this message\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of Ether owned by this contract\n     */\n    function getCashPrior() override internal view returns (uint) {\n        (MathError err, uint startingBalance) = subUInt(address(this).balance, msg.value);\n        require(err == MathError.NO_ERROR);\n        return startingBalance;\n    }\n\n    /**\n     * @notice Perform the actual transfer in, which is a no-op\n     * @param from Address sending the Ether\n     * @param amount Amount of Ether being sent\n     * @return The actual amount of Ether transferred\n     */\n    function doTransferIn(address from, uint amount) override internal returns (uint) {\n        // Sanity checks\n        require(msg.sender == from, \"sender mismatch\");\n        require(msg.value == amount, \"value mismatch\");\n        return amount;\n    }\n\n    function doTransferOut(address payable to, uint amount) override internal {\n        // Send the Ether and revert on failure\n        (bool success, ) = to.call{value:amount}(\"\");\n        require(success, \"doTransferOut failed\");\n    }\n\n    function requireNoError(uint errCode, string memory message) internal pure {\n        if (errCode == uint(Error.NO_ERROR)) {\n            return;\n        }\n\n        bytes memory fullMessage = new bytes(bytes(message).length + 7);\n        uint i;\n\n        for (i = 0; i < bytes(message).length; i++) {\n            fullMessage[i] = bytes(message)[i];\n        }\n\n        fullMessage[i+0] = byte(uint8(32));\n        fullMessage[i+1] = byte(uint8(40));\n        fullMessage[i+2] = byte(uint8(48 + ( errCode / 1000 )));\n        fullMessage[i+3] = byte(uint8(48 + ( errCode / 100 % 10 )));\n        fullMessage[i+4] = byte(uint8(48 + ( errCode / 10 % 10 )));\n        fullMessage[i+5] = byte(uint8(48 + ( errCode % 10 )));\n        fullMessage[i+6] = byte(uint8(41));\n\n        require(errCode == uint(Error.NO_ERROR), string(fullMessage));\n    }\n}\n"
    },
    "contracts/compound/Maximillion.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"./CEther.sol\";\n\n/**\n * @title Compound's Maximillion Contract\n * @author Compound\n */\ncontract Maximillion {\n    /**\n     * @notice The default cEther market to repay in\n     */\n    CEther public cEther;\n\n    /**\n     * @notice Construct a Maximillion to repay max in a CEther market\n     */\n    constructor(CEther cEther_) {\n        cEther = cEther_;\n    }\n\n    /**\n     * @notice msg.sender sends Ether to repay an account's borrow in the cEther market\n     * @dev The provided Ether is applied towards the borrow balance, any excess is refunded\n     * @param borrower The address of the borrower account to repay on behalf of\n     */\n    function repayBehalf(address borrower) public payable {\n        repayBehalfExplicit(borrower, cEther);\n    }\n\n    /**\n     * @notice msg.sender sends Ether to repay an account's borrow in a cEther market\n     * @dev The provided Ether is applied towards the borrow balance, any excess is refunded\n     * @param borrower The address of the borrower account to repay on behalf of\n     * @param cEther_ The address of the cEther contract to repay in\n     */\n    function repayBehalfExplicit(address borrower, CEther cEther_) public payable {\n        uint received = msg.value;\n        uint borrows = cEther_.borrowBalanceCurrent(borrower);\n        if (received > borrows) {\n            cEther_.repayBorrowBehalf{value:borrows}(borrower);\n            msg.sender.transfer(received - borrows);\n        } else {\n            cEther_.repayBorrowBehalf{value:received}(borrower);\n        }\n    }\n}\n"
    },
    "contracts/compound/CEtherDelegate.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"./CEther.sol\";\nimport \"./CDelegateInterface.sol\";\n\n/**\n * @title Compound's CEtherDelegate Contract\n * @notice CTokens which wrap Ether and are delegated to\n * @author Compound\n */\ncontract CEtherDelegate is CDelegateInterface, CEther {\n    /**\n     * @notice Construct an empty delegate\n     */\n    constructor() {}\n\n    /**\n     * @notice Called by the delegator on a delegate to initialize it for duty\n     * @param data The encoded bytes data for any initialization\n     */\n    function _becomeImplementation(bytes calldata data) override external {\n\n        require(msg.sender == address(this) || hasAdminRights(), \"!self\");\n\n        // Make sure admin storage is set up correctly\n        __admin = address(0);\n        __adminHasRights = false;\n        __fuseAdminHasRights = false;\n    }\n\n    /**\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\n     */\n    function _resignImplementation() internal {\n        // Shh -- we don't ever want this hook to be marked pure\n        if (false) {\n            implementation = address(0);\n        }\n    }\n\n    /**\n     * @dev Internal function to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n     */\n    function _setImplementationInternal(address implementation_, bool allowResign, bytes memory becomeImplementationData) internal {\n        // Check whitelist\n        require(fuseAdmin.cEtherDelegateWhitelist(implementation, implementation_, allowResign), \"!impl\");\n\n        // Call _resignImplementation internally (this delegate's code)\n        if (allowResign) _resignImplementation();\n\n        // Get old implementation\n        address oldImplementation = implementation;\n\n        // Store new implementation\n        implementation = implementation_;\n\n        // Call _becomeImplementation externally (delegating to new delegate's code)\n        _functionCall(address(this), abi.encodeWithSignature(\"_becomeImplementation(bytes)\", becomeImplementationData), \"!become\");\n\n        // Emit event\n        emit NewImplementation(oldImplementation, implementation);\n    }\n\n    /**\n     * @notice Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n     */\n    function _setImplementationSafe(address implementation_, bool allowResign, bytes calldata becomeImplementationData) override external {\n        // Check admin rights\n        require(hasAdminRights(), \"!admin\");\n\n        // Set implementation\n        _setImplementationInternal(implementation_, allowResign, becomeImplementationData);\n    }\n\n    /**\n     * @notice Function called before all delegator functions\n     * @dev Checks comptroller.autoImplementation and upgrades the implementation if necessary\n     */\n    function _prepare() override external payable {\n        if (msg.sender != address(this) && ComptrollerV3Storage(address(comptroller)).autoImplementation()) {\n            (address latestCEtherDelegate, bool allowResign, bytes memory becomeImplementationData) = fuseAdmin.latestCEtherDelegate(implementation);\n            if (implementation != latestCEtherDelegate) _setImplementationInternal(latestCEtherDelegate, allowResign, becomeImplementationData);\n        }\n    }\n}\n"
    },
    "contracts/compound/CDelegateInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\n\ncontract CDelegationStorage {\n    /**\n     * @notice Implementation address for this contract\n     */\n    address public implementation;\n}\n\n\nabstract contract CDelegateInterface is CDelegationStorage {\n    /**\n     * @notice Emitted when implementation is changed\n     */\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n    /**\n     * @notice Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n     */\n    function _setImplementationSafe(address implementation_, bool allowResign, bytes calldata becomeImplementationData) virtual external;\n\n    /**\n     * @notice Called by the delegator on a delegate to initialize it for duty\n     * @dev Should revert if any issues arise which make it unfit for delegation\n     * @param data The encoded bytes data for any initialization\n     */\n    function _becomeImplementation(bytes calldata data) virtual external;\n\n    /**\n     * @notice Function called before all delegator functions\n     * @dev Checks comptroller.autoImplementation and upgrades the implementation if necessary\n     */\n    function _prepare() virtual external payable;\n}"
    },
    "contracts/compound/CEtherDelegator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./InterestRateModel.sol\";\nimport \"./CDelegateInterface.sol\";\n\n/**\n * @title Compound's CEtherDelegator Contract\n * @notice CTokens which wrap Ether and delegate to an implementation\n * @author Compound\n */\ncontract CEtherDelegator is CDelegationStorage {\n    /**\n     * @notice Construct a new CEther money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     * @param implementation_ The address of the implementation the contract delegates to\n     * @param becomeImplementationData The encoded args for becomeImplementation\n     */\n    constructor(ComptrollerInterface comptroller_,\n                InterestRateModel interestRateModel_,\n                string memory name_,\n                string memory symbol_,\n                address implementation_,\n                bytes memory becomeImplementationData,\n                uint256 reserveFactorMantissa_,\n                uint256 adminFeeMantissa_) {\n        // First delegate gets to initialize the delegator (i.e. storage contract)\n        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address,address,string,string,uint256,uint256)\",\n                                                            comptroller_,\n                                                            interestRateModel_,\n                                                            name_,\n                                                            symbol_,\n                                                            reserveFactorMantissa_,\n                                                            adminFeeMantissa_));\n\n        // New implementations always get set via the settor (post-initialize)\n        delegateTo(implementation_, abi.encodeWithSignature(\"_setImplementationSafe(address,bool,bytes)\", implementation_, false, becomeImplementationData));\n    }\n\n    /**\n     * @notice Internal method to delegate execution to another contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     * @param callee The contract to delegatecall\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n        assembly {\n            if eq(success, 0) {\n                revert(add(returnData, 0x20), returndatasize())\n            }\n        }\n        return returnData;\n    }\n\n    /**\n     * @notice Delegates execution to an implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     */\n    receive() external payable {}\n\n    fallback() external payable {\n        // Check for automatic implementation\n        delegateTo(implementation, abi.encodeWithSignature(\"_prepare()\"));\n\n        // delegate all other functions to current implementation\n        (bool success, ) = implementation.delegatecall(msg.data);\n\n        assembly {\n            let free_mem_ptr := mload(0x40)\n            returndatacopy(free_mem_ptr, 0, returndatasize())\n\n            switch success\n            case 0 { revert(free_mem_ptr, returndatasize()) }\n            default { return(free_mem_ptr, returndatasize()) }\n        }\n    }\n}\n"
    },
    "contracts/FuseFeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/Create2Upgradeable.sol\";\nimport \"./compound/CEtherDelegator.sol\";\nimport \"./compound/CErc20Delegator.sol\";\n\n/**\n * @title FuseFeeDistributor\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice FuseFeeDistributor controls and receives protocol fees from Fuse pools and relays admin actions to Fuse pools.\n */\ncontract FuseFeeDistributor is Initializable, OwnableUpgradeable {\n    using AddressUpgradeable for address;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @dev Initializer that sets initial values of state variables.\n     * @param _defaultInterestFeeRate The default proportion of Fuse pool interest taken as a protocol fee (scaled by 1e18).\n     */\n    function initialize(uint256 _defaultInterestFeeRate) public initializer {\n        require(_defaultInterestFeeRate <= 1e18, \"Interest fee rate cannot be more than 100%.\");\n        __Ownable_init();\n        defaultInterestFeeRate = _defaultInterestFeeRate;\n        maxSupplyEth = uint256(-1);\n        maxUtilizationRate = uint256(-1);\n    }\n\n    /**\n     * @notice The proportion of Fuse pool interest taken as a protocol fee (scaled by 1e18).\n     */\n    uint256 public defaultInterestFeeRate;\n\n    /**\n     * @dev Sets the default proportion of Fuse pool interest taken as a protocol fee.\n     * @param _defaultInterestFeeRate The default proportion of Fuse pool interest taken as a protocol fee (scaled by 1e18).\n     */\n    function _setDefaultInterestFeeRate(uint256 _defaultInterestFeeRate) external onlyOwner {\n        require(_defaultInterestFeeRate <= 1e18, \"Interest fee rate cannot be more than 100%.\");\n        defaultInterestFeeRate = _defaultInterestFeeRate;\n    }\n\n    /**\n     * @dev Withdraws accrued fees on interest.\n     * @param erc20Contract The ERC20 token address to withdraw. Set to the zero address to withdraw ETH.\n     */\n    function _withdrawAssets(address erc20Contract) external {\n        if (erc20Contract == address(0)) {\n            uint256 balance = address(this).balance;\n            require(balance > 0, \"No balance available to withdraw.\");\n            (bool success, ) = owner().call{value: balance}(\"\");\n            require(success, \"Failed to transfer ETH balance to msg.sender.\");\n        } else {\n            IERC20Upgradeable token = IERC20Upgradeable(erc20Contract);\n            uint256 balance = token.balanceOf(address(this));\n            require(balance > 0, \"No token balance available to withdraw.\");\n            token.safeTransfer(owner(), balance);\n        }\n    }\n\n    /**\n     * @dev Minimum borrow balance (in ETH) per user per Fuse pool asset (only checked on new borrows, not redemptions).\n     */\n    uint256 public minBorrowEth;\n\n    /**\n     * @dev Maximum supply balance (in ETH) per user per Fuse pool asset.\n     * No longer used as of `Rari-Capital/compound-protocol` version `fuse-v1.1.0`.\n     */\n    uint256 public maxSupplyEth;\n\n    /**\n     * @dev Maximum utilization rate (scaled by 1e18) for Fuse pool assets (only checked on new borrows, not redemptions).\n     * No longer used as of `Rari-Capital/compound-protocol` version `fuse-v1.1.0`.\n     */\n    uint256 public maxUtilizationRate;\n\n    /**\n     * @dev Sets the proportion of Fuse pool interest taken as a protocol fee.\n     * @param _minBorrowEth Minimum borrow balance (in ETH) per user per Fuse pool asset (only checked on new borrows, not redemptions).\n     * @param _maxSupplyEth Maximum supply balance (in ETH) per user per Fuse pool asset.\n     * @param _maxUtilizationRate Maximum utilization rate (scaled by 1e18) for Fuse pool assets (only checked on new borrows, not redemptions).\n     */\n    function _setPoolLimits(uint256 _minBorrowEth, uint256 _maxSupplyEth, uint256 _maxUtilizationRate) external onlyOwner {\n        minBorrowEth = _minBorrowEth;\n        maxSupplyEth = _maxSupplyEth;\n        maxUtilizationRate = _maxUtilizationRate;\n    }\n\n    /**\n     * @dev Receives ETH fees.\n     */\n    receive() external payable { }\n\n    /**\n     * @dev Sends data to a contract.\n     * @param targets The contracts to which `data` will be sent.\n     * @param data The data to be sent to each of `targets`.\n     */\n    function _callPool(address[] calldata targets, bytes[] calldata data) external onlyOwner {\n        require(targets.length > 0 && targets.length == data.length, \"Array lengths must be equal and greater than 0.\");\n        for (uint256 i = 0; i < targets.length; i++) targets[i].functionCall(data[i]);\n    }\n\n    /**\n     * @dev Sends data to a contract.\n     * @param targets The contracts to which `data` will be sent.\n     * @param data The data to be sent to each of `targets`.\n     */\n    function _callPool(address[] calldata targets, bytes calldata data) external onlyOwner {\n        require(targets.length > 0, \"No target addresses specified.\");\n        for (uint256 i = 0; i < targets.length; i++) targets[i].functionCall(data);\n    }\n\n    function deployCEther(bytes calldata constructorData) external returns (address) {\n        // Make sure comptroller == msg.sender\n        (address comptroller) = abi.decode(constructorData[0:32], (address));\n        require(comptroller == msg.sender, \"Comptroller is not sender.\");\n        // Deploy CEtherDelegator using msg.sender, underlying, and block.number as a salt\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender, address(0), block.number));\n\n        bytes memory cEtherDelegatorCreationCode = abi.encodePacked(type(CEtherDelegator).creationCode, constructorData);\n        address proxy = Create2Upgradeable.deploy(0, salt, cEtherDelegatorCreationCode);\n        return proxy;\n    }\n\n    function deployCErc20(bytes calldata constructorData) external returns (address) {\n        // Make sure comptroller == msg.sender\n        (address underlying, address comptroller) = abi.decode(constructorData[0:64], (address, address));\n        require(comptroller == msg.sender, \"Comptroller is not sender.\");\n\n        // Deploy CErc20Delegator using msg.sender, underlying, and block.number as a salt\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender, underlying, block.number));\n\n        bytes memory cErc20DelegatorCreationCode = abi.encodePacked(type(CErc20Delegator).creationCode, constructorData);\n        address proxy = Create2Upgradeable.deploy(0, salt, cErc20DelegatorCreationCode);\n\n        return proxy;\n    }\n\n    /**\n     * @dev Whitelisted Comptroller implementation contract addresses for each existing implementation.\n     */\n    mapping(address => mapping(address => bool)) public comptrollerImplementationWhitelist;\n\n    /**\n     * @dev Adds/removes Comptroller implementations to the whitelist.\n     * @param oldImplementations The old `Comptroller` implementation addresses to upgrade from for each `newImplementations` to upgrade to.\n     * @param newImplementations Array of `Comptroller` implementations to be whitelisted/unwhitelisted.\n     * @param statuses Array of whitelist statuses corresponding to `implementations`.\n     */\n    function _editComptrollerImplementationWhitelist(address[] calldata oldImplementations, address[] calldata newImplementations, bool[] calldata statuses) external onlyOwner {\n        require(newImplementations.length > 0 && newImplementations.length == oldImplementations.length && newImplementations.length == statuses.length, \"No Comptroller implementations supplied or array lengths not equal.\");\n        for (uint256 i = 0; i < newImplementations.length; i++) comptrollerImplementationWhitelist[oldImplementations[i]][newImplementations[i]] = statuses[i];\n    }\n\n    /**\n     * @dev Whitelisted CErc20Delegate implementation contract addresses and `allowResign` values for each existing implementation.\n     */\n    mapping(address => mapping(address => mapping(bool => bool))) public cErc20DelegateWhitelist;\n\n    /**\n     * @dev Adds/removes CErc20Delegate implementations to the whitelist.\n     * @param oldImplementations The old `CErc20Delegate` implementation addresses to upgrade from for each `newImplementations` to upgrade to.\n     * @param newImplementations Array of `CErc20Delegate` implementations to be whitelisted/unwhitelisted.\n     * @param allowResign Array of `allowResign` values corresponding to `newImplementations` to be whitelisted/unwhitelisted.\n     * @param statuses Array of whitelist statuses corresponding to `newImplementations`.\n     */\n    function _editCErc20DelegateWhitelist(address[] calldata oldImplementations, address[] calldata newImplementations, bool[] calldata allowResign, bool[] calldata statuses) external onlyOwner {\n        require(newImplementations.length > 0 && newImplementations.length == oldImplementations.length && newImplementations.length == allowResign.length && newImplementations.length == statuses.length, \"No CErc20Delegate implementations supplied or array lengths not equal.\");\n        for (uint256 i = 0; i < newImplementations.length; i++) cErc20DelegateWhitelist[oldImplementations[i]][newImplementations[i]][allowResign[i]] = statuses[i];\n    }\n\n    /**\n     * @dev Whitelisted CEtherDelegate implementation contract addresses and `allowResign` values for each existing implementation.\n     */\n    mapping(address => mapping(address => mapping(bool => bool))) public cEtherDelegateWhitelist;\n\n    /**\n     * @dev Adds/removes CEtherDelegate implementations to the whitelist.\n     * @param oldImplementations The old `CEtherDelegate` implementation addresses to upgrade from for each `newImplementations` to upgrade to.\n     * @param newImplementations Array of `CEtherDelegate` implementations to be whitelisted/unwhitelisted.\n     * @param allowResign Array of `allowResign` values corresponding to `newImplementations` to be whitelisted/unwhitelisted.\n     * @param statuses Array of whitelist statuses corresponding to `newImplementations`.\n     */\n    function _editCEtherDelegateWhitelist(address[] calldata oldImplementations, address[] calldata newImplementations, bool[] calldata allowResign, bool[] calldata statuses) external onlyOwner {\n        require(newImplementations.length > 0 && newImplementations.length == oldImplementations.length && newImplementations.length == allowResign.length && newImplementations.length == statuses.length, \"No CEtherDelegate implementations supplied or array lengths not equal.\");\n        for (uint256 i = 0; i < newImplementations.length; i++) cEtherDelegateWhitelist[oldImplementations[i]][newImplementations[i]][allowResign[i]] = statuses[i];\n    }\n\n    /**\n     * @dev Latest Comptroller implementation for each existing implementation.\n     */\n    mapping(address => address) internal _latestComptrollerImplementation;\n\n    /**\n     * @dev Latest Comptroller implementation for each existing implementation.\n     */\n    function latestComptrollerImplementation(address oldImplementation) external view returns (address) {\n        return _latestComptrollerImplementation[oldImplementation] != address(0) ? _latestComptrollerImplementation[oldImplementation] : oldImplementation;\n    }\n\n    /**\n     * @dev Sets the latest `Comptroller` upgrade implementation address.\n     * @param oldImplementation The old `Comptroller` implementation address to upgrade from.\n     * @param newImplementation Latest `Comptroller` implementation address.\n     */\n    function _setLatestComptrollerImplementation(address oldImplementation, address newImplementation) external onlyOwner {\n        _latestComptrollerImplementation[oldImplementation] = newImplementation;\n    }\n\n    struct CDelegateUpgradeData {\n        address implementation;\n        bool allowResign;\n        bytes becomeImplementationData;\n    }\n\n    /**\n     * @dev Latest CErc20Delegate implementation for each existing implementation.\n     */\n    mapping(address => CDelegateUpgradeData) public _latestCErc20Delegate;\n\n    /**\n     * @dev Latest CEtherDelegate implementation for each existing implementation.\n     */\n    mapping(address => CDelegateUpgradeData) public _latestCEtherDelegate;\n\n    /**\n     * @dev Latest CErc20Delegate implementation for each existing implementation.\n     */\n    function latestCErc20Delegate(address oldImplementation) external view returns (address, bool, bytes memory) {\n        CDelegateUpgradeData memory data = _latestCErc20Delegate[oldImplementation];\n        bytes memory emptyBytes;\n        return data.implementation != address(0) ? (data.implementation, data.allowResign, data.becomeImplementationData) : (oldImplementation, false, emptyBytes);\n    }\n\n    /**\n     * @dev Latest CEtherDelegate implementation for each existing implementation.\n     */\n    function latestCEtherDelegate(address oldImplementation) external view returns (address, bool, bytes memory) {\n        CDelegateUpgradeData memory data = _latestCEtherDelegate[oldImplementation];\n        bytes memory emptyBytes;\n        return data.implementation != address(0) ? (data.implementation, data.allowResign, data.becomeImplementationData) : (oldImplementation, false, emptyBytes);\n    }\n\n    /**\n     * @dev Sets the latest `CEtherDelegate` upgrade implementation address and data.\n     * @param oldImplementation The old `CEtherDelegate` implementation address to upgrade from.\n     * @param newImplementation Latest `CEtherDelegate` implementation address.\n     * @param allowResign Whether or not `resignImplementation` should be called on the old implementation before upgrade.\n     * @param becomeImplementationData Data passed to the new implementation via `becomeImplementation` after upgrade.\n     */\n    function _setLatestCEtherDelegate(address oldImplementation, address newImplementation, bool allowResign, bytes calldata becomeImplementationData) external onlyOwner {\n        _latestCEtherDelegate[oldImplementation] = CDelegateUpgradeData(newImplementation, allowResign, becomeImplementationData);\n    }\n\n    /**\n     * @dev Sets the latest `CErc20Delegate` upgrade implementation address and data.\n     * @param oldImplementation The old `CErc20Delegate` implementation address to upgrade from.\n     * @param newImplementation Latest `CErc20Delegate` implementation address.\n     * @param allowResign Whether or not `resignImplementation` should be called on the old implementation before upgrade.\n     * @param becomeImplementationData Data passed to the new implementation via `becomeImplementation` after upgrade.\n     */\n    function _setLatestCErc20Delegate(address oldImplementation, address newImplementation, bool allowResign, bytes calldata becomeImplementationData) external onlyOwner {\n        _latestCErc20Delegate[oldImplementation] = CDelegateUpgradeData(newImplementation, allowResign, becomeImplementationData);\n    }\n\n    /**\n     * @notice Maps Unitroller (Comptroller proxy) addresses to the proportion of Fuse pool interest taken as a protocol fee (scaled by 1e18).\n     * @dev A value of 0 means unset whereas a negative value means 0.\n     */\n    mapping(address => int256) public customInterestFeeRates;\n\n    /**\n     * @notice Returns the proportion of Fuse pool interest taken as a protocol fee (scaled by 1e18).\n     */\n    function interestFeeRate() external view returns (uint256) {\n        (bool success, bytes memory data) = msg.sender.staticcall(abi.encodeWithSignature(\"comptroller()\"));\n\n        if (success && data.length == 32) {\n            (address comptroller) = abi.decode(data, (address));\n            int256 customRate = customInterestFeeRates[comptroller];\n            if (customRate > 0) return uint256(customRate);\n            if (customRate < 0) return 0;\n        }\n\n        return defaultInterestFeeRate;\n    }\n\n    /**\n     * @dev Sets the proportion of Fuse pool interest taken as a protocol fee.\n     * @param comptroller The Unitroller (Comptroller proxy) address.\n     * @param rate The proportion of Fuse pool interest taken as a protocol fee (scaled by 1e18).\n     */\n    function _setCustomInterestFeeRate(address comptroller, int256 rate) external onlyOwner {\n        require(rate <= 1e18, \"Interest fee rate cannot be more than 100%.\");\n        customInterestFeeRates[comptroller] = rate;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\nimport \"../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"../../math/SafeMathUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using SafeMathUpgradeable for uint256;\n    using AddressUpgradeable for address;\n\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/Create2Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2Upgradeable {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address) {\n        address addr;\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address) {\n        bytes32 _data = keccak256(\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)\n        );\n        return address(uint160(uint256(_data)));\n    }\n}\n"
    },
    "contracts/compound/CErc20Delegator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./InterestRateModel.sol\";\nimport \"./CDelegateInterface.sol\";\n\n/**\n * @title Compound's CErc20Delegator Contract\n * @notice CTokens which wrap an EIP-20 underlying and delegate to an implementation\n * @author Compound\n */\ncontract CErc20Delegator is CDelegationStorage {\n    /**\n     * @notice Construct a new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     * @param implementation_ The address of the implementation the contract delegates to\n     * @param becomeImplementationData The encoded args for becomeImplementation\n     */\n    constructor(address underlying_,\n                ComptrollerInterface comptroller_,\n                InterestRateModel interestRateModel_,\n                string memory name_,\n                string memory symbol_,\n                address implementation_,\n                bytes memory becomeImplementationData,\n                uint256 reserveFactorMantissa_,\n                uint256 adminFeeMantissa_) public {\n        // First delegate gets to initialize the delegator (i.e. storage contract)\n        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address,address,address,string,string,uint256,uint256)\",\n                                                            underlying_,\n                                                            comptroller_,\n                                                            interestRateModel_,\n                                                            name_,\n                                                            symbol_,\n                                                            reserveFactorMantissa_,\n                                                            adminFeeMantissa_));\n\n        // New implementations always get set via the settor (post-initialize)\n        delegateTo(implementation_, abi.encodeWithSignature(\"_setImplementationSafe(address,bool,bytes)\", implementation_, false, becomeImplementationData));\n    }\n\n    /**\n     * @notice Internal method to delegate execution to another contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     * @param callee The contract to delegatecall\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n        assembly {\n            if eq(success, 0) {\n                revert(add(returnData, 0x20), returndatasize())\n            }\n        }\n        return returnData;\n    }\n\n    /**\n     * @notice Delegates execution to an implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     */\n    receive() external payable {}\n\n    fallback() external payable {\n        // Cannot send value to CErc20Delegator\n        require(msg.value == 0, \"CErc20Delegator:fallback: cannot send value to fallback\");\n\n        // Check for automatic implementation\n        delegateTo(implementation, abi.encodeWithSignature(\"_prepare()\"));\n\n        // delegate all other functions to current implementation\n        (bool success, ) = implementation.delegatecall(msg.data);\n\n        assembly {\n            let free_mem_ptr := mload(0x40)\n            returndatacopy(free_mem_ptr, 0, returndatasize())\n\n            switch success\n            case 0 { revert(free_mem_ptr, returndatasize()) }\n            default { return(free_mem_ptr, returndatasize()) }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/compound/WhitePaperInterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"./InterestRateModel.sol\";\nimport \"./SafeMath.sol\";\n\n/**\n  * @title Compound's WhitePaperInterestRateModel Contract\n  * @author Compound\n  * @notice The parameterized model described in section 2.4 of the original Compound Protocol whitepaper\n  */\ncontract WhitePaperInterestRateModel is InterestRateModel {\n    using SafeMath for uint;\n\n    event NewInterestParams(uint baseRatePerBlock, uint multiplierPerBlock);\n\n    /**\n     * @notice The approximate number of blocks per year that is assumed by the interest rate model\n     */\n    uint public constant blocksPerYear = 2102400;\n\n    /**\n     * @notice The multiplier of utilization rate that gives the slope of the interest rate\n     */\n    uint public multiplierPerBlock;\n\n    /**\n     * @notice The base interest rate which is the y-intercept when utilization rate is 0\n     */\n    uint public baseRatePerBlock;\n\n    /**\n     * @notice Construct an interest rate model\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n     */\n    constructor(uint baseRatePerYear, uint multiplierPerYear) {\n        baseRatePerBlock = baseRatePerYear.div(blocksPerYear);\n        multiplierPerBlock = multiplierPerYear.div(blocksPerYear);\n\n        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock);\n    }\n\n    /**\n     * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market (currently unused)\n     * @return The utilization rate as a mantissa between [0, 1e18]\n     */\n    function utilizationRate(uint cash, uint borrows, uint reserves) public pure returns (uint) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n    }\n\n    /**\n     * @notice Calculates the current borrow rate per block, with the error code expected by the market\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getBorrowRate(uint cash, uint borrows, uint reserves) override public view returns (uint) {\n        uint ur = utilizationRate(cash, borrows, reserves);\n        return ur.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n    }\n\n    /**\n     * @notice Calculates the current supply rate per block\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @param reserveFactorMantissa The current reserve factor for the market\n     * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) override public view returns (uint) {\n        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactorMantissa);\n        uint borrowRate = getBorrowRate(cash, borrows, reserves);\n        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n    }\n}\n"
    },
    "contracts/compound/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\n// Subject to the MIT license.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction underflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/compound/Timelock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"./SafeMath.sol\";\n\ncontract Timelock {\n    using SafeMath for uint;\n\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint indexed newDelay);\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\n\n    uint public constant GRACE_PERIOD = 14 days;\n    uint public constant MINIMUM_DELAY = 2 days;\n    uint public constant MAXIMUM_DELAY = 30 days;\n\n    address public admin;\n    address public pendingAdmin;\n    uint public delay;\n\n    mapping (bytes32 => bool) public queuedTransactions;\n\n\n    constructor(address admin_, uint delay_) {\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n\n        admin = admin_;\n        delay = delay_;\n    }\n\n    receive() external payable { }\n\n    function setDelay(uint delay_) public {\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = delay_;\n\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() public {\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address pendingAdmin_) public {\n        require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target.call{value:value}(callData);\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    function getBlockTimestamp() internal view returns (uint) {\n        // solium-disable-next-line security/no-block-members\n        return block.timestamp;\n    }\n}"
    },
    "contracts/compound/JumpRateModel.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"./InterestRateModel.sol\";\nimport \"./SafeMath.sol\";\n\n/**\n  * @title Compound's JumpRateModel Contract\n  * @author Compound\n  */\ncontract JumpRateModel is InterestRateModel {\n    using SafeMath for uint;\n\n    event NewInterestParams(uint baseRatePerBlock, uint multiplierPerBlock, uint jumpMultiplierPerBlock, uint kink);\n\n    /**\n     * @notice The approximate number of blocks per year that is assumed by the interest rate model\n     */\n    uint public constant blocksPerYear = 2102400;\n\n    /**\n     * @notice The multiplier of utilization rate that gives the slope of the interest rate\n     */\n    uint public multiplierPerBlock;\n\n    /**\n     * @notice The base interest rate which is the y-intercept when utilization rate is 0\n     */\n    uint public baseRatePerBlock;\n\n    /**\n     * @notice The multiplierPerBlock after hitting a specified utilization point\n     */\n    uint public jumpMultiplierPerBlock;\n\n    /**\n     * @notice The utilization point at which the jump multiplier is applied\n     */\n    uint public kink;\n\n    /**\n     * @notice Construct an interest rate model\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     */\n    constructor(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_) {\n        baseRatePerBlock = baseRatePerYear.div(blocksPerYear);\n        multiplierPerBlock = multiplierPerYear.div(blocksPerYear);\n        jumpMultiplierPerBlock = jumpMultiplierPerYear.div(blocksPerYear);\n        kink = kink_;\n\n        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\n    }\n\n    /**\n     * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market (currently unused)\n     * @return The utilization rate as a mantissa between [0, 1e18]\n     */\n    function utilizationRate(uint cash, uint borrows, uint reserves) public pure returns (uint) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n    }\n\n    /**\n     * @notice Calculates the current borrow rate per block, with the error code expected by the market\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getBorrowRate(uint cash, uint borrows, uint reserves) public view override returns (uint) {\n        uint util = utilizationRate(cash, borrows, reserves);\n\n        if (util <= kink) {\n            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n        } else {\n            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n            uint excessUtil = util.sub(kink);\n            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);\n        }\n    }\n\n    /**\n     * @notice Calculates the current supply rate per block\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @param reserveFactorMantissa The current reserve factor for the market\n     * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) public view override virtual returns (uint) {\n        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactorMantissa);\n        uint borrowRate = getBorrowRate(cash, borrows, reserves);\n        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n    }\n}\n"
    },
    "contracts/compound/DAIInterestRateModelV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"./JumpRateModel.sol\";\nimport \"./SafeMath.sol\";\n\n/**\n  * @title Compound's DAIInterestRateModel Contract (version 2)\n  * @author Compound (modified by Dharma Labs)\n  * @notice The parameterized model described in section 2.4 of the original Compound Protocol whitepaper.\n  * Version 2 modifies the original interest rate model by increasing the \"gap\" or slope of the model prior\n  * to the \"kink\" from 0.05% to 2% with the goal of \"smoothing out\" interest rate changes as the utilization\n  * rate increases.\n  */\ncontract DAIInterestRateModelV2 is JumpRateModel {\n    using SafeMath for uint;\n\n    /**\n     * @notice The additional margin per block separating the base borrow rate from the roof (2% / block).\n     * Note that this value has been increased from the original value of 0.05% per block.\n     */\n    uint public constant gapPerBlock = 2e16 / blocksPerYear;\n\n    /**\n     * @notice The assumed (1 - reserve factor) used to calculate the minimum borrow rate (reserve factor = 0.05)\n     */\n    uint public constant assumedOneMinusReserveFactorMantissa = 0.95e18;\n\n    PotLike pot;\n    JugLike jug;\n\n    /**\n     * @notice Construct an interest rate model\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     * @param pot_ The address of the Dai pot (where DSR is earned)\n     * @param jug_ The address of the Dai jug (where SF is kept)\n     */\n    constructor(uint jumpMultiplierPerYear, uint kink_, address pot_, address jug_) JumpRateModel(0, 0, jumpMultiplierPerYear, kink_) {\n        pot = PotLike(pot_);\n        jug = JugLike(jug_);\n        poke();\n    }\n\n    /**\n     * @notice Calculates the current supply interest rate per block including the Dai savings rate\n     * @param cash The total amount of cash the market has\n     * @param borrows The total amount of borrows the market has outstanding\n     * @param reserves The total amnount of reserves the market has\n     * @param reserveFactorMantissa The current reserve factor the market has\n     * @return The supply rate per block (as a percentage, and scaled by 1e18)\n     */\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) public view override returns (uint) {\n        uint protocolRate = super.getSupplyRate(cash, borrows, reserves, reserveFactorMantissa);\n\n        uint underlying = cash.add(borrows).sub(reserves);\n        if (underlying == 0) {\n            return protocolRate;\n        } else {\n            uint cashRate = cash.mul(dsrPerBlock()).div(underlying);\n            return cashRate.add(protocolRate);\n        }\n    }\n\n    /**\n     * @notice Calculates the Dai savings rate per block\n     * @return The Dai savings rate per block (as a percentage, and scaled by 1e18)\n     */\n    function dsrPerBlock() public view returns (uint) {\n        return pot\n            .dsr().sub(1e27)  // scaled 1e27 aka RAY, and includes an extra \"ONE\" before subraction\n            .div(1e9) // descale to 1e18\n            .mul(15); // 15 seconds per block\n    }\n\n    /**\n     * @notice Resets the baseRate and multiplier per block based on the stability fee and Dai savings rate\n     */\n    function poke() public {\n        (uint duty, ) = jug.ilks(\"ETH-A\");\n        uint stabilityFeePerBlock = duty.add(jug.base()).sub(1e27).mul(1e18).div(1e27).mul(15);\n\n        // We ensure the minimum borrow rate >= DSR / (1 - reserve factor)\n        baseRatePerBlock = dsrPerBlock().mul(1e18).div(assumedOneMinusReserveFactorMantissa);\n\n        // The roof borrow rate is max(base rate, stability fee) + gap, from which we derive the slope\n        if (baseRatePerBlock < stabilityFeePerBlock) {\n            multiplierPerBlock = stabilityFeePerBlock.sub(baseRatePerBlock).add(gapPerBlock).mul(1e18).div(kink);\n        } else {\n            multiplierPerBlock = gapPerBlock.mul(1e18).div(kink);\n        }\n\n        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\n    }\n}\n\n\n/*** Maker Interfaces ***/\n\nabstract contract PotLike {\n    function chi() virtual external view returns (uint);\n    function dsr() virtual external view returns (uint);\n    function rho() virtual external view returns (uint);\n    function pie(address) virtual external view returns (uint);\n    function drip() virtual external returns (uint);\n    function join(uint) virtual external;\n    function exit(uint) virtual external;\n}\n\ncontract JugLike {\n    // --- Data ---\n    struct Ilk {\n        uint256 duty;\n        uint256  rho;\n    }\n\n   mapping (bytes32 => Ilk) public ilks;\n   uint256 public base;\n}\n"
    },
    "contracts/FusePoolDirectory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/Create2Upgradeable.sol\";\n\n\nimport \"./external/compound/IComptroller.sol\";\nimport \"./external/compound/IUnitroller.sol\";\nimport \"./external/compound/IPriceOracle.sol\";\nimport \"./compound/Unitroller.sol\";\n\n/**\n * @title FusePoolDirectory\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice FusePoolDirectory is a directory for Fuse interest rate pools.\n */\ncontract FusePoolDirectory is OwnableUpgradeable {\n    /**\n     * @dev Initializes a deployer whitelist if desired.\n     * @param _enforceDeployerWhitelist Boolean indicating if the deployer whitelist is to be enforced.\n     * @param _deployerWhitelist Array of Ethereum accounts to be whitelisted.\n     */\n    function initialize(bool _enforceDeployerWhitelist, address[] memory _deployerWhitelist) public initializer {\n        __Ownable_init();\n        enforceDeployerWhitelist = _enforceDeployerWhitelist;\n        for (uint256 i = 0; i < _deployerWhitelist.length; i++) deployerWhitelist[_deployerWhitelist[i]] = true;\n    }\n\n    /**\n     * @dev Struct for a Fuse interest rate pool.\n     */\n    struct FusePool {\n        string name;\n        address creator;\n        address comptroller;\n        uint256 blockPosted;\n        uint256 timestampPosted;\n    }\n\n    /**\n     * @dev Array of Fuse interest rate pools.\n     */\n    FusePool[] public pools;\n\n    /**\n     * @dev Maps Ethereum accounts to arrays of Fuse pool indexes.\n     */\n    mapping(address => uint256[]) private _poolsByAccount;\n\n    /**\n     * @dev Maps Fuse pool Comptroller addresses to bools indicating if they have been registered via the directory.\n     */\n    mapping(address => bool) public poolExists;\n\n    /**\n     * @dev Emitted when a new Fuse pool is added to the directory.\n     */\n    event PoolRegistered(uint256 index, FusePool pool);\n\n    /**\n     * @dev Booleans indicating if the deployer whitelist is enforced.\n     */\n    bool public enforceDeployerWhitelist;\n\n    /**\n     * @dev Maps Ethereum accounts to booleans indicating if they are allowed to deploy pools.\n     */\n    mapping(address => bool) public deployerWhitelist;\n\n    /**\n     * @dev Controls if the deployer whitelist is to be enforced.\n     * @param enforce Boolean indicating if the deployer whitelist is to be enforced.\n     */\n    function _setDeployerWhitelistEnforcement(bool enforce) external onlyOwner {\n        enforceDeployerWhitelist = enforce;\n    }\n\n    /**\n     * @dev Adds/removes Ethereum accounts to the deployer whitelist.\n     * @param deployers Array of Ethereum accounts to be whitelisted.\n     * @param status Whether to add or remove the accounts.\n     */\n    function _editDeployerWhitelist(address[] calldata deployers, bool status) external onlyOwner {\n        require(deployers.length > 0, \"No deployers supplied.\");\n        for (uint256 i = 0; i < deployers.length; i++) deployerWhitelist[deployers[i]] = status;\n    }\n\n    /**\n     * @dev Adds a new Fuse pool to the directory (without checking msg.sender).\n     * @param name The name of the pool.\n     * @param comptroller The pool's Comptroller proxy contract address.\n     * @return The index of the registered Fuse pool.\n     */\n    function _registerPool(string memory name, address comptroller) internal returns (uint256) {\n        require(!poolExists[comptroller], \"Pool already exists in the directory.\");\n        require(!enforceDeployerWhitelist || deployerWhitelist[msg.sender], \"Sender is not on deployer whitelist.\");\n        require(bytes(name).length <= 100, \"No pool name supplied.\");\n        FusePool memory pool = FusePool(name, msg.sender, comptroller, block.number, block.timestamp);\n        pools.push(pool);\n        _poolsByAccount[msg.sender].push(pools.length - 1);\n        poolExists[comptroller] = true;\n        emit PoolRegistered(pools.length - 1, pool);\n        return pools.length - 1;\n    }\n\n    /**\n     * @dev Deploys a new Fuse pool and adds to the directory.\n     * @param name The name of the pool.\n     * @param implementation The Comptroller implementation contract address.\n     * @param enforceWhitelist Boolean indicating if the pool's supplier/borrower whitelist is to be enforced.\n     * @param closeFactor The pool's close factor (scaled by 1e18).\n     * @param liquidationIncentive The pool's liquidation incentive (scaled by 1e18).\n     * @param priceOracle The pool's PriceOracle contract address.\n     * @return The index of the registered Fuse pool and the Unitroller proxy address.\n     */\n    function deployPool(string memory name, address implementation, bool enforceWhitelist, uint256 closeFactor, uint256 liquidationIncentive, address priceOracle) external returns (uint256, address) {\n        // Input validation\n        require(implementation != address(0), \"No Comptroller implementation contract address specified.\");\n        require(priceOracle != address(0), \"No PriceOracle contract address specified.\");\n\n        // Deploy CEtherDelegator using msg.sender, underlying, and block.number as a salt\n//        bytes32 salt = keccak256(abi.encodePacked(msg.sender, address(0), block.number));\n//\n\n//        address proxy = Create2Upgradeable.deploy(0, salt, cEtherDelegatorCreationCode);\n\n        // Deploy Unitroller using msg.sender, name, and block.number as a salt\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender, name, block.number));\n        bytes memory unitrollerCreationCode = abi.encodePacked(type(Unitroller).creationCode);\n        address proxy = Create2Upgradeable.deploy(0, salt, unitrollerCreationCode);\n\n        // Setup Unitroller\n        IUnitroller unitroller = IUnitroller(proxy);\n        require(unitroller._setPendingImplementation(implementation) == 0, \"Failed to set pending implementation on Unitroller.\"); // Checks Comptroller implementation whitelist\n        IComptroller comptrollerImplementation = IComptroller(implementation);\n        comptrollerImplementation._become(unitroller);\n        IComptroller comptrollerProxy = IComptroller(proxy);\n\n        // Set pool parameters\n        require(comptrollerProxy._setCloseFactor(closeFactor) == 0, \"Failed to set pool close factor.\");\n        require(comptrollerProxy._setLiquidationIncentive(liquidationIncentive) == 0, \"Failed to set pool liquidation incentive.\");\n        require(comptrollerProxy._setPriceOracle(IPriceOracle(priceOracle)) == 0, \"Failed to set pool price oracle.\");\n\n        // Whitelist\n        if (enforceWhitelist) require(comptrollerProxy._setWhitelistEnforcement(true) == 0, \"Failed to enforce supplier/borrower whitelist.\");\n\n        // Enable auto-implementation\n        require(comptrollerProxy._toggleAutoImplementations(true) == 0, \"Failed to enable pool auto implementations.\");\n\n        // Make msg.sender the admin\n        require(unitroller._setPendingAdmin(msg.sender) == 0, \"Failed to set pending admin on Unitroller.\");\n\n        // Register the pool with this FusePoolDirectory\n        return (_registerPool(name, proxy), proxy);\n    }\n\n    /**\n     * @notice Returns arrays of all Fuse pools' data.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     */\n    function getAllPools() external view returns (FusePool[] memory) {\n        return pools;\n    }\n\n    /**\n     * @notice Returns arrays of all public Fuse pool indexes and data.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     */\n    function getPublicPools() external view returns (uint256[] memory, FusePool[] memory) {\n        uint256 arrayLength = 0;\n\n        for (uint256 i = 0; i < pools.length; i++) {\n            try IComptroller(pools[i].comptroller).enforceWhitelist() returns (bool enforceWhitelist) {\n                if (enforceWhitelist) continue;\n            } catch { }\n\n            arrayLength++;\n        }\n\n        uint256[] memory indexes = new uint256[](arrayLength);\n        FusePool[] memory publicPools = new FusePool[](arrayLength);\n        uint256 index = 0;\n\n        for (uint256 i = 0; i < pools.length; i++) {\n            try IComptroller(pools[i].comptroller).enforceWhitelist() returns (bool enforceWhitelist) {\n                if (enforceWhitelist) continue;\n            } catch { }\n\n            indexes[index] = i;\n            publicPools[index] = pools[i];\n            index++;\n        }\n\n        return (indexes, publicPools);\n    }\n\n    /**\n     * @notice Returns arrays of Fuse pool indexes and data created by `account`.\n     */\n    function getPoolsByAccount(address account) external view returns (uint256[] memory, FusePool[] memory) {\n        uint256[] memory indexes = new uint256[](_poolsByAccount[account].length);\n        FusePool[] memory accountPools = new FusePool[](_poolsByAccount[account].length);\n\n        for (uint256 i = 0; i < _poolsByAccount[account].length; i++) {\n            indexes[i] = _poolsByAccount[account][i];\n            accountPools[i] = pools[_poolsByAccount[account][i]];\n        }\n\n        return (indexes, accountPools);\n    }\n\n    /**\n     * @dev Maps Ethereum accounts to arrays of Fuse pool Comptroller proxy contract addresses.\n     */\n    mapping(address => address[]) private _bookmarks;\n\n    /**\n     * @notice Returns arrays of Fuse pool Unitroller (Comptroller proxy) contract addresses bookmarked by `account`.\n     */\n    function getBookmarks(address account) external view returns (address[] memory) {\n        return _bookmarks[account];\n    }\n\n    /**\n     * @notice Bookmarks a Fuse pool Unitroller (Comptroller proxy) contract addresses.\n     */\n    function bookmarkPool(address comptroller) external {\n        _bookmarks[msg.sender].push(comptroller);\n    }\n\n    /**\n     * @notice Modify existing Fuse pool name.\n     */\n    function setPoolName(uint256 index, string calldata name) external {\n        IComptroller _comptroller = IComptroller(pools[index].comptroller);\n        require(msg.sender == _comptroller.admin() && _comptroller.adminHasRights() || msg.sender == owner());\n        pools[index].name = name;\n    }\n\n    /**\n     * @dev Maps Ethereum accounts to booleans indicating if they are a whitelisted admin.\n     */\n    mapping(address => bool) public adminWhitelist;\n\n    /**\n     * @dev Event emitted when the admin whitelist is updated.\n     */\n    event AdminWhitelistUpdated(address[] admins, bool status);\n\n    /**\n     * @dev Adds/removes Ethereum accounts to the admin whitelist.\n     * @param admins Array of Ethereum accounts to be whitelisted.\n     * @param status Whether to add or remove the accounts.\n     */\n    function _editAdminWhitelist(address[] calldata admins, bool status) external onlyOwner {\n        require(admins.length > 0, \"No admins supplied.\");\n        for (uint256 i = 0; i < admins.length; i++) adminWhitelist[admins[i]] = status;\n        emit AdminWhitelistUpdated(admins, status);\n    }\n\n    /**\n     * @notice Returns arrays of all public Fuse pool indexes and data with whitelisted admins.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     */\n    function getPublicPoolsByVerification(bool whitelistedAdmin) external view returns (uint256[] memory, FusePool[] memory) {\n        uint256 arrayLength = 0;\n\n        for (uint256 i = 0; i < pools.length; i++) {\n            IComptroller comptroller = IComptroller(pools[i].comptroller);\n\n            try comptroller.enforceWhitelist() returns (bool enforceWhitelist) {\n                if (enforceWhitelist) continue;\n\n                try comptroller.admin() returns (address admin) {\n                    if (whitelistedAdmin != adminWhitelist[admin]) continue;\n                } catch { }\n            } catch { }\n\n            arrayLength++;\n        }\n\n        uint256[] memory indexes = new uint256[](arrayLength);\n        FusePool[] memory publicPools = new FusePool[](arrayLength);\n        uint256 index = 0;\n\n        for (uint256 i = 0; i < pools.length; i++) {\n            IComptroller comptroller = IComptroller(pools[i].comptroller);\n\n            try comptroller.enforceWhitelist() returns (bool enforceWhitelist) {\n                if (enforceWhitelist) continue;\n\n                try comptroller.admin() returns (address admin) {\n                    if (whitelistedAdmin != adminWhitelist[admin]) continue;\n                } catch { }\n            } catch { }\n\n            indexes[index] = i;\n            publicPools[index] = pools[i];\n            index++;\n        }\n\n        return (indexes, publicPools);\n    }\n}\n"
    },
    "contracts/external/compound/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity >=0.7.0;\n\nimport \"./IPriceOracle.sol\";\nimport \"./ICToken.sol\";\nimport \"./IUnitroller.sol\";\nimport \"./IRewardsDistributor.sol\";\n\n/**\n * @title Compound's Comptroller Contract\n * @author Compound\n */\ninterface IComptroller {\n    function admin() external view returns (address);\n    function adminHasRights() external view returns (bool);\n    function fuseAdminHasRights() external view returns (bool);\n\n    function oracle() external view returns (IPriceOracle);\n    function closeFactorMantissa() external view returns (uint);\n    function liquidationIncentiveMantissa() external view returns (uint);\n\n    function markets(address cToken) external view returns (bool, uint);\n\n    function getAssetsIn(address account) external view returns (ICToken[] memory);\n    function checkMembership(address account, ICToken cToken) external view returns (bool);\n    function getAccountLiquidity(address account) external view returns (uint, uint, uint);\n\n    function _setPriceOracle(IPriceOracle newOracle) external returns (uint);\n    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint256);\n    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint);\n    function _become(IUnitroller unitroller) external;\n\n    function borrowGuardianPaused(address cToken) external view returns (bool);\n\n    function getRewardsDistributors() external view returns (IRewardsDistributor[] memory);\n    function getAllMarkets() external view returns (ICToken[] memory);\n    function getAllBorrowers() external view returns (address[] memory);\n    function suppliers(address account) external view returns (bool);\n    function enforceWhitelist() external view returns (bool);\n    function whitelist(address account) external view returns (bool);\n\n    function _setWhitelistEnforcement(bool enforce) external returns (uint);\n    function _setWhitelistStatuses(address[] calldata _suppliers, bool[] calldata statuses) external returns (uint);\n\n    function _toggleAutoImplementations(bool enabled) external returns (uint);\n}\n"
    },
    "contracts/external/compound/IUnitroller.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity >=0.7.0;\n\n/**\n * @title ComptrollerCore\n * @dev Storage for the comptroller is at this address, while execution is delegated to the `comptrollerImplementation`.\n * CTokens should reference this contract as their comptroller.\n */\ninterface IUnitroller {\n    function _setPendingImplementation(address newPendingImplementation) external returns (uint);\n    function _setPendingAdmin(address newPendingAdmin) external returns (uint);\n}\n"
    },
    "contracts/external/compound/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity >=0.7.0;\n\nimport \"./ICToken.sol\";\n\ninterface IPriceOracle {\n    /**\n      * @notice Get the underlying price of a cToken asset\n      * @param cToken The cToken to get the underlying price of\n      * @return The underlying asset price mantissa (scaled by 1e18).\n      *  Zero means the price is unavailable.\n      */\n    function getUnderlyingPrice(ICToken cToken) external view returns (uint);\n}\n"
    },
    "contracts/external/compound/ICToken.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity >=0.7.0;\n\n/**\n * @title Compound's CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n */\ninterface ICToken {\n    function admin() external view returns (address);\n    function adminHasRights() external view returns (bool);\n    function fuseAdminHasRights() external view returns (bool);\n    function symbol() external view returns (string memory);\n    function comptroller() external view returns (address);\n    function adminFeeMantissa() external view returns (uint256);\n    function fuseFeeMantissa() external view returns (uint256);\n    function reserveFactorMantissa() external view returns (uint256);\n    function totalReserves() external view returns (uint);\n    function totalAdminFees() external view returns (uint);\n    function totalFuseFees() external view returns (uint);\n\n    function isCToken() external view returns (bool);\n    function isCEther() external view returns (bool);\n\n    function balanceOf(address owner) external view returns (uint);\n    function balanceOfUnderlying(address owner) external returns (uint);\n    function borrowRatePerBlock() external view returns (uint);\n    function supplyRatePerBlock() external view returns (uint);\n    function totalBorrowsCurrent() external returns (uint);\n    function borrowBalanceStored(address account) external view returns (uint);\n    function exchangeRateStored() external view returns (uint);\n    function getCash() external view returns (uint);\n\n    function redeem(uint redeemTokens) external returns (uint);\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\n}\n"
    },
    "contracts/external/compound/IRewardsDistributor.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity >=0.7.0;\n\nimport \"./ICToken.sol\";\n\n/**\n * @title RewardsDistributor\n * @author Compound\n */\ninterface IRewardsDistributor {\n    /// @dev The token to reward (i.e., COMP)\n    function rewardToken() external view returns (address);\n\n    /// @notice The portion of compRate that each market currently receives\n    function compSupplySpeeds(address) external view returns (uint);\n\n    /// @notice The portion of compRate that each market currently receives\n    function compBorrowSpeeds(address) external view returns (uint);\n\n    /// @notice The COMP accrued but not yet transferred to each user\n    function compAccrued(address) external view returns (uint);\n\n    /**\n     * @notice Keeps the flywheel moving pre-mint and pre-redeem\n     * @dev Called by the Comptroller\n     * @param cToken The relevant market\n     * @param supplier The minter/redeemer\n     */\n    function flywheelPreSupplierAction(address cToken, address supplier) external;\n\n    /**\n     * @notice Keeps the flywheel moving pre-borrow and pre-repay\n     * @dev Called by the Comptroller\n     * @param cToken The relevant market\n     * @param borrower The borrower\n     */\n    function flywheelPreBorrowerAction(address cToken, address borrower) external;\n\n    /**\n     * @notice Returns an array of all markets.\n     */\n    function getAllMarkets() external view returns (ICToken[] memory);\n}\n"
    },
    "contracts/FusePoolLensSecondary.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"./external/compound/IComptroller.sol\";\nimport \"./external/compound/IPriceOracle.sol\";\nimport \"./external/compound/ICToken.sol\";\nimport \"./external/compound/IRewardsDistributor.sol\";\n\nimport \"./external/uniswap/IUniswapV2Pair.sol\";\n\nimport \"./FusePoolDirectory.sol\";\nimport \"./oracles/MasterPriceOracle.sol\";\n\n/**\n * @title FusePoolLensSecondary\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice FusePoolLensSecondary returns data on Fuse interest rate pools in mass for viewing by dApps, bots, etc.\n */\ncontract FusePoolLensSecondary is Initializable {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Constructor to set the `FusePoolDirectory` contract object.\n     */\n    function initialize(FusePoolDirectory _directory) public initializer {\n        require(address(_directory) != address(0), \"FusePoolDirectory instance cannot be the zero address.\");\n        directory = _directory;\n    }\n\n    /**\n     * @notice `FusePoolDirectory` contract object.\n     */\n    FusePoolDirectory public directory;\n\n    /**\n     * @notice Struct for ownership over a CToken.\n     */\n    struct CTokenOwnership {\n        address cToken;\n        address admin;\n        bool adminHasRights;\n        bool fuseAdminHasRights;\n    }\n\n    /**\n     * @notice Returns the admin, admin rights, Fuse admin (constant), Fuse admin rights, and an array of cTokens with differing properties.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n     */\n    function getPoolOwnership(IComptroller comptroller) external view returns (address, bool, bool, CTokenOwnership[] memory) {\n        // Get pool ownership\n        address comptrollerAdmin = comptroller.admin();\n        bool comptrollerAdminHasRights = comptroller.adminHasRights();\n        bool comptrollerFuseAdminHasRights = comptroller.fuseAdminHasRights();\n\n        // Get cToken ownership\n        ICToken[] memory cTokens = comptroller.getAllMarkets();\n        uint256 arrayLength = 0;\n\n        for (uint256 i = 0; i < cTokens.length; i++) {\n            ICToken cToken = cTokens[i];\n            (bool isListed, ) = comptroller.markets(address(cToken));\n            if (!isListed) continue;\n            \n            address cTokenAdmin;\n            try cToken.admin() returns (address _cTokenAdmin) {\n                cTokenAdmin = _cTokenAdmin;\n            } catch {\n                continue;\n            }\n            bool cTokenAdminHasRights = cToken.adminHasRights();\n            bool cTokenFuseAdminHasRights = cToken.fuseAdminHasRights();\n\n            // If outlier, push to array\n            if (cTokenAdmin != comptrollerAdmin || cTokenAdminHasRights != comptrollerAdminHasRights || cTokenFuseAdminHasRights != comptrollerFuseAdminHasRights)\n                arrayLength++;\n        }\n\n        CTokenOwnership[] memory outliers = new CTokenOwnership[](arrayLength);\n        uint256 arrayIndex = 0;\n\n        for (uint256 i = 0; i < cTokens.length; i++) {\n            ICToken cToken = cTokens[i];\n            (bool isListed, ) = comptroller.markets(address(cToken));\n            if (!isListed) continue;\n            \n            address cTokenAdmin;\n            try cToken.admin() returns (address _cTokenAdmin) {\n                cTokenAdmin = _cTokenAdmin;\n            } catch {\n                continue;\n            }\n            bool cTokenAdminHasRights = cToken.adminHasRights();\n            bool cTokenFuseAdminHasRights = cToken.fuseAdminHasRights();\n\n            // If outlier, push to array and increment array index\n            if (cTokenAdmin != comptrollerAdmin || cTokenAdminHasRights != comptrollerAdminHasRights || cTokenFuseAdminHasRights != comptrollerFuseAdminHasRights) {\n                outliers[arrayIndex] = CTokenOwnership(address(cToken), cTokenAdmin, cTokenAdminHasRights, cTokenFuseAdminHasRights);\n                arrayIndex++;\n            }\n        }\n        \n        return (comptrollerAdmin, comptrollerAdminHasRights, comptrollerFuseAdminHasRights, outliers);\n    }\n    \n    /**\n     * @notice Determine the maximum redeem amount of a cToken.\n     * @param cTokenModify The market to hypothetically redeem in.\n     * @param account The account to determine liquidity for.\n     * @return Maximum redeem amount.\n     */\n    function getMaxRedeem(address account, ICToken cTokenModify) external returns (uint256) {\n        return getMaxRedeemOrBorrow(account, cTokenModify, false);\n    }\n\n    /**\n     * @notice Determine the maximum borrow amount of a cToken.\n     * @param cTokenModify The market to hypothetically borrow in.\n     * @param account The account to determine liquidity for.\n     * @return Maximum borrow amount.\n     */\n    function getMaxBorrow(address account, ICToken cTokenModify) external returns (uint256) {\n        return getMaxRedeemOrBorrow(account, cTokenModify, true);\n    }\n\n    /**\n     * @dev Internal function to determine the maximum borrow/redeem amount of a cToken.\n     * @param cTokenModify The market to hypothetically borrow/redeem in.\n     * @param account The account to determine liquidity for.\n     * @return Maximum borrow/redeem amount.\n     */\n    function getMaxRedeemOrBorrow(address account, ICToken cTokenModify, bool isBorrow) internal returns (uint256) {\n        // Accrue interest\n        uint256 balanceOfUnderlying = cTokenModify.balanceOfUnderlying(account);\n\n        // Get account liquidity\n        IComptroller comptroller = IComptroller(cTokenModify.comptroller());\n        (uint256 err, uint256 liquidity, uint256 shortfall) = comptroller.getAccountLiquidity(account);\n        require(err == 0, \"Comptroller error when calculating account liquidity.\");\n        if (shortfall > 0) return 0; // Shortfall, so no more borrow/redeem\n\n        // Get max borrow/redeem\n        uint256 maxBorrowOrRedeemAmount;\n\n        if (!isBorrow && !comptroller.checkMembership(msg.sender, cTokenModify)) {\n            // Max redeem = balance of underlying if not used as collateral\n            maxBorrowOrRedeemAmount = balanceOfUnderlying;\n        } else {\n            // Avoid \"stack too deep\" error by separating this logic\n            maxBorrowOrRedeemAmount = _getMaxRedeemOrBorrow(liquidity, cTokenModify, isBorrow);\n\n            // Redeem only: max out at underlying balance\n            if (!isBorrow && balanceOfUnderlying < maxBorrowOrRedeemAmount) maxBorrowOrRedeemAmount = balanceOfUnderlying;\n        }\n\n        // Get max borrow or redeem considering cToken liquidity\n        uint256 cTokenLiquidity = cTokenModify.getCash();\n\n        // Return the minimum of the two maximums\n        return maxBorrowOrRedeemAmount <= cTokenLiquidity ? maxBorrowOrRedeemAmount : cTokenLiquidity;\n    }\n\n    /**\n     * @dev Portion of the logic in `getMaxRedeemOrBorrow` above separated to avoid \"stack too deep\" errors.\n     */\n    function _getMaxRedeemOrBorrow(uint256 liquidity, ICToken cTokenModify, bool isBorrow) internal view returns (uint256) {\n        if (liquidity <= 0) return 0; // No available account liquidity, so no more borrow/redeem\n\n        // Get the normalized price of the asset\n        IComptroller comptroller = IComptroller(cTokenModify.comptroller());\n        uint256 conversionFactor = comptroller.oracle().getUnderlyingPrice(cTokenModify);\n        require(conversionFactor > 0, \"Oracle price error.\");\n\n        // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n        if (!isBorrow) {\n            (, uint256 collateralFactorMantissa) = comptroller.markets(address(cTokenModify));\n            conversionFactor = collateralFactorMantissa.mul(conversionFactor).div(1e18);\n        }\n\n        // Get max borrow or redeem considering excess account liquidity\n        return liquidity.mul(1e18).div(conversionFactor);\n    }\n\n    /**\n     * @notice Returns an array of all markets, an array of all `RewardsDistributor` contracts, an array of reward token addresses for each `RewardsDistributor`, an array of supply speeds for each distributor for each, and their borrow speeds.\n     * @param comptroller The Fuse pool Comptroller to check.\n     */\n    function getRewardSpeedsByPool(IComptroller comptroller) public view returns (ICToken[] memory, IRewardsDistributor[] memory, address[] memory, uint256[][] memory, uint256[][] memory) {\n        ICToken[] memory allMarkets = comptroller.getAllMarkets();\n        IRewardsDistributor[] memory distributors;\n\n        try comptroller.getRewardsDistributors() returns (IRewardsDistributor[] memory _distributors) {\n            distributors = _distributors;\n        } catch {\n            distributors = new IRewardsDistributor[](0);\n        }\n\n        address[] memory rewardTokens = new address[](distributors.length);\n        uint256[][] memory supplySpeeds = new uint256[][](allMarkets.length);\n        uint256[][] memory borrowSpeeds = new uint256[][](allMarkets.length);\n\n        // Get reward tokens for each distributor\n        for (uint256 i = 0; i < distributors.length; i++) rewardTokens[i] = distributors[i].rewardToken();\n\n        // Get reward speeds for each market for each distributor\n        for (uint256 i = 0; i < allMarkets.length; i++) {\n            address cToken = address(allMarkets[i]);\n            supplySpeeds[i] = new uint256[](distributors.length);\n            borrowSpeeds[i] = new uint256[](distributors.length);\n\n            for (uint256 j = 0; j < distributors.length; j++) {\n                IRewardsDistributor distributor = distributors[j];\n                supplySpeeds[i][j] = distributor.compSupplySpeeds(cToken);\n                borrowSpeeds[i][j] = distributor.compBorrowSpeeds(cToken);\n            }\n        }\n\n        return (allMarkets, distributors, rewardTokens, supplySpeeds, borrowSpeeds);\n    }\n\n    /**\n     * @notice For each `Comptroller`, returns an array of all markets, an array of all `RewardsDistributor` contracts, an array of reward token addresses for each `RewardsDistributor`, an array of supply speeds for each distributor for each, and their borrow speeds.\n     * @param comptrollers The Fuse pool Comptrollers to check.\n     */\n    function getRewardSpeedsByPools(IComptroller[] memory comptrollers) external view returns (ICToken[][] memory, IRewardsDistributor[][] memory, address[][] memory, uint256[][][] memory, uint256[][][] memory) {\n        ICToken[][] memory allMarkets = new ICToken[][](comptrollers.length);\n        IRewardsDistributor[][] memory distributors = new IRewardsDistributor[][](comptrollers.length);\n        address[][] memory rewardTokens = new address[][](comptrollers.length);\n        uint256[][][] memory supplySpeeds = new uint256[][][](comptrollers.length);\n        uint256[][][] memory borrowSpeeds = new uint256[][][](comptrollers.length);\n        for (uint256 i = 0; i < comptrollers.length; i++) (allMarkets[i], distributors[i], rewardTokens[i], supplySpeeds[i], borrowSpeeds[i]) = getRewardSpeedsByPool(comptrollers[i]);\n        return (allMarkets, distributors, rewardTokens, supplySpeeds, borrowSpeeds);\n    }\n\n    /**\n     * @notice Returns unaccrued rewards by `holder` from `cToken` on `distributor`.\n     * @param holder The address to check.\n     * @param distributor The RewardsDistributor to check.\n     * @param cToken The CToken to check.\n     * @return Unaccrued (unclaimed) supply-side rewards and unaccrued (unclaimed) borrow-side rewards.\n     */\n    function getUnaccruedRewards(address holder, IRewardsDistributor distributor, ICToken cToken) internal returns (uint256, uint256) {\n        // Get unaccrued supply rewards\n        uint256 compAccruedPrior = distributor.compAccrued(holder);\n        distributor.flywheelPreSupplierAction(address(cToken), holder);\n        uint256 supplyRewardsUnaccrued = distributor.compAccrued(holder).sub(compAccruedPrior);\n\n        // Get unaccrued borrow rewards\n        compAccruedPrior = distributor.compAccrued(holder);\n        distributor.flywheelPreBorrowerAction(address(cToken), holder);\n        uint256 borrowRewardsUnaccrued = distributor.compAccrued(holder).sub(compAccruedPrior);\n\n        // Return both\n        return (supplyRewardsUnaccrued, borrowRewardsUnaccrued);\n    }\n\n    /**\n     * @notice Returns all unclaimed rewards accrued by the `holder` on `distributors`.\n     * @param holder The address to check.\n     * @param distributors The `RewardsDistributor` contracts to check.\n     * @return For each of `distributors`: total quantity of unclaimed rewards, array of cTokens, array of unaccrued (unclaimed) supply-side and borrow-side rewards per cToken, and quantity of funds available in the distributor.\n     */\n    function getUnclaimedRewardsByDistributors(address holder, IRewardsDistributor[] memory distributors) external returns (address[] memory, uint256[] memory, ICToken[][] memory, uint256[2][][] memory, uint256[] memory) {\n        address[] memory rewardTokens = new address[](distributors.length);\n        uint256[] memory compUnclaimedTotal = new uint256[](distributors.length);\n        ICToken[][] memory allMarkets = new ICToken[][](distributors.length);\n        uint256[2][][] memory rewardsUnaccrued = new uint256[2][][](distributors.length);\n        uint256[] memory distributorFunds = new uint256[](distributors.length);\n\n        for (uint256 i = 0; i < distributors.length; i++) {\n            IRewardsDistributor distributor = distributors[i];\n            rewardTokens[i] = distributor.rewardToken();\n            allMarkets[i] = distributor.getAllMarkets();\n            rewardsUnaccrued[i] = new uint256[2][](allMarkets[i].length);\n            for (uint256 j = 0; j < allMarkets[i].length; j++) (rewardsUnaccrued[i][j][0], rewardsUnaccrued[i][j][1]) = getUnaccruedRewards(holder, distributor, allMarkets[i][j]);\n            compUnclaimedTotal[i] = distributor.compAccrued(holder);\n            distributorFunds[i] = IERC20Upgradeable(rewardTokens[i]).balanceOf(address(distributor));\n        }\n\n        return (rewardTokens, compUnclaimedTotal, allMarkets, rewardsUnaccrued, distributorFunds);\n    }\n\n    /**\n     * @notice Returns arrays of indexes, `Comptroller` proxy contracts, and `RewardsDistributor` contracts for Fuse pools supplied to by `account`.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     */\n    function getRewardsDistributorsBySupplier(address supplier) external view returns (uint256[] memory, IComptroller[] memory, IRewardsDistributor[][] memory) {\n        // Get array length\n        FusePoolDirectory.FusePool[] memory pools = directory.getAllPools();\n        uint256 arrayLength = 0;\n\n        for (uint256 i = 0; i < pools.length; i++) {\n            try IComptroller(pools[i].comptroller).suppliers(supplier) returns (bool isSupplier) {\n                if (isSupplier) arrayLength++;\n            } catch {}\n        }\n\n        // Build array\n        uint256[] memory indexes = new uint256[](arrayLength);\n        IComptroller[] memory comptrollers = new IComptroller[](arrayLength);\n        IRewardsDistributor[][] memory distributors = new IRewardsDistributor[][](arrayLength);\n        uint256 index = 0;\n\n        for (uint256 i = 0; i < pools.length; i++) {\n            IComptroller comptroller = IComptroller(pools[i].comptroller);\n\n            try comptroller.suppliers(supplier) returns (bool isSupplier) {\n                if (isSupplier) {\n                    indexes[index] = i;\n                    comptrollers[index] = comptroller;\n\n                    try comptroller.getRewardsDistributors() returns (IRewardsDistributor[] memory _distributors) {\n                        distributors[index] = _distributors;\n                    } catch {}\n\n                    index++;\n                }\n            } catch {}\n        }\n\n        // Return distributors\n        return (indexes, comptrollers, distributors);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"./IERC20Upgradeable.sol\";\nimport \"../../math/SafeMathUpgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable {\n    using SafeMathUpgradeable for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n    uint256[44] private __gap;\n}\n"
    },
    "contracts/external/uniswap/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.7.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/oracles/MasterPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title MasterPriceOracle\n * @notice Use a combination of price oracles.\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract MasterPriceOracle is Initializable, IPriceOracle, BasePriceOracle {\n    /**\n     * @dev Maps underlying token addresses to `PriceOracle` contracts (can be `BasePriceOracle` contracts too).\n     */\n    mapping(address => IPriceOracle) public oracles;\n\n    /**\n     * @dev Default/fallback `PriceOracle`.\n     */\n    IPriceOracle public defaultOracle;\n\n    /**\n     * @dev The administrator of this `MasterPriceOracle`.\n     */\n    address public admin;\n\n    /**\n     * @dev Controls if `admin` can overwrite existing assignments of oracles to underlying tokens.\n     */\n    bool internal noAdminOverwrite;\n\n    /**\n     * @dev The Wrapped native asset address.\n     */\n    address public wtoken;\n\n    /**\n     * @dev Returns a boolean indicating if `admin` can overwrite existing assignments of oracles to underlying tokens.\n     */\n    function canAdminOverwrite() external view returns (bool) {\n        return !noAdminOverwrite;\n    }\n\n    /**\n     * @dev Event emitted when `admin` is changed.\n     */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /**\n     * @dev Event emitted when the default oracle is changed.\n     */\n    event NewDefaultOracle(address oldOracle, address newOracle);\n\n    /**\n     * @dev Event emitted when an underlying token's oracle is changed.\n     */\n    event NewOracle(address underlying, address oldOracle, address newOracle);\n\n    /**\n     * @dev Constructor to initialize state variables.\n     * @param underlyings The underlying ERC20 token addresses to link to `_oracles`.\n     * @param _oracles The `PriceOracle` contracts to be assigned to `underlyings`.\n     * @param _defaultOracle The default `PriceOracle` contract to use.\n     * @param _admin The admin who can assign oracles to underlying tokens.\n     * @param _canAdminOverwrite Controls if `admin` can overwrite existing assignments of oracles to underlying tokens.\n     */\n    function initialize(\n        address[] memory underlyings, \n        IPriceOracle[] memory _oracles, \n        IPriceOracle _defaultOracle, \n        address _admin, \n        bool _canAdminOverwrite, \n        address _wtoken\n    ) external initializer {\n        // Input validation\n        require(underlyings.length == _oracles.length, \"Lengths of both arrays must be equal.\");\n\n        // Initialize state variables\n        for (uint256 i = 0; i < underlyings.length; i++) {\n            address underlying = underlyings[i];\n            IPriceOracle newOracle = _oracles[i];\n            oracles[underlying] = newOracle;\n            emit NewOracle(underlying, address(0), address(newOracle));\n        }\n\n        defaultOracle = _defaultOracle;\n        admin = _admin;\n        noAdminOverwrite = !_canAdminOverwrite;\n        wtoken = _wtoken;\n    }\n\n    /**\n     * @dev Sets `_oracles` for `underlyings`.\n     */\n    function add(address[] calldata underlyings, IPriceOracle[] calldata _oracles) external onlyAdmin {\n        // Input validation\n        require(underlyings.length > 0 && underlyings.length == _oracles.length, \"Lengths of both arrays must be equal and greater than 0.\");\n\n        // Assign oracles to underlying tokens\n        for (uint256 i = 0; i < underlyings.length; i++) {\n            address underlying = underlyings[i];\n            address oldOracle = address(oracles[underlying]);\n            if (noAdminOverwrite) require(oldOracle == address(0), \"Admin cannot overwrite existing assignments of oracles to underlying tokens.\");\n            IPriceOracle newOracle = _oracles[i];\n            oracles[underlying] = newOracle;\n            emit NewOracle(underlying, oldOracle, address(newOracle));\n        }\n    }\n\n    /**\n     * @dev Changes the admin and emits an event.\n     */\n    function setDefaultOracle(IPriceOracle newOracle) external onlyAdmin {\n        IPriceOracle oldOracle = defaultOracle;\n        defaultOracle = newOracle;\n        emit NewDefaultOracle(address(oldOracle), address(newOracle));\n    }\n\n    /**\n     * @dev Changes the admin and emits an event.\n     */\n    function changeAdmin(address newAdmin) external onlyAdmin {\n        address oldAdmin = admin;\n        admin = newAdmin;\n        emit NewAdmin(oldAdmin, newAdmin);\n    }\n\n    /**\n     * @dev Modifier that checks if `msg.sender == admin`.\n     */\n    modifier onlyAdmin {\n        require(msg.sender == admin, \"Sender is not the admin.\");\n        _;\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(ICToken cToken) external override view returns (uint) {\n        // Get underlying ERC20 token address\n        address underlying = address(ICErc20(address(cToken)).underlying());\n\n        // Return 1e18 for WETH\n        if (underlying == wtoken) return 1e18;\n\n        // Get underlying price from assigned oracle\n        IPriceOracle oracle = oracles[underlying];\n        if (address(oracle) != address(0)) return oracle.getUnderlyingPrice(cToken);\n        if (address(defaultOracle) != address(0)) return defaultOracle.getUnderlyingPrice(cToken);\n        revert(\"Price oracle not found for this underlying token address.\");\n    }\n\n    /**\n     * @dev Attempts to return the price in ETH of `underlying` (implements `BasePriceOracle`).\n     */\n    function price(address underlying) external override view returns (uint) {\n        // Return 1e18 for WETH\n        if (underlying == wtoken) return 1e18;\n\n        // Get underlying price from assigned oracle\n        IPriceOracle oracle = oracles[underlying];\n        if (address(oracle) != address(0)) return BasePriceOracle(address(oracle)).price(underlying);\n        if (address(defaultOracle) != address(0)) return BasePriceOracle(address(defaultOracle)).price(underlying);\n        revert(\"Price oracle not found for this underlying token address.\");\n    }\n}\n"
    },
    "contracts/external/compound/ICErc20.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity >=0.7.0;\n\nimport \"./ICToken.sol\";\n\n/**\n * @title Compound's CErc20 Contract\n * @notice CTokens which wrap an EIP-20 underlying\n * @author Compound\n */\ninterface ICErc20 is ICToken {\n    function underlying() external view returns (address);\n    function liquidateBorrow(address borrower, uint repayAmount, ICToken cTokenCollateral) external returns (uint);\n}\n"
    },
    "contracts/oracles/BasePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"../external/compound/IPriceOracle.sol\";\n\n/**\n * @title BasePriceOracle\n * @notice Returns prices of underlying tokens directly without the caller having to specify a cToken address.\n * @dev Implements the `PriceOracle` interface.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ninterface BasePriceOracle is IPriceOracle {\n    /**\n     * @notice Get the price of an underlying asset.\n     * @param underlying The underlying asset to get the price of.\n     * @return The underlying asset price in ETH as a mantissa (scaled by 1e18).\n     * Zero means the price is unavailable.\n     */\n    function price(address underlying) external view returns (uint);\n}\n"
    },
    "contracts/oracles/default/PreferredPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../BasePriceOracle.sol\";\nimport \"../MasterPriceOracle.sol\";\nimport \"../default/ChainlinkPriceOracleV2.sol\";\n\n/**\n * @title PreferredPriceOracle\n * @notice Returns prices from MasterPriceOracle, ChainlinkPriceOracleV2, or prices from a tertiary oracle (in order of preference).\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract PreferredPriceOracle is IPriceOracle, BasePriceOracle {\n    /**\n     * @dev The primary `MasterPriceOracle`.\n     */\n    MasterPriceOracle public masterOracle;\n\n    /**\n     * @dev The secondary `ChainlinkPriceOracleV2`.\n     */\n    ChainlinkPriceOracleV2 public chainlinkOracleV2;\n\n    /**\n     * @dev The tertiary `PriceOracle`.\n     */\n    IPriceOracle public tertiaryOracle;\n\n    /**\n    * @dev The Wrapped native asset address.\n     */\n    address public wtoken;\n\n    /**\n     * @dev Constructor to set the primary `MasterPriceOracle`, the secondary `ChainlinkPriceOracleV2`, and the tertiary `PriceOracle`.\n     */\n    constructor(MasterPriceOracle _masterOracle, ChainlinkPriceOracleV2 _chainlinkOracleV2, IPriceOracle _tertiaryOracle, address _wtoken) {\n        require(address(_masterOracle) != address(0), \"MasterPriceOracle not set.\");\n        require(address(_chainlinkOracleV2) != address(0), \"ChainlinkPriceOracleV2 not set.\");\n        require(address(_tertiaryOracle) != address(0), \"Tertiary price oracle not set.\");\n        masterOracle = _masterOracle;\n        chainlinkOracleV2 = _chainlinkOracleV2;\n        tertiaryOracle = _tertiaryOracle;\n        wtoken = _wtoken;\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying) external override view returns (uint) {\n        // Return 1e18 for wtoken\n        if (underlying == wtoken) return 1e18;\n\n        // Try to get MasterPriceOracle price\n        if (address(masterOracle.oracles(underlying)) != address(0)) return masterOracle.price(underlying);\n\n        // Try to get ChainlinkPriceOracleV2 price\n        if (address(chainlinkOracleV2.priceFeeds(underlying)) != address(0)) return chainlinkOracleV2.price(underlying);\n\n        // Otherwise, get price from tertiary oracle\n        return BasePriceOracle(address(tertiaryOracle)).price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(ICToken cToken) external override view returns (uint) {\n        // Return 1e18 for ETH\n        if (cToken.isCEther()) return 1e18;\n\n        // Get underlying ERC20 token address\n        address underlying = address(ICErc20(address(cToken)).underlying());\n\n        // Return 1e18 for wtoken\n        if (underlying == wtoken) return 1e18;\n\n        // Try to get MasterPriceOracle price\n        if (address(masterOracle.oracles(underlying)) != address(0)) return masterOracle.getUnderlyingPrice(cToken);\n\n        // Try to get ChainlinkPriceOracleV2 price\n        if (address(chainlinkOracleV2.priceFeeds(underlying)) != address(0)) return chainlinkOracleV2.getUnderlyingPrice(cToken);\n\n        // Otherwise, get price from tertiary oracle\n        return tertiaryOracle.getUnderlyingPrice(cToken);\n    }\n}\n"
    },
    "contracts/oracles/default/ChainlinkPriceOracleV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/chainlink/AggregatorV3Interface.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title ChainlinkPriceOracleV2\n * @notice Returns prices from Chainlink.\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract ChainlinkPriceOracleV2 is IPriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Maps ERC20 token addresses to ETH-based Chainlink price feed contracts.\n     */\n    mapping(address => AggregatorV3Interface) public priceFeeds;\n\n    /**\n     * @notice Maps ERC20 token addresses to enums indicating the base currency of the feed.\n     */\n    mapping(address => FeedBaseCurrency) public feedBaseCurrencies;\n\n    /**\n     * @notice Enum indicating the base currency of a Chainlink price feed.\n     */\n    enum FeedBaseCurrency {\n        ETH,\n        USD\n    }\n\n    /**\n     * @notice Chainlink NATIVE/USD price feed contracts.\n     */\n    AggregatorV3Interface public immutable NATIVE_TOKEN_USD_PRICE_FEED;\n\n    /**\n     * @dev The administrator of this `MasterPriceOracle`.\n     */\n    address public admin;\n\n    /**\n     * @dev Controls if `admin` can overwrite existing assignments of oracles to underlying tokens.\n     */\n    bool public canAdminOverwrite;\n\n    /**\n     * @dev The Wrapped native asset address.\n     */\n    address public immutable wtoken;\n\n    /**\n     * @dev Constructor to set admin and canAdminOverwrite, wtoken address and native token USD price feed address\n     */\n    constructor (address _admin, bool _canAdminOverwrite, address _wtoken, address nativeTokenUsd) {\n        admin = _admin;\n        canAdminOverwrite = _canAdminOverwrite;\n        wtoken = _wtoken;\n        NATIVE_TOKEN_USD_PRICE_FEED = AggregatorV3Interface(nativeTokenUsd);\n    }\n\n    /**\n     * @dev Changes the admin and emits an event.\n     */\n    function changeAdmin(address newAdmin) external onlyAdmin {\n        address oldAdmin = admin;\n        admin = newAdmin;\n        emit NewAdmin(oldAdmin, newAdmin);\n    }\n\n    /**\n     * @dev Event emitted when `admin` is changed.\n     */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /**\n     * @dev Modifier that checks if `msg.sender == admin`.\n     */\n    modifier onlyAdmin {\n        require(msg.sender == admin, \"Sender is not the admin.\");\n        _;\n    }\n\n    /**\n     * @dev Admin-only function to set price feeds.\n     * @param underlyings Underlying token addresses for which to set price feeds.\n     * @param feeds The Chainlink price feed contract addresses for each of `underlyings`.\n     * @param baseCurrency The currency in which `feeds` are based.\n     */\n    function setPriceFeeds(address[] memory underlyings, AggregatorV3Interface[] memory feeds, FeedBaseCurrency baseCurrency) external onlyAdmin {\n        // Input validation\n        require(underlyings.length > 0 && underlyings.length == feeds.length, \"Lengths of both arrays must be equal and greater than 0.\");\n\n        // For each token/feed\n        for (uint256 i = 0; i < underlyings.length; i++) {\n            address underlying = underlyings[i];\n\n            // Check for existing oracle if !canAdminOverwrite\n            if (!canAdminOverwrite) require(address(priceFeeds[underlying]) == address(0), \"Admin cannot overwrite existing assignments of price feeds to underlying tokens.\");\n\n            // Set feed and base currency\n            priceFeeds[underlying] = feeds[i];\n            feedBaseCurrencies[underlying] = baseCurrency;\n        }\n    }\n\n    /**\n     * @dev Internal function returning the price in ETH of `underlying`.\n     */\n    function _price(address underlying) internal view returns (uint) {\n        // Return 1e18 for WTOKEN\n        if (underlying == wtoken || underlying == address(0)) return 1e18;\n\n        // Get token/ETH price from Chainlink\n        AggregatorV3Interface feed = priceFeeds[underlying];\n        require(address(feed) != address(0), \"No Chainlink price feed found for this underlying ERC20 token.\");\n        FeedBaseCurrency baseCurrency = feedBaseCurrencies[underlying];\n\n        if (baseCurrency == FeedBaseCurrency.ETH) {\n            (, int256 tokenEthPrice, , , ) = feed.latestRoundData();\n            return tokenEthPrice >= 0 ? uint256(tokenEthPrice).mul(1e18).div(10 ** uint256(feed.decimals())) : 0;\n        } else if (baseCurrency == FeedBaseCurrency.USD) {\n            (, int256 nativeTokenUsdPrice, , , ) = NATIVE_TOKEN_USD_PRICE_FEED.latestRoundData();\n            if (nativeTokenUsdPrice <= 0) return 0;\n            (, int256 tokenUsdPrice, , , ) = feed.latestRoundData();\n            return tokenUsdPrice >= 0 ? uint256(tokenUsdPrice).mul(1e26).div(10 ** uint256(feed.decimals())).div(uint256(nativeTokenUsdPrice)) : 0;\n        }\n    }\n\n    /**\n     * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n     */\n    function price(address underlying) external override view returns (uint) {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(ICToken cToken) external override view returns (uint) {\n        // Return 1e18 for ETH\n        if (cToken.isCEther()) return 1e18;\n\n        // Get underlying token address\n        address underlying = ICErc20(address(cToken)).underlying();\n\n        // Get price\n        uint256 chainlinkPrice = _price(underlying);\n\n        // Format and return price\n        uint256 underlyingDecimals = uint256(ERC20Upgradeable(underlying).decimals());\n        return underlyingDecimals <= 18 ? uint256(chainlinkPrice).mul(10 ** (18 - underlyingDecimals)) : uint256(chainlinkPrice).div(10 ** (underlyingDecimals - 18));\n    }\n}\n"
    },
    "contracts/external/chainlink/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n    function description() external view returns (string memory);\n    function version() external view returns (uint256);\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n"
    },
    "contracts/oracles/mainnet/YVaultV2PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/yearn/IVaultV2.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title YVaultV2PriceOracle\n * @notice Returns prices for V2 yVaults (using the sender as a root oracle).\n * @dev Implements the `PriceOracle` interface.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract YVaultV2PriceOracle is IPriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(ICToken cToken) external override view returns (uint256) {\n        // Get price of token underlying yVault\n        IVaultV2 yVault = IVaultV2(ICErc20(address(cToken)).underlying());\n        address underlyingToken = yVault.token();\n        uint underlyingPrice = underlyingToken == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 ? 1e18 : BasePriceOracle(msg.sender).price(underlyingToken);\n\n        // yVault/ETH = yVault/token * token/ETH\n        // Return value = yVault/ETH scaled by 1e(36 - yVault decimals)\n        // `pricePerShare` = yVault/token scaled by 1e(yVault decimals)\n        // `underlyingPrice` = token/ETH scaled by 1e18\n        // Return value = `pricePerShare` * `underlyingPrice` * 1e(18 - (yVault decimals * 2))\n        uint256 baseUnit = 10 ** uint256(yVault.decimals());\n        return yVault.pricePerShare().mul(underlyingPrice).div(baseUnit).mul(1e18).div(baseUnit);\n    }\n}\n"
    },
    "contracts/external/yearn/IVaultV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\ninterface IVaultV2 {\n    function pricePerShare() external view returns (uint);\n    function token() external view returns (address);\n    function decimals() external view returns (uint8);\n    function deposit(uint256 _amount) external returns (uint256);\n    function withdraw(uint256 maxShares) external returns (uint256);\n}\n"
    },
    "contracts/liquidators/YearnYVaultV2Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/yearn/IVaultV2.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title YearnYVaultV2Liquidator\n * @notice Exchanges seized Yearn yVault V2 token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract YearnYVaultV2Liquidator is IRedemptionStrategy {\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n        // Redeem yVault token for underlying token (and store output as new collateral)\n        IVaultV2 yVault = IVaultV2(address(inputToken));\n        outputAmount = yVault.withdraw(inputAmount);\n        outputToken = IERC20Upgradeable(yVault.token());\n    }\n}\n"
    },
    "contracts/liquidators/IRedemptionStrategy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\n/**\n * @title IRedemptionStrategy\n * @notice Redeems seized wrapped token collateral for an underlying token for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ninterface IRedemptionStrategy {\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external returns (IERC20Upgradeable outputToken, uint256 outputAmount);\n}\n"
    },
    "contracts/liquidators/YearnYVaultV1Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/yearn/IVault.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title YearnYVaultV1Liquidator\n * @notice Exchanges seized Yearn yVault V1 token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract YearnYVaultV1Liquidator is IRedemptionStrategy {\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n        // Redeem yVault token for underlying token (and store output as new collateral)\n        IVault yVault = IVault(address(inputToken));\n        yVault.withdraw(inputAmount);\n        outputToken = IERC20Upgradeable(yVault.token());\n        outputAmount = outputToken.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/external/yearn/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\ninterface IVault {\n    function getPricePerFullShare() external view returns (uint);\n    function token() external view returns (address);\n    function decimals() external view returns (uint8);\n    function deposit(uint _amount) external;\n    function withdraw(uint _shares) external;\n}\n"
    },
    "contracts/oracles/mainnet/YVaultV1PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/yearn/IVault.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title YVaultV1PriceOracle\n * @notice Returns prices for V1 yVaults (using the sender as a root oracle).\n * @dev Implements the `PriceOracle` interface.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract YVaultV1PriceOracle is IPriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(ICToken cToken) external override view returns (uint) {\n        // Get price of token underlying yVault\n        IVault yVault = IVault(ICErc20(address(cToken)).underlying());\n        address underlyingToken = yVault.token();\n        uint underlyingPrice = underlyingToken == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 ? 1e18 : BasePriceOracle(msg.sender).price(underlyingToken);\n\n        // yVault/ETH = yVault/token * token/ETH\n        // Return value = yVault/ETH scaled by 1e(36 - yVault decimals)\n        // `getPricePerFullShare` = yVault/token scaled by 1e18\n        // `underlyingPrice` = token/ETH scaled by 1e18\n        // Return value = `pricePerShare` * `underlyingPrice` / 1e(yVault decimals)\n        uint256 baseUnit = 10 ** uint256(yVault.decimals());\n        return yVault.getPricePerFullShare().mul(underlyingPrice).div(baseUnit); // getPricePerFullShare is scaled by 1e18\n    }\n}\n"
    },
    "contracts/oracles/mainnet/WSTEthPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/lido/IWstETH.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title WSTEthPriceOracle\n * @notice Returns prices for wstETH.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract WSTEthPriceOracle is IPriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying) external override view returns (uint) {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(ICToken cToken) external override view returns (uint) {\n        address underlying = ICErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return _price(underlying).mul(1e18).div(10 ** uint256(ERC20Upgradeable(underlying).decimals()));\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint) {\n        return IWstETH(token).stEthPerToken();\n    }\n}\n"
    },
    "contracts/external/lido/IWstETH.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\n/**\n * @title StETH token wrapper with static balances.\n * @dev It's an ERC20 token that represents the account's share of the total\n * supply of stETH tokens. WstETH token's balance only changes on transfers,\n * unlike StETH that is also changed when oracles report staking rewards and\n * penalties. It's a \"power user\" token for DeFi protocols which don't\n * support rebasable tokens.\n *\n * The contract is also a trustless wrapper that accepts stETH tokens and mints\n * wstETH in return. Then the user unwraps, the contract burns user's wstETH\n * and sends user locked stETH in return.\n *\n * The contract provides the staking shortcut: user can send ETH with regular\n * transfer and get wstETH in return. The contract will send ETH to Lido submit\n * method, staking it and wrapping the received stETH.\n *\n */\ninterface IWstETH {\n    function stETH() external view returns (address);\n\n    /**\n     * @notice Get amount of wstETH for a one stETH\n     * @return Amount of stETH for 1 wstETH\n     */\n    function stEthPerToken() external view returns (uint256);\n\n    /**\n     * @notice Exchanges wstETH to stETH\n     * @param _wstETHAmount amount of wstETH to uwrap in exchange for stETH\n     * @dev Requirements:\n     *  - `_wstETHAmount` must be non-zero\n     *  - msg.sender must have at least `_wstETHAmount` wstETH.\n     * @return Amount of stETH user receives after unwrap\n     */\n    function unwrap(uint256 _wstETHAmount) external returns (uint256);\n}"
    },
    "contracts/liquidators/WSTEthLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/lido/IWstETH.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title WSTEthLiquidator\n * @notice Redeems wstETH for underlying stETH for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract WSTEthLiquidator is IRedemptionStrategy {\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n        // Unwrap wstETH (and store output stETH as new collateral)\n        IWstETH token = IWstETH(address(inputToken));\n        token.unwrap(inputAmount);\n        outputToken = IERC20Upgradeable(token.stETH());\n        outputAmount = inputAmount;\n    }\n}\n"
    },
    "contracts/liquidators/UniswapV3Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\nimport \"../external/uniswap/ISwapRouter.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title UniswapV3Liquidator\n * @notice Exchanges seized token collateral for underlying tokens via a Uniswap V3 router for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapV3Liquidator is IRedemptionStrategy {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n     */\n    function safeApprove(IERC20Upgradeable token, address to, uint256 minAmount) private {\n        uint256 allowance = token.allowance(address(this), to);\n\n        if (allowance < minAmount) {\n            if (allowance > 0) token.safeApprove(to, 0);\n            token.safeApprove(to, uint256(-1));\n        }\n    }\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n        // Get Uniswap router, output token, and fee\n        (ISwapRouter swapRouter, address _outputToken, uint24 fee) = abi.decode(strategyData, (ISwapRouter, address, uint24));\n\n        // Swap underlying tokens\n        safeApprove(inputToken, address(swapRouter), inputAmount);\n        outputAmount = swapRouter.exactInputSingle(ISwapRouter.ExactInputSingleParams(address(inputToken), _outputToken, fee, address(this), block.timestamp, inputAmount, 0, 0));\n        outputToken = IERC20Upgradeable(_outputToken);\n    }\n}\n"
    },
    "contracts/external/uniswap/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.0;\npragma experimental ABIEncoderV2;\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n}"
    },
    "contracts/liquidators/UniswapV2Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\nimport \"../external/uniswap/IUniswapV2Router02.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title UniswapV2Liquidator\n * @notice Exchanges seized token collateral for underlying tokens via a Uniswap V2 router for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapV2Liquidator is IRedemptionStrategy {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n     */\n    function safeApprove(IERC20Upgradeable token, address to, uint256 minAmount) private {\n        uint256 allowance = token.allowance(address(this), to);\n\n        if (allowance < minAmount) {\n            if (allowance > 0) token.safeApprove(to, 0);\n            token.safeApprove(to, uint256(-1));\n        }\n    }\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n        // Get Uniswap router and path\n        (IUniswapV2Router02 uniswapV2Router, address[] memory swapPath) = abi.decode(strategyData, (IUniswapV2Router02, address[]));\n        require(swapPath.length >= 2 && swapPath[0] == address(inputToken), \"Invalid UniswapLiquidator swap path.\");\n\n        // Swap underlying tokens\n        safeApprove(inputToken, address(uniswapV2Router), inputAmount);\n        uniswapV2Router.swapExactTokensForTokens(inputAmount, 0, swapPath, address(this), block.timestamp);\n\n        // Get new collateral\n        outputToken = IERC20Upgradeable(swapPath[swapPath.length - 1]);\n        outputAmount = outputToken.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/external/uniswap/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.7.0;\n\nimport \"./IUniswapV2Router01.sol\";\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "contracts/external/uniswap/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.7.0;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "contracts/liquidators/UniswapLpTokenLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\nimport \"../external/uniswap/IUniswapV2Router02.sol\";\nimport \"../external/uniswap/IUniswapV2Pair.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title UniswapLpTokenLiquidator\n * @notice Exchanges seized Uniswap V2 LP token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapLpTokenLiquidator is IRedemptionStrategy {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n     */\n    function safeApprove(IERC20Upgradeable token, address to, uint256 minAmount) private {\n        uint256 allowance = token.allowance(address(this), to);\n\n        if (allowance < minAmount) {\n            if (allowance > 0) token.safeApprove(to, 0);\n            token.safeApprove(to, uint256(-1));\n        }\n    }\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n        // Exit Uniswap pool\n        IUniswapV2Pair pair = IUniswapV2Pair(address(inputToken));\n        address token0 = pair.token0();\n        address token1 = pair.token1();\n        pair.transfer(address(pair), inputAmount);\n        (uint amount0, uint amount1) = pair.burn(address(this));\n\n        // Swap underlying tokens\n        (IUniswapV2Router02 uniswapV2Router, address[] memory swapToken0Path, address[] memory swapToken1Path) = abi.decode(strategyData, (IUniswapV2Router02, address[], address[]));\n        require((swapToken0Path.length > 0 ? swapToken0Path[swapToken0Path.length - 1] : token0) == (swapToken1Path.length > 0 ? swapToken1Path[swapToken1Path.length - 1] : token1), \"Output of token0 swap path must equal output of token1 swap path.\");\n\n        if (swapToken0Path.length > 0 && swapToken0Path[swapToken0Path.length - 1] != token0) {\n            safeApprove(IERC20Upgradeable(token0), address(uniswapV2Router), amount0);\n            uniswapV2Router.swapExactTokensForTokens(amount0, 0, swapToken0Path, address(this), block.timestamp);\n        }\n\n        if (swapToken1Path.length > 0 && swapToken1Path[swapToken1Path.length - 1] != token1) {\n            safeApprove(IERC20Upgradeable(token1), address(uniswapV2Router), amount1);\n            uniswapV2Router.swapExactTokensForTokens(amount1, 0, swapToken1Path, address(this), block.timestamp);\n        }\n\n        // Get new collateral\n        outputToken = IERC20Upgradeable(swapToken0Path.length > 0 ? swapToken0Path[swapToken0Path.length - 1] : token0);\n        outputAmount = outputToken.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/oracles/mainnet/Keep3rV2PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/keep3r/Keep3rV2OracleFactory.sol\";\nimport \"../../external/keep3r/Keep3rV2Oracle.sol\";\n\nimport \"../../external/uniswap/IUniswapV2Pair.sol\";\nimport \"../../external/uniswap/IUniswapV2Factory.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title Keep3rV2PriceOracle\n * @notice Returns prices from `Keep3rV2Oracle`.\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract Keep3rV2PriceOracle is IPriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev Constructor that sets the Keep3rV1Oracle or SushiswapV1Oracle.\n     */\n    constructor (address _keep3rV2OracleFactory, address _uniswapV2Factory) {\n        keep3rV2OracleFactory = Keep3rV2OracleFactory(_keep3rV2OracleFactory);\n        uniswapV2Factory = IUniswapV2Factory(_uniswapV2Factory);\n    }\n\n    /**\n     * @dev Keep3rV1Oracle token contract object.\n     */\n    Keep3rV2OracleFactory immutable public keep3rV2OracleFactory;\n\n    /**\n     * @dev UniswapV2Factory contract object.\n     */\n    IUniswapV2Factory immutable public uniswapV2Factory;\n\n    /**\n     * @dev WETH token contract address.\n     */\n    address constant public WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /**\n     * @dev Minimum TWAP interval.\n     */\n    uint256 public constant MIN_TWAP_TIME = 15 minutes;\n\n    /**\n     * @dev Return the TWAP value price0. Revert if TWAP time range is not within the threshold.\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n     * @param pair The pair to query for price0.\n     */\n    function price0TWAP(address pair) internal view returns (uint) {\n        Keep3rV2Oracle feed = keep3rV2OracleFactory.feeds(pair);\n        uint length = feed.length();\n        require(length > 0, 'no length-1 observation');\n        (uint lastTime, uint lastPx0CumuCompressed, ) = feed.observations(length - 1);\n        if (lastTime > block.timestamp - MIN_TWAP_TIME) {\n            require(length > 1, 'no length-2 observation');\n            (lastTime, lastPx0CumuCompressed, ) = feed.observations(length - 2);\n        }\n        uint elapsedTime = block.timestamp - lastTime;\n        require(elapsedTime >= MIN_TWAP_TIME, 'no TWAP satisfying MIN_TWAP_TIME');\n        uint lastPx0Cumu = uint(lastPx0CumuCompressed) * (2 ** 112) / 1e18;\n        uint currPx0Cumu = currentPx0Cumu(pair);\n        return (currPx0Cumu - lastPx0Cumu) / (block.timestamp - lastTime); // overflow is desired\n    }\n\n    /**\n     * @dev Return the TWAP value price1. Revert if TWAP time range is not within the threshold.\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n     * @param pair The pair to query for price1.\n     */\n    function price1TWAP(address pair) internal view returns (uint) {\n        Keep3rV2Oracle feed = keep3rV2OracleFactory.feeds(pair);\n        uint length = feed.length();\n        require(length > 0, 'no length-1 observation');\n        (uint lastTime, , uint112 lastPx1CumuCompressed) = feed.observations(length - 1);\n        if (lastTime > block.timestamp - MIN_TWAP_TIME) {\n            require(length > 1, 'no length-2 observation');\n            (lastTime, , lastPx1CumuCompressed) = feed.observations(length - 2);\n        }\n        uint elapsedTime = block.timestamp - lastTime;\n        require(elapsedTime >= MIN_TWAP_TIME, 'no TWAP satisfying MIN_TWAP_TIME');\n        uint lastPx1Cumu = uint(lastPx1CumuCompressed) * (2 ** 112) / 1e18;\n        uint currPx1Cumu = currentPx1Cumu(pair);\n        return (currPx1Cumu - lastPx1Cumu) / (block.timestamp - lastTime); // overflow is desired\n    }\n\n    /**\n     * @dev Return the current price0 cumulative value on Uniswap.\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n     * @param pair The uniswap pair to query for price0 cumulative value.\n     */\n    function currentPx0Cumu(address pair) internal view returns (uint px0Cumu) {\n        uint32 currTime = uint32(block.timestamp);\n        px0Cumu = IUniswapV2Pair(pair).price0CumulativeLast();\n        (uint reserve0, uint reserve1, uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n        if (lastTime != block.timestamp) {\n            uint32 timeElapsed = currTime - lastTime; // overflow is desired\n            px0Cumu += uint((reserve1 << 112) / reserve0) * timeElapsed; // overflow is desired\n        }\n    }\n\n    /**\n     * @dev Return the current price1 cumulative value on Uniswap.\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n     * @param pair The uniswap pair to query for price1 cumulative value.\n     */\n    function currentPx1Cumu(address pair) internal view returns (uint px1Cumu) {\n        uint32 currTime = uint32(block.timestamp);\n        px1Cumu = IUniswapV2Pair(pair).price1CumulativeLast();\n        (uint reserve0, uint reserve1, uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n        if (lastTime != currTime) {\n            uint32 timeElapsed = currTime - lastTime; // overflow is desired\n            px1Cumu += uint((reserve0 << 112) / reserve1) * timeElapsed; // overflow is desired\n        }\n    }\n    \n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(ICToken cToken) external override view returns (uint) {\n        // Return 1e18 for ETH\n        if (cToken.isCEther()) return 1e18;\n\n        // Get underlying ERC20 token address\n        address underlying = ICErc20(address(cToken)).underlying();\n\n        // Get price, format, and return\n        uint256 baseUnit = 10 ** uint256(ERC20Upgradeable(underlying).decimals());\n        return _price(underlying).mul(1e18).div(baseUnit);\n    }\n    \n    /**\n     * @dev Internal function returning the price in ETH of `underlying`.\n     */\n    function _price(address underlying) internal view returns (uint) {\n        // Return 1e18 for WETH\n        if (underlying == WETH_ADDRESS) return 1e18;\n\n        // Call Keep3r for ERC20/ETH price and return\n        address pair = uniswapV2Factory.getPair(underlying, WETH_ADDRESS);\n        uint256 baseUnit = 10 ** uint256(ERC20Upgradeable(underlying).decimals());\n        return (underlying < WETH_ADDRESS ? price0TWAP(pair) : price1TWAP(pair)).div(2 ** 56).mul(baseUnit).div(2 ** 56); // Scaled by 1e18, not 2 ** 112\n    }\n\n    /**\n     * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n     */\n    function price(address underlying) external override view returns (uint) {\n        return _price(underlying);\n    }\n}\n"
    },
    "contracts/external/keep3r/Keep3rV2OracleFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"./Keep3rV2Oracle.sol\";\n\ncontract Keep3rV2OracleFactory {\n    mapping(address => Keep3rV2Oracle) public feeds;\n}\n"
    },
    "contracts/external/keep3r/Keep3rV2Oracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\ncontract Keep3rV2Oracle {\n    struct Observation {\n        uint32 timestamp;\n        uint112 price0Cumulative;\n        uint112 price1Cumulative;\n    }\n\n    Observation[65535] public observations;\n    uint16 public length;\n}\n"
    },
    "contracts/external/uniswap/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.7.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "contracts/oracles/mainnet/Keep3rPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/keep3r/Keep3rV1Oracle.sol\";\n\nimport \"../../external/uniswap/IUniswapV2Pair.sol\";\nimport \"../../external/uniswap/IUniswapV2Factory.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title Keep3rPriceOracle\n * @notice Returns prices from `Keep3rV1Oracle` or `SushiswapV1Oracle`.\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract Keep3rPriceOracle is IPriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev Constructor that sets the Keep3rV1Oracle or SushiswapV1Oracle.\n     */\n    constructor (bool sushiSwap) {\n        Keep3rV1Oracle _rootOracle = Keep3rV1Oracle(sushiSwap ? 0xf67Ab1c914deE06Ba0F264031885Ea7B276a7cDa : 0x73353801921417F465377c8d898c6f4C0270282C);\n        rootOracle = _rootOracle;\n        uniswapV2Factory = IUniswapV2Factory(_rootOracle.factory());\n    }\n\n    /**\n     * @dev Keep3rV1Oracle token contract object.\n     */\n    Keep3rV1Oracle immutable public rootOracle;\n\n    /**\n     * @dev WETH token contract address.\n     */\n    address constant public WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /**\n     * @dev UniswapV2Factory contract address.\n     */\n    IUniswapV2Factory immutable public uniswapV2Factory;\n\n    /**\n     * @dev Minimum TWAP interval.\n     */\n    uint256 public constant MIN_TWAP_TIME = 15 minutes;\n\n    /**\n     * @dev Maximum TWAP interval.\n     */\n    uint256 public constant MAX_TWAP_TIME = 60 minutes;\n\n    /**\n     * @dev Return the TWAP value price0. Revert if TWAP time range is not within the threshold.\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n     * @param pair The pair to query for price0.\n     */\n    function price0TWAP(address pair) internal view returns (uint) {\n        uint length = rootOracle.observationLength(pair);\n        require(length > 0, 'no length-1 observation');\n        (uint lastTime, uint lastPx0Cumu, ) = rootOracle.observations(pair, length - 1);\n        if (lastTime > block.timestamp - MIN_TWAP_TIME) {\n            require(length > 1, 'no length-2 observation');\n            (lastTime, lastPx0Cumu, ) = rootOracle.observations(pair, length - 2);\n        }\n        uint elapsedTime = block.timestamp - lastTime;\n        require(elapsedTime >= MIN_TWAP_TIME && elapsedTime <= MAX_TWAP_TIME, 'bad TWAP time');\n        uint currPx0Cumu = currentPx0Cumu(pair);\n        return (currPx0Cumu - lastPx0Cumu) / (block.timestamp - lastTime); // overflow is desired\n    }\n\n    /**\n     * @dev Return the TWAP value price1. Revert if TWAP time range is not within the threshold.\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n     * @param pair The pair to query for price1.\n     */\n    function price1TWAP(address pair) internal view returns (uint) {\n        uint length = rootOracle.observationLength(pair);\n        require(length > 0, 'no length-1 observation');\n        (uint lastTime, , uint lastPx1Cumu) = rootOracle.observations(pair, length - 1);\n        if (lastTime > block.timestamp - MIN_TWAP_TIME) {\n            require(length > 1, 'no length-2 observation');\n            (lastTime, , lastPx1Cumu) = rootOracle.observations(pair, length - 2);\n        }\n        uint elapsedTime = block.timestamp - lastTime;\n        require(elapsedTime >= MIN_TWAP_TIME && elapsedTime <= MAX_TWAP_TIME, 'bad TWAP time');\n        uint currPx1Cumu = currentPx1Cumu(pair);\n        return (currPx1Cumu - lastPx1Cumu) / (block.timestamp - lastTime); // overflow is desired\n    }\n\n    /**\n     * @dev Return the current price0 cumulative value on Uniswap.\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n     * @param pair The uniswap pair to query for price0 cumulative value.\n     */\n    function currentPx0Cumu(address pair) internal view returns (uint px0Cumu) {\n        uint32 currTime = uint32(block.timestamp);\n        px0Cumu = IUniswapV2Pair(pair).price0CumulativeLast();\n        (uint reserve0, uint reserve1, uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n        if (lastTime != block.timestamp) {\n            uint32 timeElapsed = currTime - lastTime; // overflow is desired\n            px0Cumu += uint((reserve1 << 112) / reserve0) * timeElapsed; // overflow is desired\n        }\n    }\n\n    /**\n     * @dev Return the current price1 cumulative value on Uniswap.\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n     * @param pair The uniswap pair to query for price1 cumulative value.\n     */\n    function currentPx1Cumu(address pair) internal view returns (uint px1Cumu) {\n        uint32 currTime = uint32(block.timestamp);\n        px1Cumu = IUniswapV2Pair(pair).price1CumulativeLast();\n        (uint reserve0, uint reserve1, uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n        if (lastTime != currTime) {\n            uint32 timeElapsed = currTime - lastTime; // overflow is desired\n            px1Cumu += uint((reserve0 << 112) / reserve1) * timeElapsed; // overflow is desired\n        }\n    }\n    \n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(ICToken cToken) external override view returns (uint) {\n        // Return 1e18 for ETH\n        if (cToken.isCEther()) return 1e18;\n\n        // Get underlying ERC20 token address\n        address underlying = ICErc20(address(cToken)).underlying();\n\n        // Get price, format, and return\n        uint256 baseUnit = 10 ** uint256(ERC20Upgradeable(underlying).decimals());\n        return _price(underlying).mul(1e18).div(baseUnit);\n    }\n    \n    /**\n     * @dev Internal function returning the price in ETH of `underlying`.\n     */\n    function _price(address underlying) internal view returns (uint) {\n        // Return 1e18 for WETH\n        if (underlying == WETH_ADDRESS) return 1e18;\n\n        // Call Keep3r for ERC20/ETH price and return\n        address pair = uniswapV2Factory.getPair(underlying, WETH_ADDRESS);\n        uint256 baseUnit = 10 ** uint256(ERC20Upgradeable(underlying).decimals());\n        return (underlying < WETH_ADDRESS ? price0TWAP(pair) : price1TWAP(pair)).div(2 ** 56).mul(baseUnit).div(2 ** 56); // Scaled by 1e18, not 2 ** 112\n    }\n\n    /**\n     * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n     */\n    function price(address underlying) external override view returns (uint) {\n        return _price(underlying);\n    }\n}\n"
    },
    "contracts/external/keep3r/Keep3rV1Oracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nabstract contract Keep3rV1Oracle {\n    struct Observation {\n        uint timestamp;\n        uint price0Cumulative;\n        uint price1Cumulative;\n    }\n\n    function factory() external pure virtual returns (address);\n    mapping(address => Observation[]) public observations;\n    function observationLength(address pair) external view virtual returns (uint);\n}\n"
    },
    "contracts/oracles/mainnet/MStablePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/mstable/IMasset.sol\";\nimport \"../../external/mstable/ISavingsContractV2.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title MStablePriceOracle\n * @notice Returns prices for the mStable imUSD ERC20 token.\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital>\n */\ncontract MStablePriceOracle is IPriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev mStable mUSD ERC20 token contract object.\n     */\n    IMasset constant public MUSD = IMasset(0xe2f2a5C287993345a840Db3B0845fbC70f5935a5);\n\n    /**\n     * @dev mStable imUSD ERC20 token contract object.\n     */\n    ISavingsContractV2 constant public IMUSD = ISavingsContractV2(0x30647a72Dc82d7Fbb1123EA74716aB8A317Eac19);\n\n    /**\n     * @dev mStable mBTC ERC20 token contract object.\n     */\n    IMasset constant public MBTC = IMasset(0x945Facb997494CC2570096c74b5F66A3507330a1);\n\n    /**\n     * @dev mStable imBTC ERC20 token contract object.\n     */\n    ISavingsContractV2 constant public IMBTC = ISavingsContractV2(0x17d8CBB6Bce8cEE970a4027d1198F6700A7a6c24);\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying) external override view returns (uint) {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(ICToken cToken) external override view returns (uint) {\n        address underlying = ICErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return _price(underlying).mul(1e18).div(10 ** uint256(ERC20Upgradeable(underlying).decimals()));\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address underlying) internal view returns (uint) {\n        if (underlying == address(MUSD))\n            return getMAssetEthPrice(MUSD);\n        else if (underlying == address(IMUSD))\n            return IMUSD.exchangeRate().mul(getMAssetEthPrice(MUSD)).div(1e18);\n        else if (underlying == address(MBTC))\n            return getMAssetEthPrice(MBTC);\n        else if (underlying == address(IMBTC))\n            return IMBTC.exchangeRate().mul(getMAssetEthPrice(MBTC)).div(1e18);\n        else revert(\"Invalid token passed to MStablePriceOracle.\");\n    }\n\n    /**\n     * @dev Returns the price in ETH of the mAsset using `msg.sender` as a root price oracle for underlying bAssets.\n     */\n    function getMAssetEthPrice(IMasset mAsset) internal view returns (uint256) {\n        (IMasset.BassetPersonal[] memory bAssetPersonal, IMasset.BassetData[] memory bAssetData) = mAsset.getBassets();\n        uint256 underlyingValueInEthScaled = 0;\n        for (uint256 i = 0; i < bAssetData.length; i++) underlyingValueInEthScaled = underlyingValueInEthScaled.add(uint256(bAssetData[i].vaultBalance).mul(uint256(bAssetData[i].ratio)).div(1e8).mul(BasePriceOracle(msg.sender).price(bAssetPersonal[i].addr)));\n        return underlyingValueInEthScaled.div(ERC20Upgradeable(address(mAsset)).totalSupply());\n    }\n}\n"
    },
    "contracts/external/mstable/IMasset.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./MassetStructs.sol\";\n\n/**\n * @title IMasset\n * @dev   (Internal) Interface for interacting with Masset\n *        VERSION: 1.0\n *        DATE:    2020-05-05\n */\ninterface IMasset is MassetStructs {\n    // Mint\n    function mint(\n        address _input,\n        uint256 _inputQuantity,\n        uint256 _minOutputQuantity,\n        address _recipient\n    ) external returns (uint256 mintOutput);\n\n    function mintMulti(\n        address[] calldata _inputs,\n        uint256[] calldata _inputQuantities,\n        uint256 _minOutputQuantity,\n        address _recipient\n    ) external returns (uint256 mintOutput);\n\n    function getMintOutput(address _input, uint256 _inputQuantity)\n        external\n        view\n        returns (uint256 mintOutput);\n\n    function getMintMultiOutput(address[] calldata _inputs, uint256[] calldata _inputQuantities)\n        external\n        view\n        returns (uint256 mintOutput);\n\n    // Swaps\n    function swap(\n        address _input,\n        address _output,\n        uint256 _inputQuantity,\n        uint256 _minOutputQuantity,\n        address _recipient\n    ) external returns (uint256 swapOutput);\n\n    function getSwapOutput(\n        address _input,\n        address _output,\n        uint256 _inputQuantity\n    ) external view returns (uint256 swapOutput);\n\n    // Redemption\n    function redeem(\n        address _output,\n        uint256 _mAssetQuantity,\n        uint256 _minOutputQuantity,\n        address _recipient\n    ) external returns (uint256 outputQuantity);\n\n    function redeemMasset(\n        uint256 _mAssetQuantity,\n        uint256[] calldata _minOutputQuantities,\n        address _recipient\n    ) external returns (uint256[] memory outputQuantities);\n\n    function redeemExactBassets(\n        address[] calldata _outputs,\n        uint256[] calldata _outputQuantities,\n        uint256 _maxMassetQuantity,\n        address _recipient\n    ) external returns (uint256 mAssetRedeemed);\n\n    function getRedeemOutput(address _output, uint256 _mAssetQuantity)\n        external\n        view\n        returns (uint256 bAssetOutput);\n\n    function getRedeemExactBassetsOutput(\n        address[] calldata _outputs,\n        uint256[] calldata _outputQuantities\n    ) external view returns (uint256 mAssetAmount);\n\n    // Views\n    function getBasket() external view returns (bool, bool);\n\n    function getBasset(address _token)\n        external\n        view\n        returns (BassetPersonal memory personal, BassetData memory data);\n\n    function getBassets()\n        external\n        view\n        returns (BassetPersonal[] memory personal, BassetData[] memory data);\n\n    function bAssetIndexes(address) external view returns (uint8);\n\n    // SavingsManager\n    function collectInterest() external returns (uint256 swapFeesGained, uint256 newSupply);\n\n    function collectPlatformInterest()\n        external\n        returns (uint256 mintAmount, uint256 newSupply);\n\n    // Admin\n    function setCacheSize(uint256 _cacheSize) external;\n\n    function upgradeForgeValidator(address _newForgeValidator) external;\n\n    function setFees(uint256 _swapFee, uint256 _redemptionFee) external;\n\n    function setTransferFeesFlag(address _bAsset, bool _flag) external;\n\n    function migrateBassets(address[] calldata _bAssets, address _newIntegration) external;\n}\n"
    },
    "contracts/external/mstable/ISavingsContractV2.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.7.0;\n\n/**\n * @title ISavingsContractV2\n */\ninterface ISavingsContractV2 {\n    function redeemCredits(uint256 _amount) external returns (uint256 underlyingReturned); // V2\n    function exchangeRate() external view returns (uint256); // V1 & V2\n}\n"
    },
    "contracts/external/mstable/MassetStructs.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.7.0;\n\ninterface MassetStructs {\n    struct BassetPersonal {\n        // Address of the bAsset\n        address addr;\n        // Address of the bAsset\n        address integrator;\n        // An ERC20 can charge transfer fee, for example USDT, DGX tokens.\n        bool hasTxFee; // takes a byte in storage\n        // Status of the bAsset\n        BassetStatus status;\n    }\n\n    struct BassetData {\n        // 1 Basset * ratio / ratioScale == x Masset (relative value)\n        // If ratio == 10e8 then 1 bAsset = 10 mAssets\n        // A ratio is divised as 10^(18-tokenDecimals) * measurementMultiple(relative value of 1 base unit)\n        uint128 ratio;\n        // Amount of the Basset that is held in Collateral\n        uint128 vaultBalance;\n    }\n\n    // Status of the Basset - has it broken its peg?\n    enum BassetStatus {\n        Default,\n        Normal,\n        BrokenBelowPeg,\n        BrokenAbovePeg,\n        Blacklisted,\n        Liquidating,\n        Liquidated,\n        Failed\n    }\n\n    struct BasketState {\n        bool undergoingRecol;\n        bool failed;\n    }\n\n    struct InvariantConfig {\n        uint256 a;\n        WeightLimits limits;\n    }\n\n    struct WeightLimits {\n        uint128 min;\n        uint128 max;\n    }\n\n    struct AmpData {\n        uint64 initialA;\n        uint64 targetA;\n        uint64 rampStartTime;\n        uint64 rampEndTime;\n    }\n}\n"
    },
    "contracts/liquidators/MStableLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/mstable/IMasset.sol\";\nimport \"../external/mstable/ISavingsContractV2.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title MStableLiquidator\n * @notice Redeems mUSD, imUSD, mBTC, and imBTC for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract MStableLiquidator is IRedemptionStrategy {\n    /**\n     * @dev mStable imUSD ERC20 token contract object.\n     */\n    IMasset constant public MUSD = IMasset(0xe2f2a5C287993345a840Db3B0845fbC70f5935a5);\n\n    /**\n     * @dev mStable mUSD ERC20 token contract object.\n     */\n    ISavingsContractV2 constant public IMUSD = ISavingsContractV2(0x30647a72Dc82d7Fbb1123EA74716aB8A317Eac19);\n\n    /**\n     * @dev mStable mBTC ERC20 token contract object.\n     */\n    IMasset constant public MBTC = IMasset(0x945Facb997494CC2570096c74b5F66A3507330a1);\n\n    /**\n     * @dev mStable imBTC ERC20 token contract object.\n     */\n    ISavingsContractV2 constant public IMBTC = ISavingsContractV2(0x17d8CBB6Bce8cEE970a4027d1198F6700A7a6c24);\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n        // Get output token\n        if (strategyData.length > 0) (outputToken) = abi.decode(strategyData, (IERC20Upgradeable));\n\n        // TODO: Choose asset to redeem dynamically\n        if (address(inputToken) == address(MUSD)) {\n            // Redeem mUSD for USDC\n            if (address(outputToken) == address(0)) outputToken = IERC20Upgradeable(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48); // Output USDC by default\n            outputAmount = MUSD.redeem(address(outputToken), inputAmount, 1, address(this));\n        } else if (address(inputToken) == address(IMUSD)) {\n            // Redeem imUSD for mUSD\n            uint256 mAssetReturned = IMUSD.redeemCredits(inputAmount);\n            require(mAssetReturned > 0, \"Error calling redeem on mStable savings contract: no mUSD returned.\");\n            \n            // Redeem mUSD for USDC\n            if (address(outputToken) == address(0)) outputToken = IERC20Upgradeable(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48); // Output USDC by default\n            outputAmount = MUSD.redeem(address(outputToken), mAssetReturned, 1, address(this));\n        } else if (address(inputToken) == address(MBTC)) {\n            // Redeem mUSD for USDC\n            if (address(outputToken) == address(0)) outputToken = IERC20Upgradeable(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599); // Output WBTC by default\n            outputAmount = MBTC.redeem(address(outputToken), inputAmount, 1, address(this));\n        } else if (address(inputToken) == address(IMBTC)) {\n            // Redeem imUSD for mUSD\n            uint256 mAssetReturned = IMBTC.redeemCredits(inputAmount);\n            require(mAssetReturned > 0, \"Error calling redeem on mStable savings contract: no mUSD returned.\");\n            \n            // Redeem mUSD for USDC\n            if (address(outputToken) == address(0)) outputToken = IERC20Upgradeable(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599); // Output WBTC by default\n            outputAmount = MBTC.redeem(address(outputToken), mAssetReturned, 1, address(this));\n        }\n    }\n}\n"
    },
    "contracts/oracles/mainnet/TokemakPoolTAssetPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/tokemak/ILiquidityPool.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title TokemakPoolTAssetPriceOracle\n * @notice Returns prices for Tokenmak pools (tAssets).\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract TokemakPoolTAssetPriceOracle is IPriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying) external override view returns (uint) {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(ICToken cToken) external override view returns (uint) {\n        address underlying = ICErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return _price(underlying).mul(1e18).div(10 ** uint256(ERC20Upgradeable(underlying).decimals()));\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint) {\n        return BasePriceOracle(msg.sender).price(address(ILiquidityPool(token).underlyer()));\n    }\n}\n"
    },
    "contracts/external/tokemak/ILiquidityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n/// @title Interface for Pool\n/// @notice Allows users to deposit ERC-20 tokens to be deployed to market makers.\n/// @notice Mints 1:1 fToken on deposit, represeting an IOU for the undelrying token that is freely transferable.\n/// @notice Holders of fTokens earn rewards based on duration their tokens were deployed and the demand for that asset.\n/// @notice Holders of fTokens can redeem for underlying asset after issuing requestWithdrawal and waiting for the next cycle.\ninterface ILiquidityPool {\n    /// @return Reference to the underlying ERC-20 contract\n    function underlyer() external view returns (ERC20Upgradeable);\n}\n"
    },
    "contracts/oracles/mainnet/SynthetixPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/synthetix/AddressResolver.sol\";\nimport \"../../external/synthetix/ExchangeRates.sol\";\nimport \"../../external/synthetix/ISynth.sol\";\nimport \"../../external/synthetix/MixinResolver.sol\";\nimport \"../../external/synthetix/Proxy.sol\";\n\n/**\n * @title SynthetixPriceOracle\n * @notice Returns prices for Synths from Synthetix's official `ExchangeRates` contract.\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract SynthetixPriceOracle is IPriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(ICToken cToken) external override view returns (uint) {\n        address underlying = ICErc20(address(cToken)).underlying();\n        uint256 baseUnit = 10 ** uint(ERC20Upgradeable(underlying).decimals());\n        underlying = Proxy(underlying).target(); // For some reason we have to use the logic contract instead of the proxy contract to get `resolver` and `currencyKey`\n        ExchangeRates exchangeRates = ExchangeRates(MixinResolver(underlying).resolver().requireAndGetAddress(\"ExchangeRates\", \"Failed to get Synthetix's ExchangeRates contract address.\"));\n        return exchangeRates.effectiveValue(ISynth(underlying).currencyKey(), baseUnit, \"ETH\").mul(1e18).div(baseUnit);\n    }\n}\n"
    },
    "contracts/external/synthetix/AddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\ninterface AddressResolver {\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\n}\n"
    },
    "contracts/external/synthetix/ExchangeRates.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\ninterface ExchangeRates {\n    function effectiveValue(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external view returns (uint value);\n}\n"
    },
    "contracts/external/synthetix/ISynth.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\ninterface ISynth {\n    function currencyKey() external view returns (bytes32);\n}\n"
    },
    "contracts/external/synthetix/MixinResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"./AddressResolver.sol\";\n\ncontract MixinResolver {\n    AddressResolver public resolver;\n}\n\n"
    },
    "contracts/external/synthetix/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\ncontract Proxy {\n    address public target;\n}\n"
    },
    "contracts/liquidators/SynthetixSynthLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/synthetix/ISynthetix.sol\";\nimport \"../external/synthetix/ISynth.sol\";\nimport \"../external/synthetix/Proxy.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title SynthetixSynthLiquidator\n * @notice Exchanges seized Synthetix Synth token collateral for more common Synthetix Synth tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract SynthetixSynthLiquidator is IRedemptionStrategy {\n    /**\n     * @notice Synthetix SNX token contract.\n     */\n    ISynthetix public constant SYNTHETIX = ISynthetix(0x97767D7D04Fd0dB0A1a2478DCd4BA85290556B48);\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n        // Swap Synth token for other Synth token (and store output as new collateral)\n        (outputToken) = abi.decode(strategyData, (IERC20Upgradeable));\n        address inputSynthLogic = Proxy(address(inputToken)).target(); // For some reason we have to use the logic contract instead of the proxy contract to get `currencyKey`\n        address outputSynthLogic = Proxy(address(outputToken)).target(); // For some reason we have to use the logic contract instead of the proxy contract to get `currencyKey`\n        SYNTHETIX.exchange(ISynth(inputSynthLogic).currencyKey(), inputAmount, ISynth(outputSynthLogic).currencyKey());\n        outputAmount = outputToken.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/external/synthetix/ISynthetix.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\ninterface ISynthetix {\n    function exchange(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external returns (uint amountReceived);\n}\n"
    },
    "contracts/oracles/mainnet/StakedSdtPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/stakedao/Sanctuary.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title StakedSdtPriceOracle\n * @notice Returns prices for Staked SDT (xSDT).\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract StakedSdtPriceOracle is IPriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying) external override view returns (uint) {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(ICToken cToken) external override view returns (uint) {\n        address underlying = ICErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return _price(underlying).mul(1e18).div(10 ** uint256(ERC20Upgradeable(underlying).decimals()));\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint) {\n        Sanctuary sanctuary = Sanctuary(token);\n        IERC20Upgradeable sdt = sanctuary.sdt();\n        uint256 sdtEthPrice = BasePriceOracle(msg.sender).price(address(sdt));\n        return sdt.balanceOf(token).mul(sdtEthPrice).div(sanctuary.totalSupply());\n    }\n}\n"
    },
    "contracts/external/stakedao/Sanctuary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nabstract contract Sanctuary is IERC20Upgradeable {\n    IERC20Upgradeable public sdt;\n\n    // Enter the Sanctuary. Pay some SDTs. Earn some shares.\n    function enter(uint256 _amount) public virtual;\n\n    // Leave the Sanctuary. Claim back your SDTs.\n    function leave(uint256 _share) public virtual;\n}\n"
    },
    "contracts/liquidators/StakedSdtLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/stakedao/Sanctuary.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title StakedSdtLiquidator\n * @notice Redeems Staked SDT (xSDT) for underlying SUSHI for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract StakedSdtLiquidator is IRedemptionStrategy {\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n        // Unstake xSDT (and store output SDT as new collateral)\n        Sanctuary sanctuary = Sanctuary(address(inputToken));\n        sanctuary.leave(inputAmount);\n        outputToken = IERC20Upgradeable(sanctuary.sdt());\n        outputAmount = outputToken.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/oracles/mainnet/HarvestPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/harvest/IFarmVault.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title HarvestPriceOracle\n * @notice Returns prices for iFARM.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract HarvestPriceOracle is IPriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev FARM ERC20 token contract.\n     */\n    address constant public FARM = 0xa0246c9032bC3A600820415aE600c6388619A14D;\n\n    /**\n     * @dev iFARM ERC20 token contract.\n     */\n    IFarmVault constant public IFARM = IFarmVault(0x1571eD0bed4D987fe2b498DdBaE7DFA19519F651);\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying) external override view returns (uint) {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(ICToken cToken) external override view returns (uint) {\n        address underlying = ICErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return _price(underlying).mul(1e18).div(10 ** uint256(ERC20Upgradeable(underlying).decimals()));\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint) {\n        if (token == address(IFARM)) return BasePriceOracle(msg.sender).price(FARM).mul(IFARM.getPricePerFullShare()).div(1e18);\n        else revert(\"Invalid token address passed to HarvestPriceOracle.\");\n    }\n}\n"
    },
    "contracts/external/harvest/IFarmVault.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\ninterface IFarmVault {\n    function underlyingBalanceInVault() external view returns (uint256);\n    function underlyingBalanceWithInvestment() external view returns (uint256);\n\n    // function store() external view returns (address);\n    function governance() external view returns (address);\n    function controller() external view returns (address);\n    function underlying() external view returns (address);\n    function strategy() external view returns (address);\n\n    function setStrategy(address _strategy) external;\n    function setVaultFractionToInvest(uint256 numerator, uint256 denominator) external;\n\n    function deposit(uint256 amountWei) external;\n    function depositFor(uint256 amountWei, address holder) external;\n\n    function withdrawAll() external;\n    function withdraw(uint256 numberOfShares) external;\n    function getPricePerFullShare() external view returns (uint256);\n\n    function underlyingBalanceWithInvestmentForHolder(address holder) view external returns (uint256);\n\n    // hard work should be callable only by the controller (by the hard worker) or by governance\n    function doHardWork() external;\n}\n"
    },
    "contracts/liquidators/HarvestLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/harvest/IFarmVault.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title HarvestLiquidator\n * @notice Exchanges seized iFARM token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract HarvestLiquidator is IRedemptionStrategy {\n    /**\n     * @dev FARM ERC20 token contract.\n     */\n    IERC20Upgradeable constant public FARM = IERC20Upgradeable(0xa0246c9032bC3A600820415aE600c6388619A14D);\n\n    /**\n     * @dev iFARM ERC20 token contract.\n     */\n    IFarmVault constant public IFARM = IFarmVault(0x1571eD0bed4D987fe2b498DdBaE7DFA19519F651);\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n        if (address(inputToken) == address(IFARM)) {\n            IFARM.withdrawAll();\n            outputToken = FARM;\n            outputAmount = outputToken.balanceOf(address(this));\n        } else revert(\"Invalid token address passed to HarvestLiquidator.\");\n    }\n}\n"
    },
    "contracts/oracles/mainnet/GelatoGUniPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/gelato/GUniPool.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title GelatoGUniPriceOracle\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice GelatoGUniPriceOracle is a price oracle for Gelato G-UNI wrapped Uniswap V3 LP tokens.\n * @dev Implements the `PriceOracle` interface used by Fuse pools (and Compound v2).\n */\ncontract GelatoGUniPriceOracle is IPriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev WETH contract address.\n     */\n    address constant private WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /**\n     * @notice Get the LP token price price for an underlying token address.\n     * @param underlying The underlying token address for which to get the price (set to zero address for ETH)\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying) external view returns (uint) {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(ICToken cToken) external override view returns (uint) {\n        address underlying = ICErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return _price(underlying).mul(1e18).div(10 ** uint256(ERC20Upgradeable(underlying).decimals()));\n    }\n\n    /**\n     * @dev Fetches the fair LP token/ETH price from Uniswap, with 18 decimals of precision.\n     */\n    function _price(address token) internal view virtual returns (uint) {\n        // Get G-UNI pool and underlying tokens\n        GUniPool pool = GUniPool(token);\n        address token0 = pool.token0();\n        address token1 = pool.token1();\n\n        // Get underlying token prices\n        uint256 p0 = token0 == WETH_ADDRESS ? 1e18 : BasePriceOracle(msg.sender).price(token0);\n        require(p0 > 0, \"Failed to retrieve price for G-UNI underlying token0.\");\n        uint256 p1 = token1 == WETH_ADDRESS ? 1e18 : BasePriceOracle(msg.sender).price(token1);\n        require(p1 > 0, \"Failed to retrieve price for G-UNI underlying token1.\");\n\n        // Get conversion factors\n        uint256 dec0 = uint256(ERC20Upgradeable(token0).decimals());\n        require(dec0 <= 18, \"G-UNI underlying token0 decimals greater than 18.\");\n        uint256 to18Dec0 = 10 ** (18 - dec0);\n        uint256 dec1 = uint256(ERC20Upgradeable(token1).decimals());\n        require(dec1 <= 18, \"G-UNI underlying token1 decimals greater than 18.\");\n        uint256 to18Dec1 = 10 ** (18 - dec1);\n        \n        // Get square root of underlying token prices\n        // token1/token0 \n        // = (p0 / 10^dec0) / (p1 / 10^dec1) \n        // = (p0 * 10^dec1) / (p1 * 10^dec0)\n        // [From Uniswap's definition] sqrtPriceX96\n        // = sqrt(token1/token0) * 2^96\n        // = sqrt((p0 * 10^dec1) / (p1 * 10^dec0)) * 2^96\n        // = sqrt((p0 * 10^dec1) / (p1 * 10^dec0)) * 2^48 * 2^48\n        // = sqrt((p0 * 10^dec1 * 2^96) / (p1 * 10^dec0)) * 2^48\n        uint160 sqrtPriceX96 = toUint160(sqrt(p0.mul(10 ** dec1).mul(1 << 96).div(p1.mul(10 ** dec0))) << 48);\n\n        // Get balances of the tokens in the pool given fair underlying token prices\n        (uint256 r0, uint256 r1) = pool.getUnderlyingBalancesAtPrice(sqrtPriceX96);\n        require(r0 > 0 || r1 > 0, \"G-UNI underlying token balances not both greater than 0.\");\n\n        // Add the total value of each token together and divide by the totalSupply to get the unit price\n        return p0.mul(r0.mul(to18Dec0)).add(p1.mul(r1.mul(to18Dec1))).div(ERC20Upgradeable(token).totalSupply());\n    }\n\n    /**\n     * @dev Fast square root function.\n     * Implementation from: https://github.com/Uniswap/uniswap-lib/commit/99f3f28770640ba1bb1ff460ac7c5292fb8291a0\n     * Original implementation: https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n     */\n    function sqrt(uint x) internal pure returns (uint) {\n        if (x == 0) return 0;\n        uint xx = x;\n        uint r = 1;\n\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n\n    /**\n     * @dev Converts uint256 to uint160.\n     */\n    function toUint160(uint256 x) internal pure returns (uint160 z) {\n        require((z = uint160(x)) == x, \"Overflow when converting uint256 into uint160.\");\n    }\n}\n"
    },
    "contracts/external/gelato/GUniPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0;\n\ninterface GUniPool {\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n\n    /// @notice compute total underlying holdings of the G-UNI token supply\n    /// includes current liquidity invested in uniswap position, current fees earned\n    /// and any uninvested leftover (but does not include manager or gelato fees accrued)\n    /// @return amount0Current current total underlying balance of token0\n    /// @return amount1Current current total underlying balance of token1\n    function getUnderlyingBalancesAtPrice(uint160 sqrtRatioX96)\n        external\n        view\n        returns (uint256 amount0Current, uint256 amount1Current);\n\n    /// @notice burn G-UNI tokens (fractional shares of a Uniswap V3 position) and receive tokens\n    /// @param burnAmount The number of G-UNI tokens to burn\n    /// @param receiver The account to receive the underlying amounts of token0 and token1\n    /// @return amount0 amount of token0 transferred to receiver for burning `burnAmount`\n    /// @return amount1 amount of token1 transferred to receiver for burning `burnAmount`\n    /// @return liquidityBurned amount of liquidity removed from the underlying Uniswap V3 position\n    // solhint-disable-next-line function-max-lines\n    function burn(uint256 burnAmount, address receiver)\n        external\n        returns (\n            uint256 amount0,\n            uint256 amount1,\n            uint128 liquidityBurned\n        );\n}\n"
    },
    "contracts/liquidators/GelatoGUniLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\nimport \"../external/uniswap/IUniswapV2Router02.sol\";\nimport \"../external/uniswap/IUniswapV2Pair.sol\";\n\nimport \"../external/gelato/GUniPool.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title GelatoGUniLiquidator\n * @notice Exchanges seized GelatoGUni token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract GelatoGUniLiquidator is IRedemptionStrategy {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    /**\n     * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n     */\n    function safeApprove(IERC20Upgradeable token, address to, uint256 minAmount) private {\n        uint256 allowance = token.allowance(address(this), to);\n\n        if (allowance < minAmount) {\n            if (allowance > 0) token.safeApprove(to, 0);\n            token.safeApprove(to, uint256(-1));\n        }\n    }\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n        // Exit GUni pool\n        GUniPool pool = GUniPool(address(inputToken));\n        address token0 = pool.token0();\n        address token1 = pool.token1();\n        (uint amount0, uint amount1, ) = pool.burn(inputAmount, address(this));\n\n        // Swap underlying tokens\n        (IUniswapV2Router02 uniswapV2Router, address[] memory swapToken0Path, address[] memory swapToken1Path) = abi.decode(strategyData, (IUniswapV2Router02, address[], address[]));\n        require((swapToken0Path.length > 0 ? swapToken0Path[swapToken0Path.length - 1] : token0) == (swapToken1Path.length > 0 ? swapToken1Path[swapToken1Path.length - 1] : token1), \"Output of token0 swap path must equal output of token1 swap path.\");\n\n        if (swapToken0Path.length > 0 && swapToken0Path[swapToken0Path.length - 1] != token0) {\n            safeApprove(IERC20Upgradeable(token0), address(uniswapV2Router), amount0);\n            uniswapV2Router.swapExactTokensForTokens(amount0, 0, swapToken0Path, address(this), block.timestamp);\n        }\n\n        if (swapToken1Path.length > 0 && swapToken1Path[swapToken1Path.length - 1] != token1) {\n            safeApprove(IERC20Upgradeable(token1), address(uniswapV2Router), amount1);\n            uniswapV2Router.swapExactTokensForTokens(amount1, 0, swapToken1Path, address(this), block.timestamp);\n        }\n\n        // Get new collateral\n        outputToken = IERC20Upgradeable(swapToken0Path.length > 0 ? swapToken0Path[swapToken0Path.length - 1] : token0);\n        outputAmount = outputToken.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/oracles/mainnet/CurveLpTokenPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/curve/ICurveRegistry.sol\";\nimport \"../../external/curve/ICurvePool.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title CurveLpTokenPriceOracle\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice CurveLpTokenPriceOracle is a price oracle for Curve LP tokens (using the sender as a root oracle).\n * @dev Implements the `PriceOracle` interface used by Fuse pools (and Compound v2).\n */\ncontract CurveLpTokenPriceOracle is IPriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Get the LP token price price for an underlying token address.\n     * @param underlying The underlying token address for which to get the price (set to zero address for ETH).\n     * @return Price denominated in ETH (scaled by 1e18).\n     */\n    function price(address underlying) external override view returns (uint) {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(ICToken cToken) external override view returns (uint) {\n        address underlying = ICErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return _price(underlying).mul(1e18).div(10 ** uint256(ERC20Upgradeable(underlying).decimals()));\n    }\n\n    /**\n     * @dev Fetches the fair LP token/ETH price from Curve, with 18 decimals of precision.\n     * Source: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/CurveOracle.sol\n     * @param lpToken The LP token contract address for price retrieval.\n     */\n    function _price(address lpToken) internal view returns (uint) {\n        address pool = poolOf[lpToken];\n        require(pool != address(0), \"LP token is not registered.\");\n        address[] memory tokens = underlyingTokens[lpToken];\n        uint256 minPx = uint256(-1);\n        uint256 n = tokens.length;\n\n        for (uint256 i = 0; i < n; i++) {\n            address ulToken = tokens[i];\n            uint256 tokenPx = BasePriceOracle(msg.sender).price(ulToken);\n            if (tokenPx < minPx) minPx = tokenPx;\n        }\n\n        require(minPx != uint256(-1), \"No minimum underlying token price found.\");      \n        return minPx.mul(ICurvePool(pool).get_virtual_price()).div(1e18); // Use min underlying token prices\n    }\n\n    /**\n     * @dev The Curve registry.\n     */\n    ICurveRegistry public constant registry = ICurveRegistry(0x7D86446dDb609eD0F5f8684AcF30380a356b2B4c);\n\n    /**\n     * @dev Maps Curve LP token addresses to underlying token addresses.\n     */\n    mapping(address => address[]) public underlyingTokens;\n\n    /**\n     * @dev Maps Curve LP token addresses to pool addresses.\n     */\n    mapping(address => address) public poolOf;\n\n    /**\n     * @dev Register the pool given LP token address and set the pool info.\n     * Source: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/CurveOracle.sol\n     * @param lpToken LP token to find the corresponding pool.\n     */\n    function registerPool(address lpToken) external {\n        address pool = poolOf[lpToken];\n        require(pool == address(0), \"This LP token is already registered.\");\n        pool = registry.get_pool_from_lp_token(lpToken);\n        require(pool != address(0), \"No corresponding pool found for this LP token in the Curve registry.\");\n        poolOf[lpToken] = pool;\n        uint n = registry.get_n_coins(pool);\n        address[8] memory tokens = registry.get_coins(pool);\n        for (uint256 i = 0; i < n; i++) underlyingTokens[lpToken].push(tokens[i]);\n    }\n}\n"
    },
    "contracts/external/curve/ICurveRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\ninterface ICurveRegistry {\n    function get_n_coins(address lp) external view returns (uint);\n    function get_coins(address pool) external view returns (address[8] memory);\n    function get_pool_from_lp_token(address lp) external view returns (address);\n}\n"
    },
    "contracts/external/curve/ICurvePool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\ninterface ICurvePool {\n    function get_virtual_price() external view returns (uint);\n    function remove_liquidity_one_coin(uint256 _token_amount, int128 i, uint256 min_amount) external;\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns (uint256);\n}\n"
    },
    "contracts/liquidators/CurveSwapLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\nimport \"../external/curve/ICurveRegistry.sol\";\nimport \"../external/curve/ICurvePool.sol\";\n\nimport \"../external/aave/IWETH.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title CurveSwapLiquidator\n * @notice Swaps seized token collateral via Curve as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CurveSwapLiquidator is IRedemptionStrategy {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @dev WETH contract object.\n     */\n    IWETH constant private WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    /**\n     * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n     */\n    function safeApprove(IERC20Upgradeable token, address to, uint256 minAmount) private {\n        uint256 allowance = token.allowance(address(this), to);\n\n        if (allowance < minAmount) {\n            if (allowance > 0) token.safeApprove(to, 0);\n            token.safeApprove(to, uint256(-1));\n        }\n    }\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n        // Exchange and store output\n        (ICurvePool curvePool, int128 i, int128 j, address jToken) = abi.decode(strategyData, (ICurvePool, int128, int128, address));\n        outputToken = IERC20Upgradeable(jToken == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE ? address(0) : jToken);\n        safeApprove(inputToken, address(curvePool), inputAmount);\n        outputAmount = curvePool.exchange(i, j, inputAmount, 0);\n\n        // Convert to WETH if ETH because `FuseSafeLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address) \n        if (address(outputToken) == address(0)) {\n            WETH.deposit{value: outputAmount}();\n            return (IERC20Upgradeable(address(WETH)), outputAmount);\n        }\n    }\n}\n"
    },
    "contracts/external/aave/IWETH.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.7.0;\n\ninterface IWETH {\n  function deposit() external payable;\n\n  function withdraw(uint256) external;\n\n  function approve(address guy, uint256 wad) external returns (bool);\n\n  function transfer(address dst, uint256 wad) external returns (bool);\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 wad\n  ) external returns (bool);\n}\n"
    },
    "contracts/liquidators/UniswapV1Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\nimport \"../external/uniswap/IUniswapV1Exchange.sol\";\nimport \"../external/uniswap/IUniswapV1Factory.sol\";\n\nimport \"../external/aave/IWETH.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title UniswapV1Liquidator\n * @notice Exchanges seized token collateral for underlying tokens via a Uniswap V1 pool for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapV1Liquidator is IRedemptionStrategy {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @dev The V1 Uniswap factory contract.\n     */\n    IUniswapV1Factory constant private UNISWAP_V1_FACTORY = IUniswapV1Factory(0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95);\n\n    /**\n     * @dev WETH contract object.\n     */\n    IWETH constant private WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    /**\n     * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n     */\n    function safeApprove(IERC20Upgradeable token, address to, uint256 minAmount) private {\n        uint256 allowance = token.allowance(address(this), to);\n\n        if (allowance < minAmount) {\n            if (allowance > 0) token.safeApprove(to, 0);\n            token.safeApprove(to, uint256(-1));\n        }\n    }\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n        // Get Uniswap exchange\n        IUniswapV1Exchange uniswapV1Exchange = IUniswapV1Exchange(UNISWAP_V1_FACTORY.getExchange(address(inputToken)));\n\n        // Swap underlying tokens\n        safeApprove(inputToken, address(uniswapV1Exchange), inputAmount);\n        uniswapV1Exchange.tokenToEthSwapInput(inputAmount, 1, block.timestamp);\n\n        // Get new collateral\n        outputAmount = address(this).balance;\n        WETH.deposit{value: outputAmount}();\n        return (IERC20Upgradeable(address(WETH)), outputAmount);\n    }\n}\n"
    },
    "contracts/external/uniswap/IUniswapV1Exchange.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.7.0;\n\ninterface IUniswapV1Exchange {\n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256);\n}\n"
    },
    "contracts/external/uniswap/IUniswapV1Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.7.0;\n\ninterface IUniswapV1Factory {\n    function getExchange(address token) external view returns (address);\n}\n"
    },
    "contracts/liquidators/CustomLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/aave/IWETH.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title CustomLiquidator\n * @notice Redeems seized collateral tokens for the specified output token by calling the specified contract for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CustomLiquidator is IRedemptionStrategy {\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev WETH contract object.\n     */\n    IWETH constant private WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n        // Call arbitrary contract\n        address target;\n        bytes memory data;\n        (target, data, outputToken) = abi.decode(strategyData, (address, bytes, IERC20Upgradeable));\n        target.functionCall(data);\n        outputAmount = address(outputToken) == address(0) ? address(this).balance : outputToken.balanceOf(address(this));\n\n        // Convert to WETH if ETH because `FuseSafeLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address) \n        if (address(outputToken) == address(0)) {\n            WETH.deposit{value: outputAmount}();\n            return (IERC20Upgradeable(address(WETH)), outputAmount);\n        }\n    }\n}\n"
    },
    "contracts/utils/InitializableClones.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\n/**\n * @title InitializableClones\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice Deploys minimal proxy contracts (known as \"clones\") and initializes them.\n */\ncontract InitializableClones {\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Event emitted when a clone is deployed.\n     */\n    event Deployed(address instance);\n\n    /**\n     * @dev Deploys, initializes, and returns the address of a clone that mimics the behaviour of `master`.\n     */\n    function clone(address master, bytes memory initializer) external returns (address instance) {\n        instance = ClonesUpgradeable.clone(master);\n        instance.functionCall(initializer, \"Failed to initialize clone.\");\n        emit Deployed(instance);\n    }\n}"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary ClonesUpgradeable {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address master) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `master` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address master, bytes32 salt) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address master, bytes32 salt, address deployer) internal pure returns (address predicted) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address master, bytes32 salt) internal view returns (address predicted) {\n        return predictDeterministicAddress(master, salt, address(this));\n    }\n}\n"
    },
    "contracts/oracles/default/UniswapTwapPriceOracleV2Factory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\n\nimport \"./UniswapTwapPriceOracleV2.sol\";\n\n/**\n * @title UniswapTwapPriceOracleV2Factory\n * @notice Deploys and catalogs UniswapTwapPriceOracleV2 contracts.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapTwapPriceOracleV2Factory {\n    /**\n     * @dev WETH token contract address.\n     */\n    address immutable public wtoken;\n\n    /**\n     * @dev `UniswapTwapPriceOracleV2Root` contract address.\n     */\n    address immutable public rootOracle;\n\n    /**\n     * @dev Implementation address for the `UniswapV3TwapPriceOracleV2`.\n     */\n    address immutable public logic;\n\n    /**\n     * @notice Maps `UniswapV2Factory` contracts to base tokens to `UniswapTwapPriceOracleV2` contract addresses.\n     */\n    mapping(address => mapping(address => UniswapTwapPriceOracleV2)) public oracles;\n\n    /**\n     * @dev Constructor that sets the `UniswapTwapPriceOracleV2Root` and `UniswapTwapPriceOracleV2` implementation contract.\n     */\n    constructor (address _rootOracle, address _logic, address _wtoken) {\n        require(_rootOracle != address(0), \"UniswapTwapPriceOracleV2Root not defined.\");\n        require(_logic != address(0), \"UniswapTwapPriceOracleV2 implementation/logic contract not defined.\");\n        rootOracle = _rootOracle;\n        logic = _logic;\n        wtoken = _wtoken;\n    }\n\n    /**\n     * @notice Deploys a `UniswapTwapPriceOracleV2`.\n     * @param uniswapV2Factory The `UniswapV2Factory` contract of the pairs for which this oracle will be used.\n     * @param baseToken The base token of the pairs for which this oracle will be used.\n     */\n    function deploy(address uniswapV2Factory, address baseToken) external returns (address) {\n        // Input validation\n        if (baseToken == address(0)) baseToken = address(wtoken);\n\n        // Return existing oracle if present\n        address currentOracle = address(oracles[uniswapV2Factory][baseToken]);\n        if (currentOracle != address(0)) return currentOracle;\n\n        // Deploy oracle\n        bytes32 salt = keccak256(abi.encodePacked(uniswapV2Factory, baseToken));\n        address oracle = ClonesUpgradeable.cloneDeterministic(logic, salt);\n        UniswapTwapPriceOracleV2(oracle).initialize(rootOracle, uniswapV2Factory, baseToken, wtoken);\n\n        // Set oracle in state\n        oracles[uniswapV2Factory][baseToken] = UniswapTwapPriceOracleV2(oracle);\n\n        // Return oracle address\n        return oracle;\n    }\n}\n"
    },
    "contracts/oracles/default/UniswapTwapPriceOracleV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../BasePriceOracle.sol\";\nimport \"./UniswapTwapPriceOracleV2Root.sol\";\n\n/**\n * @title UniswapTwapPriceOracleV2\n * @notice Stores cumulative prices and returns TWAPs for assets on Uniswap V2 pairs.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapTwapPriceOracleV2 is Initializable, IPriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev wtoken token contract address.\n     */\n    address public wtoken;\n\n    /**\n     * @dev UniswapTwapPriceOracleV2Root contract address.\n     */\n    UniswapTwapPriceOracleV2Root public rootOracle;\n\n    /**\n     * @dev UniswapV2Factory contract address.\n     */\n    address public uniswapV2Factory;\n\n    /**\n     * @dev The token on which to base TWAPs (its price must be available via `msg.sender`).\n     */\n    address public baseToken;\n\n    /**\n     * @dev Constructor that sets the UniswapTwapPriceOracleV2Root, UniswapV2Factory, and base token.\n     */\n    function initialize(address _rootOracle, address _uniswapV2Factory, address _baseToken, address _wtoken) external initializer {\n        require(_rootOracle != address(0), \"UniswapTwapPriceOracleV2Root not defined.\");\n        require(_uniswapV2Factory != address(0), \"UniswapV2Factory not defined.\");\n        rootOracle = UniswapTwapPriceOracleV2Root(_rootOracle);\n        uniswapV2Factory = _uniswapV2Factory;\n        wtoken = _wtoken;\n        baseToken = _baseToken == address(0) ? address(wtoken) : _baseToken;\n    }\n    \n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(ICToken cToken) external override view returns (uint) {\n        // Return 1e18 for ETH\n        if (cToken.isCEther()) return 1e18;\n\n        // Get underlying ERC20 token address\n        address underlying = ICErc20(address(cToken)).underlying();\n\n        // Get price, format, and return\n        uint256 baseUnit = 10 ** uint256(ERC20Upgradeable(underlying).decimals());\n        return _price(underlying).mul(1e18).div(baseUnit);\n    }\n    \n    /**\n     * @dev Internal function returning the price in ETH of `underlying`.\n     */\n    function _price(address underlying) internal view returns (uint) {\n        // Return 1e18 for wtoken\n        if (underlying == wtoken) return 1e18;\n\n        // Return root oracle ERC20/ETH TWAP\n        uint256 twap = rootOracle.price(underlying, baseToken, uniswapV2Factory);\n        return baseToken == address(wtoken) ? twap : twap.mul(BasePriceOracle(msg.sender).price(baseToken)).div(10 ** uint256(ERC20Upgradeable(baseToken).decimals()));\n    }\n\n    /**\n     * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n     */\n    function price(address underlying) external override view returns (uint) {\n        return _price(underlying);\n    }\n}\n"
    },
    "contracts/oracles/default/UniswapTwapPriceOracleV2Root.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/uniswap/IUniswapV2Pair.sol\";\nimport \"../../external/uniswap/IUniswapV2Factory.sol\";\n\n/**\n * @title UniswapTwapPriceOracleV2Root\n * @notice Stores cumulative prices and returns TWAPs for assets on Uniswap V2 pairs.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapTwapPriceOracleV2Root {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev wtoken token contract address.\n     */\n    address public immutable wtoken;\n\n    /**\n     * @dev Minimum TWAP interval.\n     */\n    uint256 public constant MIN_TWAP_TIME = 15 minutes;\n\n    /**\n    * @dev Constructor to set wtoken address\n     */\n    constructor (address _wtoken) {\n        wtoken = _wtoken;\n    }\n\n    /**\n     * @dev Return the TWAP value price0. Revert if TWAP time range is not within the threshold.\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n     * @param pair The pair to query for price0.\n     */\n    function price0TWAP(address pair) internal view returns (uint) {\n        uint length = observationCount[pair];\n        require(length > 0, 'No length-1 TWAP observation.');\n        Observation memory lastObservation = observations[pair][(length - 1) % OBSERVATION_BUFFER];\n        if (lastObservation.timestamp > block.timestamp - MIN_TWAP_TIME) {\n            require(length > 1, 'No length-2 TWAP observation.');\n            lastObservation = observations[pair][(length - 2) % OBSERVATION_BUFFER];\n        }\n        uint elapsedTime = block.timestamp - lastObservation.timestamp;\n        require(elapsedTime >= MIN_TWAP_TIME, 'Bad TWAP time.');\n        uint currPx0Cumu = currentPx0Cumu(pair);\n        return (currPx0Cumu - lastObservation.price0Cumulative) / (block.timestamp - lastObservation.timestamp); // overflow is desired\n    }\n\n    /**\n     * @dev Return the TWAP value price1. Revert if TWAP time range is not within the threshold.\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n     * @param pair The pair to query for price1.\n     */\n    function price1TWAP(address pair) internal view returns (uint) {\n        uint length = observationCount[pair];\n        require(length > 0, 'No length-1 TWAP observation.');\n        Observation memory lastObservation = observations[pair][(length - 1) % OBSERVATION_BUFFER];\n        if (lastObservation.timestamp > block.timestamp - MIN_TWAP_TIME) {\n            require(length > 1, 'No length-2 TWAP observation.');\n            lastObservation = observations[pair][(length - 2) % OBSERVATION_BUFFER];\n        }\n        uint elapsedTime = block.timestamp - lastObservation.timestamp;\n        require(elapsedTime >= MIN_TWAP_TIME, 'Bad TWAP time.');\n        uint currPx1Cumu = currentPx1Cumu(pair);\n        return (currPx1Cumu - lastObservation.price1Cumulative) / (block.timestamp - lastObservation.timestamp); // overflow is desired\n    }\n\n    /**\n     * @dev Return the current price0 cumulative value on Uniswap.\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n     * @param pair The uniswap pair to query for price0 cumulative value.\n     */\n    function currentPx0Cumu(address pair) internal view returns (uint px0Cumu) {\n        uint32 currTime = uint32(block.timestamp);\n        px0Cumu = IUniswapV2Pair(pair).price0CumulativeLast();\n        (uint reserve0, uint reserve1, uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n        if (lastTime != block.timestamp) {\n            uint32 timeElapsed = currTime - lastTime; // overflow is desired\n            px0Cumu += uint((reserve1 << 112) / reserve0) * timeElapsed; // overflow is desired\n        }\n    }\n\n    /**\n     * @dev Return the current price1 cumulative value on Uniswap.\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n     * @param pair The uniswap pair to query for price1 cumulative value.\n     */\n    function currentPx1Cumu(address pair) internal view returns (uint px1Cumu) {\n        uint32 currTime = uint32(block.timestamp);\n        px1Cumu = IUniswapV2Pair(pair).price1CumulativeLast();\n        (uint reserve0, uint reserve1, uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n        if (lastTime != currTime) {\n            uint32 timeElapsed = currTime - lastTime; // overflow is desired\n            px1Cumu += uint((reserve0 << 112) / reserve1) * timeElapsed; // overflow is desired\n        }\n    }\n    \n    /**\n     * @dev Returns the price of `underlying` in terms of `baseToken` given `factory`.\n     */\n    function price(address underlying, address baseToken, address factory) external view returns (uint) {\n        // Return ERC20/ETH TWAP\n        address pair = IUniswapV2Factory(factory).getPair(underlying, baseToken);\n        uint256 baseUnit = 10 ** uint256(ERC20Upgradeable(underlying).decimals());\n        return (underlying < baseToken ? price0TWAP(pair) : price1TWAP(pair)).div(2 ** 56).mul(baseUnit).div(2 ** 56); // Scaled by 1e18, not 2 ** 112\n    }\n\n    /**\n     * @dev Struct for cumulative price observations.\n     */\n    struct Observation {\n        uint32 timestamp;\n        uint256 price0Cumulative;\n        uint256 price1Cumulative;\n    }\n\n    /**\n     * @dev Length after which observations roll over to index 0.\n     */\n    uint8 public constant OBSERVATION_BUFFER = 4;\n\n    /**\n     * @dev Total observation count for each pair.\n     */\n    mapping(address => uint256) public observationCount;\n\n    /**\n     * @dev Array of cumulative price observations for each pair.\n     */\n    mapping(address => Observation[OBSERVATION_BUFFER]) public observations;\n    \n    /// @notice Get pairs for token combinations.\n    function pairsFor(address[] calldata tokenA, address[] calldata tokenB, address factory) external view returns (address[] memory) {\n        require(tokenA.length > 0 && tokenA.length == tokenB.length, \"Token array lengths must be equal and greater than 0.\");\n        address[] memory pairs = new address[](tokenA.length);\n        for (uint256 i = 0; i < tokenA.length; i++) pairs[i] = IUniswapV2Factory(factory).getPair(tokenA[i], tokenB[i]);\n        return pairs;\n    }\n\n    /// @notice Check which of multiple pairs are workable/updatable.\n    function workable(address[] calldata pairs, address[] calldata baseTokens, uint256[] calldata minPeriods, uint256[] calldata deviationThresholds) external view returns (bool[] memory) {\n        require(pairs.length > 0 && pairs.length == baseTokens.length && pairs.length == minPeriods.length && pairs.length == deviationThresholds.length, \"Array lengths must be equal and greater than 0.\");\n        bool[] memory answers = new bool[](pairs.length);\n        for (uint256 i = 0; i < pairs.length; i++) answers[i] = _workable(pairs[i], baseTokens[i], minPeriods[i], deviationThresholds[i]);\n        return answers;\n    }\n    \n    /// @dev Internal function to check if a pair is workable (updateable AND reserves have changed AND deviation threshold is satisfied).\n    function _workable(address pair, address baseToken, uint256 minPeriod, uint256 deviationThreshold) internal view returns (bool) {\n        // Workable if:\n        // 1) We have no observations\n        // 2) The elapsed time since the last observation is > minPeriod AND reserves have changed AND deviation threshold is satisfied \n        // Note that we loop observationCount[pair] around OBSERVATION_BUFFER so we don't waste gas on new storage slots\n        if (observationCount[pair] <= 0) return true;\n        (, , uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n        return (block.timestamp - observations[pair][(observationCount[pair] - 1) % OBSERVATION_BUFFER].timestamp) > (minPeriod >= MIN_TWAP_TIME ? minPeriod : MIN_TWAP_TIME) &&\n            lastTime != observations[pair][(observationCount[pair] - 1) % OBSERVATION_BUFFER].timestamp &&\n            _deviation(pair, baseToken) >= deviationThreshold;\n    }\n\n    /// @dev Internal function to check if a pair's spot price's deviation from its TWAP price as a ratio scaled by 1e18\n    function _deviation(address pair, address baseToken) internal view returns (uint256) {\n        // Get token base unit\n        address token0 = IUniswapV2Pair(pair).token0();\n        bool useToken0Price = token0 != baseToken;\n        address underlying = useToken0Price ? token0 : IUniswapV2Pair(pair).token1();\n        uint256 baseUnit = 10 ** uint256(ERC20Upgradeable(underlying).decimals());\n\n        // Get TWAP price\n        uint256 twapPrice = (useToken0Price ? price0TWAP(pair) : price1TWAP(pair)).div(2 ** 56).mul(baseUnit).div(2 ** 56); // Scaled by 1e18, not 2 ** 112\n    \n        // Get spot price\n        (uint reserve0, uint reserve1, ) = IUniswapV2Pair(pair).getReserves();\n        uint256 spotPrice = useToken0Price ? reserve1.mul(baseUnit).div(reserve0) : reserve0.mul(baseUnit).div(reserve1);\n\n        // Get ratio and return deviation\n        uint256 ratio = spotPrice.mul(1e18).div(twapPrice);\n        return ratio >= 1e18 ? ratio - 1e18 : 1e18 - ratio;\n    }\n    \n    /// @dev Internal function to check if a pair is updatable at all.\n    function _updateable(address pair) internal view returns (bool) {\n        // Updateable if:\n        // 1) We have no observations\n        // 2) The elapsed time since the last observation is > MIN_TWAP_TIME\n        // Note that we loop observationCount[pair] around OBSERVATION_BUFFER so we don't waste gas on new storage slots\n        return observationCount[pair] <= 0 || (block.timestamp - observations[pair][(observationCount[pair] - 1) % OBSERVATION_BUFFER].timestamp) > MIN_TWAP_TIME;\n    }\n\n    /// @notice Update one pair.\n    function update(address pair) external {\n        require(_update(pair), \"Failed to update pair.\");\n    }\n\n    /// @notice Update multiple pairs at once.\n    function update(address[] calldata pairs) external {\n        bool worked = false;\n        for (uint256 i = 0; i < pairs.length; i++) if (_update(pairs[i])) worked = true;\n        require(worked, \"No pairs can be updated (yet).\");\n    }\n\n    /// @dev Internal function to update a single pair.\n    function _update(address pair) internal returns (bool) {\n        // Check if workable\n        if (!_updateable(pair)) return false;\n\n        // Get cumulative price(s)\n        uint256 price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n        uint256 price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n        \n        // Loop observationCount[pair] around OBSERVATION_BUFFER so we don't waste gas on new storage slots\n        (, , uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n        observations[pair][observationCount[pair] % OBSERVATION_BUFFER] = Observation(lastTime, price0Cumulative, price1Cumulative);\n        observationCount[pair]++;\n        return true;\n    }\n}\n"
    },
    "contracts/FuseSafeLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\nimport \"./liquidators/IRedemptionStrategy.sol\";\n\nimport \"./external/compound/ICToken.sol\";\nimport \"./external/compound/ICErc20.sol\";\nimport \"./external/compound/ICEther.sol\";\n\nimport \"./external/aave/IWETH.sol\";\n\nimport \"./external/uniswap/IUniswapV2Router02.sol\";\nimport \"./external/uniswap/IUniswapV2Callee.sol\";\nimport \"./external/uniswap/IUniswapV2Pair.sol\";\nimport \"./external/uniswap/IUniswapV2Factory.sol\";\nimport \"./external/uniswap/UniswapV2Library.sol\";\n\n/**\n * @title FuseSafeLiquidator\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice FuseSafeLiquidator safely liquidates unhealthy borrowers (with flashloan support).\n * @dev Do not transfer ETH or tokens directly to this address. Only send ETH here when using a method, and only approve tokens for transfer to here when using a method. Direct ETH transfers will be rejected and direct token transfers will be lost.\n */\ncontract FuseSafeLiquidator is Initializable, IUniswapV2Callee {\n    using SafeMathUpgradeable for uint256;\n    using AddressUpgradeable for address payable;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n     */\n    function safeApprove(IERC20Upgradeable token, address to, uint256 minAmount) private {\n        uint256 allowance = token.allowance(address(this), to);\n\n        if (allowance < minAmount) {\n            if (allowance > 0) token.safeApprove(to, 0);\n            token.safeApprove(to, uint256(-1));\n        }\n    }\n\n    /**\n     * @dev Internal function to exchange the entire balance of `from` to at least `minOutputAmount` of `to`.\n     * @param from The input ERC20 token address (or the zero address if ETH) to exchange from.\n     * @param to The output ERC20 token address (or the zero address if ETH) to exchange to.\n     * @param minOutputAmount The minimum output amount of `to` necessary to complete the exchange without reversion.\n     * @param uniswapV2Router The UniswapV2Router02 to use.\n     */\n    function exchangeAllEthOrTokens(address from, address to, uint256 minOutputAmount, IUniswapV2Router02 uniswapV2Router) private {\n        if (to == from) return;\n\n        // From ETH, WETH, or something else?\n        if (from == address(0)) {\n            if (to == WETH_ADDRESS) {\n                // Deposit all ETH to WETH\n                WETH.deposit{value: address(this).balance}();\n            } else {\n                // Exchange from ETH to tokens\n                uniswapV2Router.swapExactETHForTokens{value: address(this).balance}(minOutputAmount, array(WETH_ADDRESS, to), address(this), block.timestamp);\n            }\n        } else if (from == WETH_ADDRESS && to == address(0)) {\n            // Withdraw all WETH to ETH\n            WETH.withdraw(IERC20Upgradeable(WETH_ADDRESS).balanceOf(address(this)));\n        } else {\n            // Approve input tokens\n            IERC20Upgradeable fromToken = IERC20Upgradeable(from);\n            uint256 inputBalance = fromToken.balanceOf(address(this));\n            safeApprove(fromToken, address(uniswapV2Router), inputBalance);\n\n            // Exchange from tokens to ETH or tokens\n            if (to == address(0)) uniswapV2Router.swapExactTokensForETH(inputBalance, minOutputAmount, array(from, WETH_ADDRESS), address(this), block.timestamp);\n            else uniswapV2Router.swapExactTokensForTokens(inputBalance, minOutputAmount, from == WETH_ADDRESS || to == WETH_ADDRESS ? array(from, to) : array(from, WETH_ADDRESS, to), address(this), block.timestamp); // Put WETH in the middle of the path if not already a part of the path\n        }\n    }\n\n    /**\n     * @dev Internal function to exchange the entire balance of `from` to at least `minOutputAmount` of `to`.\n     * @param from The input ERC20 token address (or the zero address if ETH) to exchange from.\n     * @param outputAmount The output amount of ETH.\n     * @param uniswapV2Router The UniswapV2Router02 to use.\n     */\n    function exchangeToExactEth(address from, uint256 outputAmount, IUniswapV2Router02 uniswapV2Router) private {\n        if (from == address(0)) return;\n\n        // From WETH something else?\n        if (from == WETH_ADDRESS) {\n            // Withdraw WETH to ETH\n            WETH.withdraw(outputAmount);\n        } else {\n            // Approve input tokens\n            IERC20Upgradeable fromToken = IERC20Upgradeable(from);\n            uint256 inputBalance = fromToken.balanceOf(address(this));\n            safeApprove(fromToken, address(uniswapV2Router), inputBalance);\n\n            // Exchange from tokens to ETH\n            uniswapV2Router.swapTokensForExactETH(outputAmount, inputBalance, array(from, WETH_ADDRESS), address(this), block.timestamp);\n        }\n    }\n\n    /**\n     * @notice Safely liquidate an unhealthy loan (using capital from the sender), confirming that at least `minOutputAmount` in collateral is seized (or outputted by exchange if applicable). \n     * @param borrower The borrower's Ethereum address.\n     * @param repayAmount The amount to repay to liquidate the unhealthy loan.\n     * @param cErc20 The borrowed cErc20 to repay.\n     * @param cTokenCollateral The cToken collateral to be liquidated.\n     * @param minOutputAmount The minimum amount of collateral to seize (or the minimum exchange output if applicable) required for execution. Reverts if this condition is not met.\n     * @param exchangeSeizedTo If set to an address other than `cTokenCollateral`, exchange seized collateral to this ERC20 token contract address (or the zero address for ETH).\n     * @param uniswapV2Router The UniswapV2Router to use to convert the seized underlying collateral.\n     * @param redemptionStrategies The IRedemptionStrategy contracts to use, if any, to redeem \"special\" collateral tokens (before swapping the output for borrowed tokens to be repaid via Uniswap).\n     * @param strategyData The data for the chosen IRedemptionStrategy contracts, if any.\n     */\n    function safeLiquidate(address borrower, uint256 repayAmount, ICErc20 cErc20, ICToken cTokenCollateral, uint256 minOutputAmount, address exchangeSeizedTo, IUniswapV2Router02 uniswapV2Router, IRedemptionStrategy[] memory redemptionStrategies, bytes[] memory strategyData) external returns (uint256) {\n        // Transfer tokens in, approve to cErc20, and liquidate borrow\n        require(repayAmount > 0, \"Repay amount (transaction value) must be greater than 0.\");\n        IERC20Upgradeable underlying = IERC20Upgradeable(cErc20.underlying());\n        underlying.safeTransferFrom(msg.sender, address(this), repayAmount);\n        safeApprove(underlying, address(cErc20), repayAmount);\n        require(cErc20.liquidateBorrow(borrower, repayAmount, cTokenCollateral) == 0, \"Liquidation failed.\");\n\n        // Redeem seized cToken collateral if necessary\n        if (exchangeSeizedTo != address(cTokenCollateral)) {\n            uint256 seizedCTokenAmount = cTokenCollateral.balanceOf(address(this));\n\n            if (seizedCTokenAmount > 0) {\n                uint256 redeemResult = cTokenCollateral.redeem(seizedCTokenAmount);\n                require(redeemResult == 0, \"Error calling redeeming seized cToken: error code not equal to 0\");\n\n                // If cTokenCollateral is CEther\n                if (cTokenCollateral.isCEther()) {\n                    // Exchange redeemed ETH collateral if necessary\n                    exchangeAllEthOrTokens(address(0), exchangeSeizedTo, minOutputAmount, uniswapV2Router);\n                } else {\n                    // Redeem custom collateral if liquidation strategy is set\n                    IERC20Upgradeable underlyingCollateral = IERC20Upgradeable(ICErc20(address(cTokenCollateral)).underlying());\n\n                    if (redemptionStrategies.length > 0) {\n                        require(redemptionStrategies.length == strategyData.length, \"IRedemptionStrategy contract array and strategy data bytes array mnust the the same length.\");\n                        uint256 underlyingCollateralSeized = underlyingCollateral.balanceOf(address(this));\n                        for (uint256 i = 0; i < redemptionStrategies.length; i++) (underlyingCollateral, underlyingCollateralSeized) = redeemCustomCollateral(underlyingCollateral, underlyingCollateralSeized, redemptionStrategies[i], strategyData[i]);\n                    }\n\n                    // Exchange redeemed token collateral if necessary\n                    exchangeAllEthOrTokens(address(underlyingCollateral), exchangeSeizedTo, minOutputAmount, uniswapV2Router);\n                }\n            }\n        }\n\n        // Transfer seized amount to sender\n        return transferSeizedFunds(exchangeSeizedTo, minOutputAmount);\n    }\n\n    /**\n     * @notice Safely liquidate an unhealthy loan (using capital from the sender), confirming that at least `minOutputAmount` in collateral is seized (or outputted by exchange if applicable). \n     * @param borrower The borrower's Ethereum address.\n     * @param cEther The borrowed cEther contract to repay.\n     * @param cErc20Collateral The cErc20 collateral contract to be liquidated.\n     * @param minOutputAmount The minimum amount of collateral to seize (or the minimum exchange output if applicable) required for execution. Reverts if this condition is not met.\n     * @param exchangeSeizedTo If set to an address other than `cTokenCollateral`, exchange seized collateral to this ERC20 token contract address (or the zero address for ETH).\n     * @param uniswapV2Router The UniswapV2Router to use to convert the seized underlying collateral.\n     * @param redemptionStrategies The IRedemptionStrategy contracts to use, if any, to redeem \"special\" collateral tokens (before swapping the output for borrowed tokens to be repaid via Uniswap).\n     * @param strategyData The data for the chosen IRedemptionStrategy contracts, if any.\n     */\n    function safeLiquidate(address borrower, ICEther cEther, ICErc20 cErc20Collateral, uint256 minOutputAmount, address exchangeSeizedTo, IUniswapV2Router02 uniswapV2Router, IRedemptionStrategy[] memory redemptionStrategies, bytes[] memory strategyData) external payable returns (uint256) {\n        // Liquidate ETH borrow\n        require(msg.value > 0, \"Repay amount (transaction value) must be greater than 0.\");\n        cEther.liquidateBorrow{value: msg.value}(borrower, ICToken(cErc20Collateral));\n\n        // Redeem seized cToken collateral if necessary\n        if (exchangeSeizedTo != address(cErc20Collateral)) {\n            uint256 seizedCTokenAmount = cErc20Collateral.balanceOf(address(this));\n\n            if (seizedCTokenAmount > 0) {\n                uint256 redeemResult = cErc20Collateral.redeem(seizedCTokenAmount);\n                require(redeemResult == 0, \"Error calling redeeming seized cToken: error code not equal to 0\");\n\n                // Redeem custom collateral if liquidation strategy is set\n                IERC20Upgradeable underlyingCollateral = IERC20Upgradeable(cErc20Collateral.underlying());\n\n                if (redemptionStrategies.length > 0) {\n                    require(redemptionStrategies.length == strategyData.length, \"IRedemptionStrategy contract array and strategy data bytes array mnust the the same length.\");\n                    uint256 underlyingCollateralSeized = underlyingCollateral.balanceOf(address(this));\n                    for (uint256 i = 0; i < redemptionStrategies.length; i++) (underlyingCollateral, underlyingCollateralSeized) = this.redeemCustomCollateral(underlyingCollateral, underlyingCollateralSeized, redemptionStrategies[i], strategyData[i]); // redeemCustomCollateral called externally because this safeLiquidate function is payable (for some reason delegatecall fails when called with msg.value > 0)\n                }\n\n                // Exchange redeemed collateral if necessary\n                exchangeAllEthOrTokens(address(underlyingCollateral), exchangeSeizedTo, minOutputAmount, uniswapV2Router);\n            }\n        }\n\n        // Transfer seized amount to sender\n        return transferSeizedFunds(exchangeSeizedTo, minOutputAmount);\n    }\n\n    /**\n     * @dev Transfers seized funds to the sender.\n     * @param erc20Contract The address of the token to transfer.\n     * @param minOutputAmount The minimum amount to transfer.\n     */\n    function transferSeizedFunds(address erc20Contract, uint256 minOutputAmount) internal returns (uint256) {\n        uint256 seizedOutputAmount;\n\n        if (erc20Contract == address(0)) {\n            seizedOutputAmount = address(this).balance;\n            require(seizedOutputAmount >= minOutputAmount, \"Minimum ETH output amount not satisfied.\");\n\n            if (seizedOutputAmount > 0) {\n                (bool success, ) = msg.sender.call{value: seizedOutputAmount}(\"\");\n                require(success, \"Failed to transfer output ETH to msg.sender.\");\n            }\n        } else {\n            IERC20Upgradeable token = IERC20Upgradeable(erc20Contract);\n            seizedOutputAmount = token.balanceOf(address(this));\n            require(seizedOutputAmount >= minOutputAmount, \"Minimum token output amount not satified.\");\n            if (seizedOutputAmount > 0) token.safeTransfer(msg.sender, seizedOutputAmount);\n        }\n\n        return seizedOutputAmount;\n    }\n\n    /**\n     * @dev WETH contract address.\n     */\n    address constant private WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /**\n     * @dev WETH contract object.\n     */\n    IWETH constant private WETH = IWETH(WETH_ADDRESS);\n\n    /**\n     * @dev UniswapV2Router02 contract address.\n     */\n    address constant private UNISWAP_V2_ROUTER_02_ADDRESS = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n\n    /**\n     * @dev UniswapV2Router02 contract object.\n     */\n    IUniswapV2Router02 constant private UNISWAP_V2_ROUTER_02 = IUniswapV2Router02(UNISWAP_V2_ROUTER_02_ADDRESS);\n\n    /**\n     * @dev Cached liquidator profit exchange source.\n     * ERC20 token address or the zero address for ETH.\n     * For use in `safeLiquidateToTokensWithFlashLoan`/`safeLiquidateToEthWithFlashLoan` after it is set by `postFlashLoanTokens`/`postFlashLoanWeth`.\n     */\n    address private _liquidatorProfitExchangeSource;\n\n    /**\n     * @notice Safely liquidate an unhealthy loan, confirming that at least `minProfitAmount` in ETH profit is seized. \n     * @param borrower The borrower's Ethereum address.\n     * @param repayAmount The amount to repay to liquidate the unhealthy loan.\n     * @param cErc20 The borrowed CErc20 contract to repay.\n     * @param cTokenCollateral The cToken collateral contract to be liquidated.\n     * @param minProfitAmount The minimum amount of profit required for execution (in terms of `exchangeProfitTo`). Reverts if this condition is not met.\n     * @param exchangeProfitTo If set to an address other than `cTokenCollateral`, exchange seized collateral to this ERC20 token contract address (or the zero address for ETH).\n     * @param uniswapV2RouterForBorrow The UniswapV2Router to use to convert the ETH to the underlying borrow (and flashloan the underlying borrow for ETH).\n     * @param uniswapV2RouterForCollateral The UniswapV2Router to use to convert the underlying collateral to ETH.\n     * @param redemptionStrategies The IRedemptionStrategy contracts to use, if any, to redeem \"special\" collateral tokens (before swapping the output for borrowed tokens to be repaid via Uniswap).\n     * @param strategyData The data for the chosen IRedemptionStrategy contracts, if any.\n     */\n    function safeLiquidateToTokensWithFlashLoan(address borrower, uint256 repayAmount, ICErc20 cErc20, ICToken cTokenCollateral, uint256 minProfitAmount, address exchangeProfitTo, IUniswapV2Router02 uniswapV2RouterForBorrow, IUniswapV2Router02 uniswapV2RouterForCollateral, IRedemptionStrategy[] memory redemptionStrategies, bytes[] memory strategyData, uint256 ethToCoinbase) external returns (uint256) {\n        // Input validation\n        require(repayAmount > 0, \"Repay amount must be greater than 0.\");\n\n        // Flashloan via Uniswap (scoping `underlyingBorrow` variable to avoid \"stack too deep\" compiler error)\n        IUniswapV2Pair pair;\n        bool token0IsUnderlyingBorrow;\n        {\n            address underlyingBorrow = cErc20.underlying();\n            pair = IUniswapV2Pair(IUniswapV2Factory(uniswapV2RouterForBorrow.factory()).getPair(underlyingBorrow, WETH_ADDRESS));\n            token0IsUnderlyingBorrow = pair.token0() == underlyingBorrow;\n        }\n        pair.swap(token0IsUnderlyingBorrow ? repayAmount : 0, !token0IsUnderlyingBorrow ? repayAmount : 0, address(this), msg.data);\n\n        // Exchange profit, send ETH to coinbase if necessary, and transfer seized funds\n        return distributeProfit(exchangeProfitTo, minProfitAmount, ethToCoinbase);\n    }\n\n    /**\n     * @notice Safely liquidate an unhealthy loan, confirming that at least `minProfitAmount` in ETH profit is seized. \n     * @param borrower The borrower's Ethereum address.\n     * @param repayAmount The ETH amount to repay to liquidate the unhealthy loan.\n     * @param cEther The borrowed CEther contract to repay.\n     * @param cErc20Collateral The CErc20 collateral contract to be liquidated.\n     * @param minProfitAmount The minimum amount of profit required for execution (in terms of `exchangeProfitTo`). Reverts if this condition is not met.\n     * @param exchangeProfitTo If set to an address other than `cErc20Collateral`, exchange seized collateral to this ERC20 token contract address (or the zero address for ETH).\n     * @param uniswapV2RouterForCollateral The UniswapV2Router to use to convert the underlying collateral to ETH.\n     * @param redemptionStrategies The IRedemptionStrategy contracts to use, if any, to redeem \"special\" collateral tokens (before swapping the output for borrowed tokens to be repaid via Uniswap).\n     * @param strategyData The data for the chosen IRedemptionStrategy contracts, if any.\n     */\n    function safeLiquidateToEthWithFlashLoan(address borrower, uint256 repayAmount, ICEther cEther, ICErc20 cErc20Collateral, uint256 minProfitAmount, address exchangeProfitTo, IUniswapV2Router02 uniswapV2RouterForCollateral, IRedemptionStrategy[] memory redemptionStrategies, bytes[] memory strategyData, uint256 ethToCoinbase) external returns (uint256) {\n        // Input validation\n        require(repayAmount > 0, \"Repay amount must be greater than 0.\");\n\n        // Flashloan via Uniswap\n        IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(UNISWAP_V2_ROUTER_02.factory(), address(uniswapV2RouterForCollateral) == UNISWAP_V2_ROUTER_02_ADDRESS && cErc20Collateral.underlying() == 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 ? 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599 : 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48, WETH_ADDRESS)); // Use USDC unless collateral is USDC, in which case we use WBTC to avoid a reentrancy error when exchanging the collateral to repay the borrow\n        address token0 = pair.token0();\n        pair.swap(token0 == WETH_ADDRESS ? repayAmount : 0, token0 != WETH_ADDRESS ? repayAmount : 0, address(this), msg.data);\n\n        // Exchange profit, send ETH to coinbase if necessary, and transfer seized funds\n        return distributeProfit(exchangeProfitTo, minProfitAmount, ethToCoinbase);\n    }\n\n    /**\n     * Exchange profit, send ETH to coinbase if necessary, and transfer seized funds to sender.\n     */\n    function distributeProfit(address exchangeProfitTo, uint256 minProfitAmount, uint256 ethToCoinbase) private returns (uint256) {\n        if (exchangeProfitTo == address(0)) {\n            // Exchange profit if necessary\n            exchangeAllEthOrTokens(_liquidatorProfitExchangeSource, exchangeProfitTo, minProfitAmount.add(ethToCoinbase), UNISWAP_V2_ROUTER_02);\n\n            // Transfer ETH to block.coinbase if requested\n            if (ethToCoinbase > 0) block.coinbase.call{value: ethToCoinbase}(\"\");\n\n            // Transfer profit to msg.sender\n            return transferSeizedFunds(exchangeProfitTo, minProfitAmount);\n        } else {\n            // Transfer ETH to block.coinbase if requested\n            if (ethToCoinbase > 0) {\n                exchangeToExactEth(_liquidatorProfitExchangeSource, ethToCoinbase, UNISWAP_V2_ROUTER_02);\n                block.coinbase.call{value: ethToCoinbase}(\"\");\n            }\n\n            // Exchange profit if necessary\n            exchangeAllEthOrTokens(_liquidatorProfitExchangeSource, exchangeProfitTo, minProfitAmount.add(ethToCoinbase), UNISWAP_V2_ROUTER_02);\n\n            // Transfer profit to msg.sender\n            return transferSeizedFunds(exchangeProfitTo, minProfitAmount);\n        }\n    }\n\n    /**\n     * @dev Receives ETH from liquidations and flashloans.\n     * Requires that `msg.sender` is WETH, a CToken, or a Uniswap V2 Router, or another contract.\n     */\n    receive() external payable {\n        require(msg.sender.isContract(), \"Sender is not a contract.\");\n    }\n\n    /**\n     * @dev Callback function for Uniswap flashloans.\n     */\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external override {\n        (address cToken) = abi.decode(data[68:100], (address));\n\n        // Liquidate unhealthy borrow, exchange seized collateral, return flashloaned funds, and exchange profit\n        if (ICToken(cToken).isCEther()) {\n            // Decode params\n            (address borrower, uint256 repayAmount, , address cTokenCollateral, uint256 minProfitAmount, address exchangeProfitTo, IUniswapV2Router02 uniswapV2Router, address[] memory redemptionStrategies, bytes[] memory strategyData) = abi.decode(data[4:], (address, uint256, address, address, uint256, address, IUniswapV2Router02, address[], bytes[]));\n\n            // Calculate flashloan return amount\n            uint256 flashLoanReturnAmount = repayAmount.mul(1000).div(997);\n            if (repayAmount.mul(1000).mod(997) > 0) flashLoanReturnAmount++; // Round up if division resulted in a remainder\n\n            // Post WETH flashloan\n            // Cache liquidation profit token (or the zero address for ETH) for use as source for exchange later\n            _liquidatorProfitExchangeSource = postFlashLoanWeth(borrower, repayAmount, ICEther(cToken), ICErc20(cTokenCollateral), minProfitAmount, exchangeProfitTo, flashLoanReturnAmount, uniswapV2Router, redemptionStrategies, strategyData);\n        }\n        else {\n            // Decode params\n            (address borrower, uint256 repayAmount, , address cTokenCollateral, uint256 minProfitAmount, address exchangeProfitTo, IUniswapV2Router02 uniswapV2RouterForBorrow, IUniswapV2Router02 uniswapV2RouterForCollateral, address[] memory redemptionStrategies, bytes[] memory strategyData) = abi.decode(data[4:], (address, uint256, address, address, uint256, address, IUniswapV2Router02, IUniswapV2Router02, address[], bytes[]));\n\n            // Calculate flashloan return amount\n            uint256 flashLoanReturnAmount = repayAmount.mul(1000).div(997);\n            if (repayAmount.mul(1000).mod(997) > 0) flashLoanReturnAmount++; // Round up if division resulted in a remainder\n\n            // Post token flashloan\n            // Cache liquidation profit token (or the zero address for ETH) for use as source for exchange later\n            _liquidatorProfitExchangeSource = postFlashLoanTokens(borrower, repayAmount, ICErc20(cToken), ICToken(cTokenCollateral), minProfitAmount, exchangeProfitTo, flashLoanReturnAmount, uniswapV2RouterForBorrow, uniswapV2RouterForCollateral, redemptionStrategies, strategyData);\n        }\n    }\n\n    /**\n     * @dev Fetches and sorts the reserves for a pair.\n     * Original code from UniswapV2Library.\n     */\n    function getReserves(address factory, address tokenA, address tokenB) private view returns (uint reserveA, uint reserveB) {\n        (address token0, ) = UniswapV2Library.sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(IUniswapV2Factory(factory).getPair(tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    /**\n     * @dev Performs chained getAmountIn calculations on any number of pairs.\n     * Original code from UniswapV2Library.\n     */\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) private view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint i = path.length - 1; i > 0; i--) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = UniswapV2Library.getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    /**\n     * @dev Liquidate unhealthy ETH borrow, exchange seized collateral, return flashloaned funds, and exchange profit.\n     */\n    function postFlashLoanWeth(address borrower, uint256 repayAmount, ICEther cEther, ICErc20 cErc20Collateral, uint256 minProfitAmount, address exchangeProfitTo, uint256 flashLoanReturnAmount, IUniswapV2Router02 uniswapV2Router, address[] memory redemptionStrategies, bytes[] memory strategyData) private returns (address) {\n        // Unwrap WETH\n        WETH.withdraw(repayAmount);\n\n        // Liquidate ETH borrow using flashloaned ETH\n        cEther.liquidateBorrow{value: repayAmount}(borrower, ICToken(cErc20Collateral));\n\n        // Redeem seized cTokens for underlying asset\n        uint256 seizedCTokenAmount = cErc20Collateral.balanceOf(address(this));\n        require(seizedCTokenAmount > 0, \"No cTokens seized.\");\n        uint256 redeemResult = cErc20Collateral.redeem(seizedCTokenAmount);\n        require(redeemResult == 0, \"Error calling redeeming seized cToken: error code not equal to 0\");\n\n        // Repay flashloan\n        return repayWethFlashLoan(repayAmount, cErc20Collateral, exchangeProfitTo, flashLoanReturnAmount, uniswapV2Router, redemptionStrategies, strategyData);\n    }\n\n    /**\n     * @dev Repays WETH flashloans.\n     */\n    function repayWethFlashLoan(uint256 repayAmount, ICErc20 cErc20Collateral, address exchangeProfitTo, uint256 flashLoanReturnAmount, IUniswapV2Router02 uniswapV2Router, address[] memory redemptionStrategies, bytes[] memory strategyData) private returns (address) {\n        // Check underlying collateral seized\n        IERC20Upgradeable underlyingCollateral = IERC20Upgradeable(cErc20Collateral.underlying());\n        uint256 underlyingCollateralSeized = underlyingCollateral.balanceOf(address(this));\n\n        // Redeem custom collateral if liquidation strategy is set\n        if (redemptionStrategies.length > 0) {\n            require(redemptionStrategies.length == strategyData.length, \"IRedemptionStrategy contract array and strategy data bytes array mnust the the same length.\");\n            for (uint256 i = 0; i < redemptionStrategies.length; i++) (underlyingCollateral, underlyingCollateralSeized) = redeemCustomCollateral(underlyingCollateral, underlyingCollateralSeized, IRedemptionStrategy(redemptionStrategies[i]), strategyData[i]);\n        }\n\n        // Check side of the flashloan to repay: if input token (underlying collateral) is part of flashloan, repay it (to avoid reentracy error); otherwise, convert to WETH and repay WETH\n        if (address(uniswapV2Router) == UNISWAP_V2_ROUTER_02_ADDRESS && address(underlyingCollateral) == (cErc20Collateral.underlying() == 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 ? 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599 : 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48)) {\n            // Get tokens required to repay flashloan and repay flashloan in non-WETH tokens\n            uint256 tokensRequired = getAmountsIn(uniswapV2Router.factory(), repayAmount, array(address(underlyingCollateral), WETH_ADDRESS))[0];\n            require(tokensRequired <= underlyingCollateralSeized, \"Flashloan return amount greater than seized collateral.\");\n            require(underlyingCollateral.transfer(msg.sender, tokensRequired), \"Failed to transfer non-WETH tokens back to flashlender.\");\n        } else {\n            // If underlying collateral is not already WETH, convert it to WETH\n            if (address(underlyingCollateral) != WETH_ADDRESS) {\n                // If underlying collateral is ETH, deposit to WETH; if token, exchange to WETH\n                if (address(underlyingCollateral) == address(0)) {\n                    // Deposit ETH to WETH to repay flashloan\n                    WETH.deposit{value: flashLoanReturnAmount}();\n                } else {\n                    // Approve to Uniswap router\n                    safeApprove(underlyingCollateral, address(uniswapV2Router), underlyingCollateralSeized);\n\n                    // Swap collateral tokens for WETH via Uniswap router\n                    if (exchangeProfitTo == address(underlyingCollateral)) uniswapV2Router.swapTokensForExactTokens(flashLoanReturnAmount, underlyingCollateralSeized, array(address(underlyingCollateral), WETH_ADDRESS), address(this), block.timestamp);\n                    else {\n                        uniswapV2Router.swapExactTokensForTokens(underlyingCollateralSeized, flashLoanReturnAmount, array(address(underlyingCollateral), WETH_ADDRESS), address(this), block.timestamp);\n                        underlyingCollateral = IERC20Upgradeable(WETH_ADDRESS);\n                    }\n                }\n            }\n\n            // Repay flashloan in WETH\n            require(flashLoanReturnAmount <= IERC20Upgradeable(WETH_ADDRESS).balanceOf(address(this)), \"Flashloan return amount greater than WETH exchanged from seized collateral.\");\n            require(WETH.transfer(msg.sender, flashLoanReturnAmount), \"Failed to transfer WETH back to flashlender.\");\n        }\n\n        // Return the profited token\n        return address(underlyingCollateral);\n    }\n\n    /**\n     * @dev Liquidate unhealthy token borrow, exchange seized collateral, return flashloaned funds, and exchange profit.\n     */\n    function postFlashLoanTokens(address borrower, uint256 repayAmount, ICErc20 cErc20, ICToken cTokenCollateral, uint256 minProfitAmount, address exchangeProfitTo, uint256 flashLoanReturnAmount, IUniswapV2Router02 uniswapV2RouterForBorrow, IUniswapV2Router02 uniswapV2RouterForCollateral, address[] memory redemptionStrategies, bytes[] memory strategyData) private returns (address) {\n        // Approve repayAmount to cErc20\n        IERC20Upgradeable underlyingBorrow = IERC20Upgradeable(cErc20.underlying());\n        safeApprove(underlyingBorrow, address(cErc20), repayAmount);\n\n        // Liquidate ETH borrow using flashloaned ETH\n        require(cErc20.liquidateBorrow(borrower, repayAmount, cTokenCollateral) == 0, \"Liquidation failed.\");\n\n        // Redeem seized cTokens for underlying asset\n        uint256 seizedCTokenAmount = cTokenCollateral.balanceOf(address(this));\n        require(seizedCTokenAmount > 0, \"No cTokens seized.\");\n        uint256 redeemResult = cTokenCollateral.redeem(seizedCTokenAmount);\n        require(redeemResult == 0, \"Error calling redeeming seized cToken: error code not equal to 0\");\n\n        // Repay flashloan\n        return repayTokenFlashLoan(repayAmount, cTokenCollateral, exchangeProfitTo, flashLoanReturnAmount, uniswapV2RouterForBorrow, uniswapV2RouterForCollateral, redemptionStrategies, strategyData, underlyingBorrow);\n    }\n\n    /**\n     * @dev Repays token flashloans.\n     */\n    function repayTokenFlashLoan(uint256 repayAmount, ICToken cTokenCollateral, address exchangeProfitTo, uint256 flashLoanReturnAmount, IUniswapV2Router02 uniswapV2RouterForBorrow, IUniswapV2Router02 uniswapV2RouterForCollateral, address[] memory redemptionStrategies, bytes[] memory strategyData, IERC20Upgradeable underlyingBorrow) private returns (address) {\n        // Swap cTokenCollateral for cErc20 via Uniswap\n        if (cTokenCollateral.isCEther()) {\n            // Get flashloan repay amount in terms of WETH collateral via Uniswap router\n            // uniswapV2RouterForCollateral is ignored because it should be the same as uniswapV2RouterForBorrow\n            uint256 underlyingCollateralSeized = address(this).balance;\n            uint256 wethRequired = getAmountsIn(uniswapV2RouterForBorrow.factory(), repayAmount, array(WETH_ADDRESS, address(underlyingBorrow)))[0];\n\n            // Repay flashloan\n            require(wethRequired <= underlyingCollateralSeized, \"Seized ETH collateral not enough to repay flashloan.\");\n            WETH.deposit{value: wethRequired}();\n            require(WETH.transfer(msg.sender, wethRequired), \"Failed to repay Uniswap flashloan with WETH exchanged from seized collateral.\");\n\n            // Return the profited token (ETH)\n            return address(0);\n        } else {\n            // Check underlying collateral seized\n            IERC20Upgradeable underlyingCollateral = IERC20Upgradeable(ICErc20(address(cTokenCollateral)).underlying());\n            uint256 underlyingCollateralSeized = underlyingCollateral.balanceOf(address(this));\n\n            // Redeem custom collateral if liquidation strategy is set\n            if (redemptionStrategies.length > 0) {\n                require(redemptionStrategies.length == strategyData.length, \"IRedemptionStrategy contract array and strategy data bytes array mnust the the same length.\");\n                for (uint256 i = 0; i < redemptionStrategies.length; i++) (underlyingCollateral, underlyingCollateralSeized) = redeemCustomCollateral(underlyingCollateral, underlyingCollateralSeized, IRedemptionStrategy(redemptionStrategies[i]), strategyData[i]);\n            }\n\n            // Check which side of the flashloan to repay\n            if (address(underlyingCollateral) == address(underlyingBorrow)) {\n                // Repay flashloan on borrow side with collateral\n                require(flashLoanReturnAmount <= underlyingBorrow.balanceOf(address(this)), \"Token flashloan return amount greater than tokens exchanged from seized collateral.\");\n                require(underlyingBorrow.transfer(msg.sender, flashLoanReturnAmount), \"Failed to repay token flashloan on borrow (non-WETH) side.\");\n\n                // Return the profited token (same as collateral and borrow)\n                return address(underlyingCollateral);\n            } else {\n                // Get WETH required to repay flashloan\n                uint256 wethRequired = getAmountsIn(uniswapV2RouterForBorrow.factory(), repayAmount, array(WETH_ADDRESS, address(underlyingBorrow)))[0];\n\n                if (address(underlyingCollateral) != WETH_ADDRESS) {\n                    // Approve to Uniswap router\n                    safeApprove(underlyingCollateral, address(uniswapV2RouterForCollateral), underlyingCollateralSeized);\n\n                    // Swap collateral tokens for WETH to be repaid via Uniswap router\n                    if (exchangeProfitTo == address(underlyingCollateral)) uniswapV2RouterForCollateral.swapTokensForExactTokens(wethRequired, underlyingCollateralSeized, array(address(underlyingCollateral), WETH_ADDRESS), address(this), block.timestamp);\n                    else uniswapV2RouterForCollateral.swapExactTokensForTokens(underlyingCollateralSeized, wethRequired, array(address(underlyingCollateral), WETH_ADDRESS), address(this), block.timestamp);\n                }\n\n                // Repay flashloan\n                require(wethRequired <= IERC20Upgradeable(WETH_ADDRESS).balanceOf(address(this)), \"Not enough WETH exchanged from seized collateral to repay flashloan.\");\n                require(WETH.transfer(msg.sender, wethRequired), \"Failed to repay Uniswap flashloan with WETH exchanged from seized collateral.\");\n\n                // Return the profited token (underlying collateral if same as exchangeProfitTo; otherwise, WETH)\n                return exchangeProfitTo == address(underlyingCollateral) ? address(underlyingCollateral) : WETH_ADDRESS;\n            }\n        }\n    }\n\n    /**\n     * @dev Redeem \"special\" collateral tokens (before swapping the output for borrowed tokens to be repaid via Uniswap).\n     * Public visibility because we have to call this function externally if called from a payable FuseSafeLiquidator function (for some reason delegatecall fails when called with msg.value > 0).\n     */\n    function redeemCustomCollateral(IERC20Upgradeable underlyingCollateral, uint256 underlyingCollateralSeized, IRedemptionStrategy strategy, bytes memory strategyData) public returns (IERC20Upgradeable, uint256) {\n        bytes memory returndata = _functionDelegateCall(address(strategy), abi.encodeWithSelector(strategy.redeem.selector, underlyingCollateral, underlyingCollateralSeized, strategyData));\n        return abi.decode(returndata, (IERC20Upgradeable, uint256));\n    }\n    \n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], but performing a delegate call.\n     * Copied from https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/cb4774ace1cb84f2662fa47c573780aab937628b/contracts/utils/MulticallUpgradeable.sol#L37\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Used by `_functionDelegateCall` to verify the result of a delegate call.\n     * Copied from https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/cb4774ace1cb84f2662fa47c573780aab937628b/contracts/utils/MulticallUpgradeable.sol#L45\n     */\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n\n    /**\n     * @dev Returns an array containing the parameters supplied.\n     */\n    function array(uint256 a) private pure returns (uint256[] memory) {\n        uint256[] memory arr = new uint256[](1);\n        arr[0] = a;\n        return arr;\n    }\n\n    /**\n     * @dev Returns an array containing the parameters supplied.\n     */\n    function array(address a) private pure returns (address[] memory) {\n        address[] memory arr = new address[](1);\n        arr[0] = a;\n        return arr;\n    }\n\n    /**\n     * @dev Returns an array containing the parameters supplied.\n     */\n    function array(address a, address b) private pure returns (address[] memory) {\n        address[] memory arr = new address[](2);\n        arr[0] = a;\n        arr[1] = b;\n        return arr;\n    }\n\n    /**\n     * @dev Returns an array containing the parameters supplied.\n     */\n    function array(address a, address b, address c) private pure returns (address[] memory) {\n        address[] memory arr = new address[](3);\n        arr[0] = a;\n        arr[1] = b;\n        arr[2] = c;\n        return arr;\n    }\n}\n"
    },
    "contracts/external/compound/ICEther.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity >=0.7.0;\n\nimport \"./ICToken.sol\";\n\n/**\n * @title Compound's CEther Contract\n * @notice CTokens which wrap an EIP-20 underlying\n * @author Compound\n */\ninterface ICEther is ICToken {\n    function liquidateBorrow(address borrower, ICToken cTokenCollateral) external payable;\n}\n"
    },
    "contracts/external/uniswap/IUniswapV2Callee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.7.0;\n\ninterface IUniswapV2Callee {\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n"
    },
    "contracts/external/uniswap/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\n\nimport \"./IUniswapV2Pair.sol\";\n\nlibrary UniswapV2Library {\n    using SafeMathUpgradeable for uint;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint(keccak256(abi.encodePacked(\n                hex'ff',\n                factory,\n                keccak256(abi.encodePacked(token0, token1)),\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n            ))));\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\n        uint denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[0] = amountIn;\n        for (uint i; i < path.length - 1; i++) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint i = path.length - 1; i > 0; i--) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n"
    },
    "contracts/liquidators/CEtherLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/compound/ICEther.sol\";\n\nimport \"../external/aave/IWETH.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title CEtherLiquidator\n * @notice Redeems seized Compound/Cream/Fuse CEther cTokens for underlying ETH for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CEtherLiquidator is IRedemptionStrategy {\n    /**\n     * @dev WETH contract object.\n     */\n    IWETH constant private WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n        // Redeem cEther for underlying ETH (and store output as new collateral)\n        ICEther cEther = ICEther(address(inputToken));\n        uint256 redeemResult = cEther.redeem(inputAmount);\n        require(redeemResult == 0, \"Error calling redeeming seized cEther: error code not equal to 0\");\n        outputToken = IERC20Upgradeable(address(0));\n        outputAmount = address(this).balance;\n\n        // Convert to WETH because `FuseSafeLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address) \n        WETH.deposit{value: outputAmount}();\n        return (IERC20Upgradeable(address(WETH)), outputAmount);\n    }\n}\n"
    },
    "contracts/FusePoolLens.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"./external/compound/IComptroller.sol\";\nimport \"./external/compound/IPriceOracle.sol\";\nimport \"./external/compound/ICToken.sol\";\nimport \"./external/compound/ICErc20.sol\";\nimport \"./external/compound/IRewardsDistributor.sol\";\n\nimport \"./external/uniswap/IUniswapV2Pair.sol\";\n\nimport \"./FusePoolDirectory.sol\";\nimport \"./oracles/MasterPriceOracle.sol\";\n\n/**\n * @title FusePoolLens\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice FusePoolLens returns data on Fuse interest rate pools in mass for viewing by dApps, bots, etc.\n */\ncontract FusePoolLens is Initializable {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Constructor to set the `FusePoolDirectory` contract object.\n     */\n    function initialize(FusePoolDirectory _directory) public initializer {\n        require(address(_directory) != address(0), \"FusePoolDirectory instance cannot be the zero address.\");\n        directory = _directory;\n    }\n\n    /**\n     * @notice `FusePoolDirectory` contract object.\n     */\n    FusePoolDirectory public directory;\n\n    /**\n     * @dev Struct for Fuse pool summary data.\n     */\n    struct FusePoolData {\n        uint256 totalSupply;\n        uint256 totalBorrow;\n        address[] underlyingTokens;\n        string[] underlyingSymbols;\n        bool whitelistedAdmin;\n    }\n\n    /**\n     * @notice Returns arrays of all public Fuse pool indexes, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n     */\n    function getPublicPoolsWithData() external returns (uint256[] memory, FusePoolDirectory.FusePool[] memory, FusePoolData[] memory, bool[] memory) {\n        (uint256[] memory indexes, FusePoolDirectory.FusePool[] memory publicPools) = directory.getPublicPools();\n        (FusePoolData[] memory data, bool[] memory errored) = getPoolsData(publicPools);\n        return (indexes, publicPools, data, errored);\n    }\n\n    /**\n     * @notice Returns arrays of all whitelisted public Fuse pool indexes, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n     */\n    function getPublicPoolsByVerificationWithData(bool whitelistedAdmin) external returns (uint256[] memory, FusePoolDirectory.FusePool[] memory, FusePoolData[] memory, bool[] memory) {\n        (uint256[] memory indexes, FusePoolDirectory.FusePool[] memory publicPools) = directory.getPublicPoolsByVerification(whitelistedAdmin);\n        (FusePoolData[] memory data, bool[] memory errored) = getPoolsData(publicPools);\n        return (indexes, publicPools, data, errored);\n    }\n\n    /**\n     * @notice Returns arrays of the indexes of Fuse pools created by `account`, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n     */\n    function getPoolsByAccountWithData(address account) external returns (uint256[] memory, FusePoolDirectory.FusePool[] memory, FusePoolData[] memory, bool[] memory) {\n        (uint256[] memory indexes, FusePoolDirectory.FusePool[] memory accountPools) = directory.getPoolsByAccount(account);\n        (FusePoolData[] memory data, bool[] memory errored) = getPoolsData(accountPools);\n        return (indexes, accountPools, data, errored);\n    }\n\n    /**\n     * @notice Internal function returning arrays of requested Fuse pool indexes, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n     */\n    function getPoolsData(FusePoolDirectory.FusePool[] memory pools) internal returns (FusePoolData[] memory, bool[] memory) {\n        FusePoolData[] memory data = new FusePoolData[](pools.length);\n        bool[] memory errored = new bool[](pools.length);\n\n        for (uint256 i = 0; i < pools.length; i++) {\n            try this.getPoolSummary(IComptroller(pools[i].comptroller)) returns (uint256 _totalSupply, uint256 _totalBorrow, address[] memory _underlyingTokens, string[] memory _underlyingSymbols, bool _whitelistedAdmin) {\n                data[i] = FusePoolData(_totalSupply, _totalBorrow, _underlyingTokens, _underlyingSymbols, _whitelistedAdmin);\n            } catch {\n                errored[i] = true;\n            }\n        }\n\n        return (data, errored);\n    }\n\n    /**\n     * @notice Returns total supply balance (in ETH), total borrow balance (in ETH), underlying token addresses, and underlying token symbols of a Fuse pool.\n     */\n    function getPoolSummary(IComptroller comptroller) external returns (uint256, uint256, address[] memory, string[] memory, bool) {\n        uint256 totalBorrow = 0;\n        uint256 totalSupply = 0;\n        ICToken[] memory cTokens = comptroller.getAllMarkets();\n        address[] memory underlyingTokens = new address[](cTokens.length);\n        string[] memory underlyingSymbols = new string[](cTokens.length);\n        IPriceOracle oracle = comptroller.oracle();\n\n        for (uint256 i = 0; i < cTokens.length; i++) {\n            ICToken cToken = cTokens[i];\n            (bool isListed, ) = comptroller.markets(address(cToken));\n            if (!isListed) continue;\n            uint256 assetTotalBorrow = cToken.totalBorrowsCurrent();\n            uint256 assetTotalSupply = cToken.getCash().add(assetTotalBorrow).sub(cToken.totalReserves().add(cToken.totalAdminFees()).add(cToken.totalFuseFees()));\n            uint256 underlyingPrice = oracle.getUnderlyingPrice(cToken);\n            totalBorrow = totalBorrow.add(assetTotalBorrow.mul(underlyingPrice).div(1e18));\n            totalSupply = totalSupply.add(assetTotalSupply.mul(underlyingPrice).div(1e18));\n\n            if (cToken.isCEther()) {\n                underlyingTokens[i] = address(0);\n                underlyingSymbols[i] = \"ETH\";\n            } else {\n                underlyingTokens[i] = ICErc20(address(cToken)).underlying();\n                (, underlyingSymbols[i]) = getTokenNameAndSymbol(underlyingTokens[i]);\n            }\n        }\n\n        bool whitelistedAdmin = directory.adminWhitelist(comptroller.admin());\n        return (totalSupply, totalBorrow, underlyingTokens, underlyingSymbols, whitelistedAdmin);\n    }\n\n    /**\n     * @dev Struct for a Fuse pool asset.\n     */\n    struct FusePoolAsset {\n        address cToken;\n        address underlyingToken;\n        string underlyingName;\n        string underlyingSymbol;\n        uint256 underlyingDecimals;\n        uint256 underlyingBalance;\n        uint256 supplyRatePerBlock;\n        uint256 borrowRatePerBlock;\n        uint256 totalSupply;\n        uint256 totalBorrow;\n        uint256 supplyBalance;\n        uint256 borrowBalance;\n        uint256 liquidity;\n        bool membership;\n        uint256 exchangeRate; // Price of cTokens in terms of underlying tokens\n        uint256 underlyingPrice; // Price of underlying tokens in ETH (scaled by 1e18)\n        address oracle;\n        uint256 collateralFactor;\n        uint256 reserveFactor;\n        uint256 adminFee;\n        uint256 fuseFee;\n        bool borrowGuardianPaused;\n    }\n\n    /**\n     * @notice Returns data on the specified assets of the specified Fuse pool.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n     * @param comptroller The Comptroller proxy contract address of the Fuse pool.\n     * @param cTokens The cToken contract addresses of the assets to query.\n     * @param user The user for which to get account data.\n     * @return An array of Fuse pool assets.\n     */\n    function getPoolAssetsWithData(IComptroller comptroller, ICToken[] memory cTokens, address user) internal returns (FusePoolAsset[] memory) {\n        uint256 arrayLength = 0;\n\n        for (uint256 i = 0; i < cTokens.length; i++) {\n            (bool isListed, ) = comptroller.markets(address(cTokens[i]));\n            if (isListed) arrayLength++;\n        }\n\n        FusePoolAsset[] memory detailedAssets = new FusePoolAsset[](arrayLength);\n        uint256 index = 0;\n        IPriceOracle oracle = comptroller.oracle();\n\n        for (uint256 i = 0; i < cTokens.length; i++) {\n            // Check if market is listed and get collateral factor\n            (bool isListed, uint256 collateralFactorMantissa) = comptroller.markets(address(cTokens[i]));\n            if (!isListed) continue;\n\n            // Start adding data to FusePoolAsset\n            FusePoolAsset memory asset;\n            ICToken cToken = cTokens[i];\n            asset.cToken = address(cToken);\n\n            // Get underlying asset data\n            if (cToken.isCEther()) {\n                asset.underlyingName = \"Ethereum\";\n                asset.underlyingSymbol = \"ETH\";\n                asset.underlyingDecimals = 18;\n                asset.underlyingBalance = user.balance;\n            } else {\n                asset.underlyingToken = ICErc20(address(cToken)).underlying();\n                ERC20Upgradeable underlying = ERC20Upgradeable(asset.underlyingToken);\n                (asset.underlyingName, asset.underlyingSymbol) = getTokenNameAndSymbol(asset.underlyingToken);\n                asset.underlyingDecimals = underlying.decimals();\n                asset.underlyingBalance = underlying.balanceOf(user);\n            }\n\n            // Get cToken data\n            asset.supplyRatePerBlock = cToken.supplyRatePerBlock();\n            asset.borrowRatePerBlock = cToken.borrowRatePerBlock();\n            asset.liquidity = cToken.getCash();\n            asset.totalBorrow = cToken.totalBorrowsCurrent();\n            asset.totalSupply = asset.liquidity.add(asset.totalBorrow).sub(cToken.totalReserves().add(cToken.totalAdminFees()).add(cToken.totalFuseFees()));\n            asset.supplyBalance = cToken.balanceOfUnderlying(user);\n            asset.borrowBalance = cToken.borrowBalanceStored(user); // We would use borrowBalanceCurrent but we already accrue interest above\n            asset.membership = comptroller.checkMembership(user, cToken);\n            asset.exchangeRate = cToken.exchangeRateStored(); // We would use exchangeRateCurrent but we already accrue interest above\n            asset.underlyingPrice = oracle.getUnderlyingPrice(cToken);\n\n            // Get oracle for this cToken\n            asset.oracle = address(oracle);\n\n            try MasterPriceOracle(asset.oracle).oracles(asset.underlyingToken) returns (IPriceOracle _oracle) {\n                asset.oracle = address(_oracle);\n            } catch { }\n\n            // More cToken data\n            asset.collateralFactor = collateralFactorMantissa;\n            asset.reserveFactor = cToken.reserveFactorMantissa();\n            asset.adminFee = cToken.adminFeeMantissa();\n            asset.fuseFee = cToken.fuseFeeMantissa();\n            asset.borrowGuardianPaused = comptroller.borrowGuardianPaused(address(cToken));\n\n            // Add to assets array and increment index\n            detailedAssets[index] = asset;\n            index++;\n        }\n\n        return (detailedAssets);\n    }\n\n    /**\n     * @notice Returns the `name` and `symbol` of `token`.\n     * Supports Uniswap V2 and SushiSwap LP tokens as well as MKR.\n     * @param token An ERC20 token contract object.\n     * @return The `name` and `symbol`.\n     */\n    function getTokenNameAndSymbol(address token) internal view returns (string memory, string memory) {\n        // MKR is a DSToken and uses bytes32\n        if (token == 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2) return (\"Maker\", \"MKR\");\n        if (token == 0xB8c77482e45F1F44dE1745F52C74426C631bDD52) return (\"BNB\", \"BNB\");\n\n        // Get name and symbol from token contract\n        ERC20Upgradeable tokenContract = ERC20Upgradeable(token);\n        string memory name = tokenContract.name();\n        string memory symbol = tokenContract.symbol();\n\n        // Check for Uniswap V2/SushiSwap pair\n        try IUniswapV2Pair(token).token0() returns (address _token0) {\n            bool isUniswapToken = keccak256(abi.encodePacked(name)) == keccak256(abi.encodePacked(\"Uniswap V2\")) && keccak256(abi.encodePacked(symbol)) == keccak256(abi.encodePacked(\"UNI-V2\"));\n            bool isSushiSwapToken = !isUniswapToken && keccak256(abi.encodePacked(name)) == keccak256(abi.encodePacked(\"SushiSwap LP Token\")) && keccak256(abi.encodePacked(symbol)) == keccak256(abi.encodePacked(\"SLP\"));\n\n            if (isUniswapToken || isSushiSwapToken) {\n                ERC20Upgradeable token0 = ERC20Upgradeable(_token0);\n                ERC20Upgradeable token1 = ERC20Upgradeable(IUniswapV2Pair(token).token1());\n                name = string(abi.encodePacked(isSushiSwapToken ? \"SushiSwap \" : \"Uniswap \", token0.symbol(), \"/\", token1.symbol(), \" LP\"));\n                symbol = string(abi.encodePacked(token0.symbol(), \"-\", token1.symbol()));\n            }\n        } catch { }\n\n        return (name, symbol);\n    }\n\n    /**\n     * @notice Returns the assets of the specified Fuse pool.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n     * @param comptroller The Comptroller proxy contract of the Fuse pool.\n     * @return An array of Fuse pool assets.\n     */\n    function getPoolAssetsWithData(IComptroller comptroller) external returns (FusePoolAsset[] memory) {\n        return getPoolAssetsWithData(comptroller, comptroller.getAllMarkets(), msg.sender);\n    }\n\n    /**\n     * @dev Struct for a Fuse pool user.\n     */\n    struct FusePoolUser {\n        address account;\n        uint256 totalBorrow;\n        uint256 totalCollateral;\n        uint256 health;\n        FusePoolAsset[] assets;\n    }\n\n    /**\n     * @notice Returns the borrowers of the specified Fuse pool.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n     * @param comptroller The Comptroller proxy contract of the Fuse pool.\n     * @param maxHealth The maximum health (scaled by 1e18) for which to return data.\n     * @return An array of Fuse pool users, the pool's close factor, and the pool's liquidation incentive.\n     */\n    function getPoolUsersWithData(IComptroller comptroller, uint256 maxHealth) external returns (FusePoolUser[] memory, uint256, uint256) {\n        address[] memory users = comptroller.getAllBorrowers();\n        uint256 arrayLength = 0;\n\n        for (uint256 i = 0; i < users.length; i++) {\n            uint256 totalBorrow = 0;\n            uint256 totalCollateral = 0;\n            FusePoolAsset[] memory assets = getPoolAssetsWithData(comptroller, comptroller.getAssetsIn(users[i]), users[i]);\n\n            for (uint256 j = 0; j < assets.length; j++) {\n                totalBorrow = totalBorrow.add(assets[j].borrowBalance.mul(assets[j].underlyingPrice).div(1e18));\n                if (assets[j].membership) totalCollateral = totalCollateral.add(assets[j].supplyBalance.mul(assets[j].underlyingPrice).div(1e18).mul(assets[j].collateralFactor).div(1e18));\n            }\n\n            uint256 health = totalBorrow > 0 ? totalCollateral.mul(1e18).div(totalBorrow) : 1e36;\n            if (health <= maxHealth) arrayLength++;\n        }\n\n        FusePoolUser[] memory detailedUsers = new FusePoolUser[](arrayLength);\n        uint256 index = 0;\n\n        for (uint256 i = 0; i < users.length; i++) {\n            uint256 totalBorrow = 0;\n            uint256 totalCollateral = 0;\n            FusePoolAsset[] memory assets = getPoolAssetsWithData(comptroller, comptroller.getAssetsIn(users[i]), users[i]);\n\n            for (uint256 j = 0; j < assets.length; j++) {\n                totalBorrow = totalBorrow.add(assets[j].borrowBalance.mul(assets[j].underlyingPrice).div(1e18));\n                if (assets[j].membership) totalCollateral = totalCollateral.add(assets[j].supplyBalance.mul(assets[j].underlyingPrice).div(1e18).mul(assets[j].collateralFactor).div(1e18));\n            }\n\n            uint256 health = totalBorrow > 0 ? totalCollateral.mul(1e18).div(totalBorrow) : 1e36;\n            if (health > maxHealth) continue;\n            detailedUsers[index] = FusePoolUser(users[i], totalBorrow, totalCollateral, health, assets);\n            index++;\n        }\n\n        return (detailedUsers, comptroller.closeFactorMantissa(), comptroller.liquidationIncentiveMantissa());\n    }\n\n    /**\n     * @notice Returns the users of each public Fuse pool.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n     * @param maxHealth The maximum health (scaled by 1e18) for which to return data.\n     * @return An array of pools' Comptroller proxy addresses, an array of arrays of Fuse pool users, an array of pools' close factors, an array of pools' liquidation incentives, and an array of booleans indicating if retrieving each pool's data failed.\n     */\n    function getPublicPoolUsersWithData(uint256 maxHealth) external returns (IComptroller[] memory, FusePoolUser[][] memory, uint256[] memory, uint256[] memory, bool[] memory) {\n        // Get Comptroller addresses of all public pools\n        IComptroller[] memory comptrollers;\n\n        // Scope to avoid \"stack too deep\" error\n        {\n            (, FusePoolDirectory.FusePool[] memory publicPools) = directory.getPublicPools();\n            comptrollers = new IComptroller[](publicPools.length);\n            for (uint256 i = 0; i < publicPools.length; i++) comptrollers[i] = IComptroller(publicPools[i].comptroller);\n        }\n\n        // Get all public pools' data\n        (FusePoolUser[][] memory users, uint256[] memory closeFactors, uint256[] memory liquidationIncentives, bool[] memory errored) = getPoolUsersWithData(comptrollers, maxHealth);\n        return (comptrollers, users, closeFactors, liquidationIncentives, errored);\n    }\n\n    /**\n     * @notice Returns the users of the specified Fuse pools.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n     * @param comptrollers The Comptroller proxy contracts of the Fuse pools.\n     * @param maxHealth The maximum health (scaled by 1e18) for which to return data.\n     * @return An array of arrays of Fuse pool users, an array of pools' close factors, an array of pools' liquidation incentives, and an array of booleans indicating if retrieving each pool's data failed.\n     */\n    function getPoolUsersWithData(IComptroller[] memory comptrollers, uint256 maxHealth) public returns (FusePoolUser[][] memory, uint256[] memory, uint256[] memory, bool[] memory) {\n        FusePoolUser[][] memory users = new FusePoolUser[][](comptrollers.length);\n        uint256[] memory closeFactors = new uint256[](comptrollers.length);\n        uint256[] memory liquidationIncentives = new uint256[](comptrollers.length);\n        bool[] memory errored = new bool[](comptrollers.length);\n\n        for (uint256 i = 0; i < comptrollers.length; i++) {\n            try this.getPoolUsersWithData(IComptroller(comptrollers[i]), maxHealth) returns (FusePoolUser[] memory _users, uint256 closeFactor, uint256 liquidationIncentive) {\n                users[i] = _users;\n                closeFactors[i] = closeFactor;\n                liquidationIncentives[i] = liquidationIncentive;\n            } catch {\n                errored[i] = true;\n            }\n        }\n\n        return (users, closeFactors, liquidationIncentives, errored);\n    }\n\n    /**\n     * @notice Returns arrays of Fuse pool indexes and data supplied to by `account`.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     */\n    function getPoolsBySupplier(address account) public view returns (uint256[] memory, FusePoolDirectory.FusePool[] memory) {\n        FusePoolDirectory.FusePool[] memory pools = directory.getAllPools();\n        uint256 arrayLength = 0;\n\n        for (uint256 i = 0; i < pools.length; i++) {\n            IComptroller comptroller = IComptroller(pools[i].comptroller);\n\n            try comptroller.suppliers(account) returns (bool isSupplier) {\n                if (isSupplier) {\n                    ICToken[] memory allMarkets = comptroller.getAllMarkets();\n\n                    for (uint256 j = 0; j < allMarkets.length; j++) if (allMarkets[j].balanceOf(account) > 0) {\n                        arrayLength++;\n                        break;\n                    }\n                }\n            } catch {}\n        }\n\n        uint256[] memory indexes = new uint256[](arrayLength);\n        FusePoolDirectory.FusePool[] memory accountPools = new FusePoolDirectory.FusePool[](arrayLength);\n        uint256 index = 0;\n\n        for (uint256 i = 0; i < pools.length; i++) {\n            IComptroller comptroller = IComptroller(pools[i].comptroller);\n\n            try comptroller.suppliers(account) returns (bool isSupplier) {\n                if (isSupplier) {\n                    ICToken[] memory allMarkets = comptroller.getAllMarkets();\n\n                    for (uint256 j = 0; j < allMarkets.length; j++) if (allMarkets[j].balanceOf(account) > 0) {\n                        indexes[index] = i;\n                        accountPools[index] = pools[i];\n                        index++;\n                        break;\n                    }\n                }\n            } catch {}\n        }\n\n        return (indexes, accountPools);\n    }\n\n    /**\n     * @notice Returns arrays of the indexes of Fuse pools supplied to by `account`, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n     */\n    function getPoolsBySupplierWithData(address account) external returns (uint256[] memory, FusePoolDirectory.FusePool[] memory, FusePoolData[] memory, bool[] memory) {\n        (uint256[] memory indexes, FusePoolDirectory.FusePool[] memory accountPools) = getPoolsBySupplier(account);\n        (FusePoolData[] memory data, bool[] memory errored) = getPoolsData(accountPools);\n        return (indexes, accountPools, data, errored);\n    }\n\n    /**\n     * @notice Returns the total supply balance (in ETH) and the total borrow balance (in ETH) of the caller across all pools.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n     */\n    function getUserSummary(address account) external returns (uint256, uint256, bool) {\n        FusePoolDirectory.FusePool[] memory pools = directory.getAllPools();\n        uint256 borrowBalance = 0;\n        uint256 supplyBalance = 0;\n        bool errors = false;\n\n        for (uint256 i = 0; i < pools.length; i++) {\n            try this.getPoolUserSummary(IComptroller(pools[i].comptroller), account) returns (uint256 poolSupplyBalance, uint256 poolBorrowBalance) {\n                supplyBalance = supplyBalance.add(poolSupplyBalance);\n                borrowBalance = borrowBalance.add(poolBorrowBalance);\n            } catch {\n                errors = true;\n            }\n        }\n\n        return (supplyBalance, borrowBalance, errors);\n    }\n\n    /**\n     * @notice Returns the total supply balance (in ETH) and the total borrow balance (in ETH) of the caller in the specified pool.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n     */\n    function getPoolUserSummary(IComptroller comptroller, address account) external returns (uint256, uint256) {\n        uint256 borrowBalance = 0;\n        uint256 supplyBalance = 0;\n\n        if (!comptroller.suppliers(account)) return (0, 0);\n        ICToken[] memory cTokens = comptroller.getAllMarkets();\n        IPriceOracle oracle = comptroller.oracle();\n\n        for (uint256 i = 0; i < cTokens.length; i++) {\n            ICToken cToken = cTokens[i];\n            (bool isListed, ) = comptroller.markets(address(cToken));\n            if (!isListed) continue;\n            uint256 assetSupplyBalance = cToken.balanceOfUnderlying(account);\n            uint256 assetBorrowBalance = cToken.borrowBalanceStored(account); // We would use borrowBalanceCurrent but we already accrue interest above\n            uint256 underlyingPrice = oracle.getUnderlyingPrice(cToken);\n            borrowBalance = borrowBalance.add(assetBorrowBalance.mul(underlyingPrice).div(1e18));\n            supplyBalance = supplyBalance.add(assetSupplyBalance.mul(underlyingPrice).div(1e18));\n        }\n\n        return (supplyBalance, borrowBalance);\n    }\n\n    /**\n     * @notice Returns arrays of Fuse pool indexes and data with a whitelist containing `account`.\n     * Note that the whitelist does not have to be enforced.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     */\n    function getWhitelistedPoolsByAccount(address account) public view returns (uint256[] memory, FusePoolDirectory.FusePool[] memory) {\n        FusePoolDirectory.FusePool[] memory pools = directory.getAllPools();\n        uint256 arrayLength = 0;\n\n        for (uint256 i = 0; i < pools.length; i++) {\n            IComptroller comptroller = IComptroller(pools[i].comptroller);\n\n            if (comptroller.whitelist(account)) arrayLength++;\n        }\n\n        uint256[] memory indexes = new uint256[](arrayLength);\n        FusePoolDirectory.FusePool[] memory accountPools = new FusePoolDirectory.FusePool[](arrayLength);\n        uint256 index = 0;\n\n        for (uint256 i = 0; i < pools.length; i++) {\n            IComptroller comptroller = IComptroller(pools[i].comptroller);\n\n            if (comptroller.whitelist(account)) {\n                indexes[index] = i;\n                accountPools[index] = pools[i];\n                index++;\n                break;\n            }\n        }\n\n        return (indexes, accountPools);\n    }\n\n    /**\n     * @notice Returns arrays of the indexes of Fuse pools with a whitelist containing `account`, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n     */\n    function getWhitelistedPoolsByAccountWithData(address account) external returns (uint256[] memory, FusePoolDirectory.FusePool[] memory, FusePoolData[] memory, bool[] memory) {\n        (uint256[] memory indexes, FusePoolDirectory.FusePool[] memory accountPools) = getWhitelistedPoolsByAccount(account);\n        (FusePoolData[] memory data, bool[] memory errored) = getPoolsData(accountPools);\n        return (indexes, accountPools, data, errored);\n    }\n}\n"
    },
    "contracts/oracles/default/RecursivePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\nimport \"../../external/compound/IComptroller.sol\";\n\n/**\n * @title RecursivePriceOracle\n * @notice Returns prices from other cTokens (from Fuse).\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract RecursivePriceOracle is IPriceOracle {\n    using SafeMathUpgradeable for uint256;\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(ICToken cToken) external override view returns (uint) {\n        // Get cToken's underlying cToken\n        ICToken underlying = ICToken(ICErc20(address(cToken)).underlying());\n\n        // Get Comptroller\n        IComptroller comptroller = IComptroller(underlying.comptroller());\n\n        // If cETH, return cETH/ETH exchange rate\n        if (underlying.isCEther()) {\n            return underlying.exchangeRateStored();\n        }\n\n        // Fuse cTokens: cToken/token price * token/ETH price = cToken/ETH price\n        return underlying.exchangeRateStored().mul(comptroller.oracle().getUnderlyingPrice(underlying)).div(1e18);\n    }\n\n}\n"
    },
    "contracts/liquidators/CurveMetapoolLpTokenLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/curve/ICurveStableSwap.sol\";\n\nimport \"../external/aave/IWETH.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title CurveMetaPoolLpTokenLiquidator\n * @notice Redeems seized Curve Metapool LP token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CurveMetaPoolLpTokenLiquidator is IRedemptionStrategy {\n    /**\n     * @dev WETH contract object.\n     */\n    IWETH constant private WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n        // Remove liquidity from Curve pool in the form of one coin only (and store output as new collateral)\n        ICurveStableSwap curvePool = ICurveStableSwap(address(inputToken));\n        (uint8 curveCoinIndex, address underlying) = abi.decode(strategyData, (uint8, address));\n        curvePool.remove_liquidity_one_coin(inputAmount, int128(curveCoinIndex), 1);\n        outputToken = IERC20Upgradeable(underlying == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE ? address(0) : underlying);\n        outputAmount = address(outputToken) == address(0) ? address(this).balance : outputToken.balanceOf(address(this));\n\n        // Convert to WETH if ETH because `FuseSafeLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address) \n        if (address(outputToken) == address(0)) {\n            WETH.deposit{value: outputAmount}();\n            return (IERC20Upgradeable(address(WETH)), outputAmount);\n        }\n    }\n}\n"
    },
    "contracts/external/curve/ICurveStableSwap.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface ICurveStableSwap is IERC20Upgradeable {\n    function get_balances() external view returns (uint256[2] memory);\n    function remove_liquidity_one_coin(uint256 _token_amount, int128 i, uint256 min_amount) external;\n}\n"
    },
    "contracts/liquidators/CurveLpTokenLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/curve/ICurveRegistry.sol\";\nimport \"../external/curve/ICurvePool.sol\";\n\nimport \"../external/aave/IWETH.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title CurveLpTokenLiquidator\n * @notice Redeems seized Curve LP token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CurveLpTokenLiquidator is IRedemptionStrategy {\n    /**\n     * @dev WETH contract object.\n     */\n    IWETH constant private WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n        // Remove liquidity from Curve pool in the form of one coin only (and store output as new collateral)\n        ICurvePool curvePool = ICurvePool(ICurveRegistry(0x7D86446dDb609eD0F5f8684AcF30380a356b2B4c).get_pool_from_lp_token(address(inputToken)));\n        (uint8 curveCoinIndex, address underlying) = abi.decode(strategyData, (uint8, address));\n        curvePool.remove_liquidity_one_coin(inputAmount, int128(curveCoinIndex), 1);\n        outputToken = IERC20Upgradeable(underlying == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE ? address(0) : underlying);\n        outputAmount = address(outputToken) == address(0) ? address(this).balance : outputToken.balanceOf(address(this));\n\n        // Convert to WETH if ETH because `FuseSafeLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address) \n        if (address(outputToken) == address(0)) {\n            WETH.deposit{value: outputAmount}();\n            return (IERC20Upgradeable(address(WETH)), outputAmount);\n        }\n    }\n}\n"
    },
    "contracts/liquidators/CurveLiquidityGaugeV2Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/curve/ICurveRegistry.sol\";\nimport \"../external/curve/ICurvePool.sol\";\nimport \"../external/curve/ICurveLiquidityGaugeV2.sol\";\n\nimport \"../external/aave/IWETH.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title CurveLiquidityGaugeV2Liquidator\n * @notice Redeems seized Curve LiquidityGaugeV2 collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CurveLiquidityGaugeV2Liquidator is IRedemptionStrategy {\n    /**\n     * @dev WETH contract object.\n     */\n    IWETH constant private WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n        // Redeem Curve liquidity gauge V2 token for Curve pool LP token (and store output as new collateral)\n        ICurveLiquidityGaugeV2 gauge = ICurveLiquidityGaugeV2(address(inputToken));\n        gauge.withdraw(inputAmount);\n        inputToken = IERC20Upgradeable(gauge.lp_token());\n        \n        // Remove liquidity from Curve pool in the form of one coin only (and store output as new collateral)\n        ICurvePool curvePool = ICurvePool(ICurveRegistry(0x7D86446dDb609eD0F5f8684AcF30380a356b2B4c).get_pool_from_lp_token(address(inputToken)));\n        (uint8 curveCoinIndex, address underlying) = abi.decode(strategyData, (uint8, address));\n        curvePool.remove_liquidity_one_coin(inputAmount, int128(curveCoinIndex), 1);\n        outputToken = IERC20Upgradeable(underlying == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE ? address(0) : underlying);\n        outputAmount = address(outputToken) == address(0) ? address(this).balance : outputToken.balanceOf(address(this));\n\n        // Convert to WETH if ETH because `FuseSafeLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address) \n        if (address(outputToken) == address(0)) {\n            WETH.deposit{value: outputAmount}();\n            return (IERC20Upgradeable(address(WETH)), outputAmount);\n        }\n    }\n}\n"
    },
    "contracts/external/curve/ICurveLiquidityGaugeV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\ninterface ICurveLiquidityGaugeV2 {\n    function lp_token() external view returns (address);\n    function deposit(uint256 _value) external;\n    function withdraw(uint256 _value) external;\n}\n"
    },
    "contracts/oracles/mainnet/CurveLiquidityGaugeV2PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/curve/ICurveLiquidityGaugeV2.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title CurveLiquidityGaugeV2PriceOracle\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice CurveLiquidityGaugeV2PriceOracle is a price oracle for Curve LiquidityGaugeV2 tokens (using the sender as a root oracle).\n * @dev Implements the `PriceOracle` interface used by Fuse pools (and Compound v2).\n * This contract is expected to be called by a `MasterPriceOracle` with the necessary `CurveLpTokenPriceOracle` configured.\n * The price of a Curve LiquidityGaugeV2 token is the same as the price of its underlying Curve LP token.\n */\ncontract CurveLiquidityGaugeV2PriceOracle is IPriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Get the LiquidityGaugeV2 price price for an underlying token address.\n     * @param underlying The underlying token address for which to get the price (set to zero address for ETH).\n     * @return Price denominated in ETH (scaled by 1e18).\n     */\n    function price(address underlying) external override view returns (uint) {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(ICToken cToken) external override view returns (uint) {\n        address underlying = ICErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return _price(underlying).mul(1e18).div(10 ** uint256(ERC20Upgradeable(underlying).decimals()));\n    }\n\n    /**\n     * @dev Fetches the fair LiquidityGaugeV2/ETH price from Curve, with 18 decimals of precision.\n     * @param gauge The LiquidityGaugeV2 contract address for price retrieval.\n     */\n    function _price(address gauge) internal view returns (uint) {\n        return BasePriceOracle(msg.sender).price(ICurveLiquidityGaugeV2(gauge).lp_token());\n    }\n}\n"
    },
    "contracts/liquidators/AlphaHomoraV2SafeBoxETHLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/alpha/ISafeBoxETH.sol\";\n\nimport \"../external/aave/IWETH.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title AlphaHomoraV2SafeBoxETHLiquidator\n * @notice Redeems seized Alpha Homora v2 \"ibETHv2\" (SafeBoxETH) tokens for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract AlphaHomoraV2SafeBoxETHLiquidator is IRedemptionStrategy {\n    /**\n     * @dev WETH contract object.\n     */\n    IWETH constant private WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n        // Redeem ibTokenV2 for underlying ETH (and store output as new collateral)\n        ISafeBoxETH safeBox = ISafeBoxETH(address(inputToken));\n        safeBox.withdraw(inputAmount);\n        outputToken = IERC20Upgradeable(address(0));\n        outputAmount = address(this).balance;\n\n        // Convert to WETH because `FuseSafeLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address) \n        WETH.deposit{value: outputAmount}();\n        return (IERC20Upgradeable(address(WETH)), outputAmount);\n    }\n}\n"
    },
    "contracts/external/alpha/ISafeBoxETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface ISafeBoxETH is IERC20Upgradeable {\n  function cToken() external view returns (address);\n  function deposit() external payable;\n  function withdraw(uint amount) external;\n}\n"
    },
    "contracts/liquidators/AlphaHomoraV1BankLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/alpha/Bank.sol\";\n\nimport \"../external/aave/IWETH.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title AlphaHomoraV1BankLiquidator\n * @notice Redeems seized Alpha Homora v1 ibETH (Bank) tokens for ETH for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract AlphaHomoraV1BankLiquidator is IRedemptionStrategy {\n    /**\n     * @dev WETH contract object.\n     */\n    IWETH constant private WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n        // Redeem ibTokenV2 for underlying ETH token (and store output as new collateral)\n        Bank bank = Bank(address(inputToken));\n        bank.withdraw(inputAmount);\n        outputToken = IERC20Upgradeable(address(0));\n        outputAmount = address(this).balance;\n\n        // Convert to WETH because `FuseSafeLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address) \n        WETH.deposit{value: outputAmount}();\n        return (IERC20Upgradeable(address(WETH)), outputAmount);\n    }\n}\n"
    },
    "contracts/external/alpha/Bank.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface Bank is IERC20Upgradeable {\n    /// @dev Return the total ETH entitled to the token holders. Be careful of unaccrued interests.\n    function totalETH() external view returns (uint256);\n\n    /// @dev Add more ETH to the bank. Hope to get some good returns.\n    function deposit() external payable;\n\n    /// @dev Withdraw ETH from the bank by burning the share tokens.\n    function withdraw(uint256 share) external;\n}\n"
    },
    "contracts/oracles/mainnet/AlphaHomoraV1PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/alpha/Bank.sol\";\n\n/**\n * @title AlphaHomoraV1PriceOracle\n * @notice Returns prices the Alpha Homora V1 ibETH ERC20 token.\n * @dev Implements the `PriceOracle` interface.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract AlphaHomoraV1PriceOracle is IPriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev Alpha Homora ibETH token contract object.\n     */\n    Bank constant public IBETH = Bank(0x67B66C99D3Eb37Fa76Aa3Ed1ff33E8e39F0b9c7A);\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(ICToken cToken) external override view returns (uint) {\n        require(ICErc20(address(cToken)).underlying() == address(IBETH));\n        return IBETH.totalETH().mul(1e18).div(IBETH.totalSupply());\n    }\n}\n"
    },
    "contracts/oracles/mainnet/BadgerPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/chainlink/AggregatorV3Interface.sol\";\n\nimport \"../../external/badger/IXToken.sol\";\nimport \"../../external/badger/IDigg.sol\";\nimport \"../../external/badger/DiggSett.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title BadgerPriceOracle\n * @notice Returns prices for bDIGG, bBADGER, and ibBTC.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract BadgerPriceOracle is IPriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev BADGER/ETH Chainlink price feed.\n     */\n    AggregatorV3Interface constant public BADGER_ETH_FEED = AggregatorV3Interface(0x58921Ac140522867bf50b9E009599Da0CA4A2379);\n\n    /**\n     * @dev bBADGER ERC20 token contract.\n     */\n    IXToken constant public BBADGER = IXToken(0x19D97D8fA813EE2f51aD4B4e04EA08bAf4DFfC28);\n\n    /**\n     * @dev DIGG/BTC Chainlink price feed.\n     */\n    AggregatorV3Interface constant public DIGG_BTC_FEED = AggregatorV3Interface(0x418a6C98CD5B8275955f08F0b8C1c6838c8b1685);\n\n    /**\n     * @dev bDIGG ERC20 token contract.\n     */\n    DiggSett constant public BDIGG = DiggSett(0x7e7E112A68d8D2E221E11047a72fFC1065c38e1a);\n\n    /**\n     * @dev BTC/ETH Chainlink price feed.\n     */\n    AggregatorV3Interface constant public BTC_ETH_FEED = AggregatorV3Interface(0xdeb288F737066589598e9214E782fa5A8eD689e8);\n\n    /**\n     * @dev ibBTC ERC20 token contract.\n     */\n    IXToken constant public IBBTC = IXToken(0xc4E15973E6fF2A35cC804c2CF9D2a1b817a8b40F);\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying) external override view returns (uint) {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(ICToken cToken) external override view returns (uint) {\n        address underlying = ICErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return _price(underlying).mul(1e18).div(10 ** uint256(ERC20Upgradeable(underlying).decimals()));\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint) {\n        if (token == address(BBADGER)) {\n            (uint80 roundId, int256 badgerEthPrice, , , uint80 answeredInRound) = BADGER_ETH_FEED.latestRoundData();\n            require(answeredInRound == roundId, \"Chainlink round timed out.\");\n            return badgerEthPrice > 0 ? uint256(badgerEthPrice).mul(BBADGER.getPricePerFullShare()).div(1e18) : 0;\n        } else if (token == address(BDIGG)) {\n            (uint80 roundId, int256 diggBtcPrice, , , uint80 answeredInRound) = DIGG_BTC_FEED.latestRoundData();\n            require(answeredInRound == roundId, \"Chainlink round timed out.\");\n            if (diggBtcPrice < 0) return 0;\n            int256 btcEthPrice;\n            (roundId, btcEthPrice, , , answeredInRound) = BTC_ETH_FEED.latestRoundData();\n            require(answeredInRound == roundId, \"Chainlink round timed out.\");\n            if (btcEthPrice < 0) return 0;\n            uint256 bDiggDiggPrice = IDigg(BDIGG.token()).sharesToFragments(BDIGG.shares().div(BDIGG.totalSupply()).mul(1e18));\n            // bDIGG/ETH price = (bDIGG/DIGG price / 1e9) * (DIGG/BTC price / 1e8) * BTC/ETH price\n            // Divide by BTC base unit 1e8 (BTC has 8 decimals) and DIGG base unit 1e9 (DIGG has 9 decimals)\n            return bDiggDiggPrice > 0 ? uint256(diggBtcPrice).mul(uint256(btcEthPrice)).div(1e8).mul(bDiggDiggPrice).div(1e9) : 0;\n        } else if (token == address(IBBTC)) {\n            (uint80 roundId, int256 btcEthPrice, , , uint80 answeredInRound) = BTC_ETH_FEED.latestRoundData();\n            require(answeredInRound == roundId, \"Chainlink round timed out.\");\n            return btcEthPrice > 0 ? uint256(btcEthPrice).mul(IBBTC.pricePerShare()).div(1e18) : 0;\n        } else revert(\"Invalid token address passed to BadgerPriceOracle.\");\n    }\n}\n"
    },
    "contracts/external/badger/IXToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\ninterface IXToken {\n    function pricePerShare() external view returns (uint256);\n    function getPricePerFullShare() external view returns (uint256);\n}\n"
    },
    "contracts/external/badger/IDigg.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\ninterface IDigg {\n    /**\n     * @param shares Share value to convert.\n     * @return The current fragment value of the specified underlying share amount.\n     */\n    function sharesToFragments(uint256 shares) external view returns (uint256);\n}\n"
    },
    "contracts/external/badger/DiggSett.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"./Sett.sol\";\n\ninterface DiggSett is Sett {\n    function shares() external view returns (uint256);\n}\n"
    },
    "contracts/external/badger/Sett.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\ninterface Sett {\n    function totalSupply() external view returns (uint256);\n    function withdrawAll() external;\n    function token() external view returns (address);\n}\n"
    },
    "contracts/liquidators/BadgerSettLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/badger/Sett.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title BadgerSettLiquidator\n * @notice Redeems a Badger Sett for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract BadgerSettLiquidator is IRedemptionStrategy {\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n        // Unwrap wstETH (and store output stETH as new collateral)\n        Sett token = Sett(address(inputToken));\n        token.withdrawAll();\n        outputToken = IERC20Upgradeable(token.token());\n        outputAmount = outputToken.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/oracles/default/FixedEurPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/chainlink/AggregatorV3Interface.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title FixedEurPriceOracle\n * @notice Returns fixed prices of 1 EUR in terms of Native Token for all tokens (expected to be used under a `MasterPriceOracle`).\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract FixedEurPriceOracle is IPriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice The maximum number of seconds elapsed since the round was last updated before the price is considered stale. If set to 0, no limit is enforced.\n     */\n    uint256 public maxSecondsBeforePriceIsStale;\n\n    /**\n     * @notice Chainlink NATIVE/USD price feed contracts.\n     */\n    AggregatorV3Interface public immutable NATIVE_TOKEN_USD_PRICE_FEED;\n\n    /**\n     * @notice Chainlink EUR/USD price feed contracts.\n     */\n    AggregatorV3Interface public immutable EUR_USD_PRICE_FEED;\n\n    /**\n     * @dev Constructor to set `maxSecondsBeforePriceIsStale`.\n     */\n    constructor(uint256 _maxSecondsBeforePriceIsStale, address nativeTokenUsdPriceFeed, address eurUsdPriceFeed) {\n        maxSecondsBeforePriceIsStale = _maxSecondsBeforePriceIsStale;\n        NATIVE_TOKEN_USD_PRICE_FEED = AggregatorV3Interface(nativeTokenUsdPriceFeed);\n        EUR_USD_PRICE_FEED = AggregatorV3Interface(eurUsdPriceFeed);\n    }\n\n    /**\n     * @dev Internal function returning the price in NATIVE of `underlying`.\n     */\n    function _price(address underlying) internal view returns (uint) {\n        // Get NATIVE/USD price from Chainlink\n\n        (, int256 nativeUsdPrice, , uint256 updatedAt, ) = NATIVE_TOKEN_USD_PRICE_FEED.latestRoundData();\n        if (maxSecondsBeforePriceIsStale > 0) require(block.timestamp <= updatedAt + maxSecondsBeforePriceIsStale, \"NATIVE/USD Chainlink price is stale.\");\n        if (nativeUsdPrice <= 0) return 0;\n\n        // Get EUR/USD price from Chainlink\n        int256 eurUsdPrice;\n        (, eurUsdPrice, , updatedAt, ) = EUR_USD_PRICE_FEED.latestRoundData();\n        if (maxSecondsBeforePriceIsStale > 0) require(block.timestamp <= updatedAt + maxSecondsBeforePriceIsStale, \"EUR/USD Chainlink price is stale.\");\n        if (eurUsdPrice <= 0) return 0;\n\n        // Return EUR/NATIVE price = EUR/USD price / NATIVE/USD price\n        return uint256(eurUsdPrice).mul(1e18).div(uint256(nativeUsdPrice));\n    }\n\n    /**\n     * @dev Returns the price in NATIVE of `underlying` (implements `BasePriceOracle`).\n     */\n    function price(address underlying) external override view returns (uint) {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in NATIVE of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in NATIVE of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(ICToken cToken) external override view returns (uint) {\n        // Get underlying token address\n        address underlying = ICErc20(address(cToken)).underlying();\n\n        // Format and return price\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return _price(underlying).mul(1e18).div(10 ** uint256(ERC20Upgradeable(underlying).decimals()));\n    }\n}\n"
    },
    "contracts/oracles/1337/MockPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/chainlink/AggregatorV3Interface.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title MockPriceOracle\n * @notice Returns mocked prices from a Chainlink-like oracle. Used for local dev only\n * @dev Implements `PriceOracle`.\n * @author Carlo Mazzaferro <carlo.mazzaferro@gmail.com> (https://github.com/carlomazzaferro)\n */\ncontract MockPriceOracle is IPriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice The maxmimum number of seconds elapsed since the round was last updated before the price is considered stale. If set to 0, no limit is enforced.\n     */\n    uint256 public maxSecondsBeforePriceIsStale;\n\n    /**\n     * @dev Constructor to set `maxSecondsBeforePriceIsStale` as well as all Chainlink price feeds.\n     */\n    constructor(uint256 _maxSecondsBeforePriceIsStale) {\n        // Set maxSecondsBeforePriceIsStale\n        maxSecondsBeforePriceIsStale = _maxSecondsBeforePriceIsStale;\n    }\n\n    /**\n     * @dev Returns a boolean indicating if a price feed exists for the underlying asset.\n     */\n\n    function hasPriceFeed(address underlying) external view returns (bool) {\n        return true;\n    }\n\n    /**\n     * @dev Internal function returning the price in ETH of `underlying`.\n     */\n\n    function random() private view returns (uint) {\n        uint r = uint(keccak256(abi.encodePacked(block.timestamp, msg.sender))) % 99;\n        r = r + 1;\n        return r;\n    }\n\n    function _price(address underlying) internal view returns (uint) {\n        // Return 1e18 for WETH\n        if (underlying == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) return 1e18;\n\n        int256 tokenEthPrice = 1;\n        uint r = random();\n\n        return uint256(tokenEthPrice).mul(1e18).div(r).div(1e18);\n\n    }\n\n    /**\n     * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n     */\n    function price(address underlying) external override view returns (uint) {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(ICToken cToken) external override view returns (uint) {\n        // Return 1e18 for ETH\n        if (cToken.isCEther()) return 1e18;\n\n        // Get underlying token address\n        address underlying = ICErc20(address(cToken)).underlying();\n\n        // Get price\n        uint256 chainlinkPrice = _price(underlying);\n\n        // Format and return price\n        uint256 underlyingDecimals = uint256(ERC20Upgradeable(underlying).decimals());\n        return underlyingDecimals <= 18 ? uint256(chainlinkPrice).mul(10 ** (18 - underlyingDecimals)) : uint256(chainlinkPrice).div(10 ** (underlyingDecimals - 18));\n    }\n}\n"
    },
    "contracts/external/chainlink/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface\n{\n}\n"
    },
    "contracts/external/chainlink/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\ninterface AggregatorInterface {\n  function latestAnswer()\n    external\n    view\n    returns (\n      int256\n    );\n  \n  function latestTimestamp()\n    external\n    view\n    returns (\n      uint256\n    );\n\n  function latestRound()\n    external\n    view\n    returns (\n      uint256\n    );\n\n  function getAnswer(\n    uint256 roundId\n  )\n    external\n    view\n    returns (\n      int256\n    );\n\n  function getTimestamp(\n    uint256 roundId\n  )\n    external\n    view\n    returns (\n      uint256\n    );\n\n  event AnswerUpdated(\n    int256 indexed current,\n    uint256 indexed roundId,\n    uint256 updatedAt\n  );\n\n  event NewRound(\n    uint256 indexed roundId,\n    address indexed startedBy,\n    uint256 startedAt\n  );\n}"
    },
    "contracts/external/chainlink/FeedRegistryInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./AggregatorV2V3Interface.sol\";\n\ninterface FeedRegistryInterface {\n  struct Phase {\n    uint16 phaseId;\n    uint80 startingAggregatorRoundId;\n    uint80 endingAggregatorRoundId;\n  }\n\n  event FeedProposed(\n    address indexed asset,\n    address indexed denomination,\n    address indexed proposedAggregator,\n    address currentAggregator,\n    address sender\n  );\n  event FeedConfirmed(\n    address indexed asset,\n    address indexed denomination,\n    address indexed latestAggregator,\n    address previousAggregator,\n    uint16 nextPhaseId,\n    address sender\n  );\n\n  // V3 AggregatorV3Interface\n\n  function decimals(\n    address base,\n    address quote\n  )\n    external\n    view\n    returns (\n      uint8\n    );\n\n  function description(\n    address base,\n    address quote\n  )\n    external\n    view\n    returns (\n      string memory\n    );\n\n  function version(\n    address base,\n    address quote\n  )\n    external\n    view\n    returns (\n      uint256\n    );\n\n  function latestRoundData(\n    address base,\n    address quote\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function getRoundData(\n    address base,\n    address quote,\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  // V2 AggregatorInterface\n\n  function latestAnswer(\n    address base,\n    address quote\n  )\n    external\n    view\n    returns (\n      int256 answer\n    );\n\n  function latestTimestamp(\n    address base,\n    address quote\n  )\n    external\n    view\n    returns (\n      uint256 timestamp\n    );\n\n  function latestRound(\n    address base,\n    address quote\n  )\n    external\n    view\n    returns (\n      uint256 roundId\n    );\n\n  function getAnswer(\n    address base,\n    address quote,\n    uint256 roundId\n  )\n    external\n    view\n    returns (\n      int256 answer\n    );\n\n  function getTimestamp(\n    address base,\n    address quote,\n    uint256 roundId\n  )\n    external\n    view\n    returns (\n      uint256 timestamp\n    );\n\n  // Registry getters\n\n  function getFeed(\n    address base,\n    address quote\n  )\n    external\n    view\n    returns (\n      AggregatorV2V3Interface aggregator\n    );\n\n  function getPhaseFeed(\n    address base,\n    address quote,\n    uint16 phaseId\n  )\n    external\n    view\n    returns (\n      AggregatorV2V3Interface aggregator\n    );\n\n  function isFeedEnabled(\n    address aggregator\n  )\n    external\n    view\n    returns (\n      bool\n    );\n\n  function getPhase(\n    address base,\n    address quote,\n    uint16 phaseId\n  )\n    external\n    view\n    returns (\n      Phase memory phase\n    );\n\n  // Round helpers\n\n  function getRoundFeed(\n    address base,\n    address quote,\n    uint80 roundId\n  )\n    external\n    view\n    returns (\n      AggregatorV2V3Interface aggregator\n    );\n\n  function getPhaseRange(\n    address base,\n    address quote,\n    uint16 phaseId\n  )\n    external\n    view\n    returns (\n      uint80 startingRoundId,\n      uint80 endingRoundId\n    );\n\n  function getPreviousRoundId(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external\n    view\n    returns (\n      uint80 previousRoundId\n    );\n\n  function getNextRoundId(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external\n    view\n    returns (\n      uint80 nextRoundId\n    );\n\n  // Feed management\n\n  function proposeFeed(\n    address base,\n    address quote,\n    address aggregator\n  ) external;\n\n  function confirmFeed(\n    address base,\n    address quote,\n    address aggregator\n  ) external;\n\n  // Proposed aggregator\n\n  function getProposedFeed(\n    address base,\n    address quote\n  )\n    external\n    view\n    returns (\n      AggregatorV2V3Interface proposedAggregator\n    );\n\n  function proposedGetRoundData(\n    address base,\n    address quote,\n    uint80 roundId\n  )\n    external\n    view\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function proposedLatestRoundData(\n    address base,\n    address quote\n  )\n    external\n    view\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  // Phases\n  function getCurrentPhaseId(\n    address base,\n    address quote\n  )\n    external\n    view\n    returns (\n      uint16 currentPhaseId\n    );\n}\n"
    },
    "contracts/oracles/mainnet/AlphaHomoraV2PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/alpha/ISafeBox.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title AlphaHomoraV2PriceOracle\n * @notice Returns prices from Alpha Homora v2 \"ibTokenV2\" tokens (e.g., ibETHv2, ibDAIv2).\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract AlphaHomoraV2PriceOracle is IPriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev Fetches the fair ibTokenV2/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price (set to zero address for ETH).\n     * @return Price denominated in ETH (scaled by 1e18).\n     */\n    function price(address underlying) external override view returns (uint) {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(ICToken cToken) external override view returns (uint) {\n        address underlying = ICErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return _price(underlying).mul(1e18).div(10 ** uint256(ERC20Upgradeable(underlying).decimals()));\n    }\n\n    /**\n     * @dev Fetches the fair ibTokenV2/ETH price, with 18 decimals of precision.\n     * @param safeBox The SafeBox (or SafeBoxETH) contract address for price retrieval.\n     */\n    function _price(address safeBox) internal view returns (uint) {\n        // Get the cToken's underlying ibToken's underlying cToken\n        ICErc20 underlyingCErc20 = ICErc20(ISafeBox(safeBox).cToken());\n\n        // Get the token underlying the underlying cToken\n        address baseToken = underlyingCErc20.underlying();\n\n        // ibTokenV2/ETH price = underlying cToken/ETH price = underlying cToken/token price * base token/ETH price\n        return underlyingCErc20.exchangeRateStored().mul(BasePriceOracle(msg.sender).price(baseToken)).div(1e18);\n    }\n}\n"
    },
    "contracts/external/alpha/ISafeBox.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface ISafeBox is IERC20Upgradeable {\n  function cToken() external view returns (address); \n  function uToken() external view returns (address); \n  function deposit(uint amount) external;\n  function withdraw(uint amount) external;\n}\n"
    },
    "contracts/liquidators/AlphaHomoraV2SafeBoxLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/alpha/ISafeBox.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title AlphaHomoraV2SafeBoxLiquidator\n * @notice Redeems seized Alpha Homora v2 \"ibTokenV2\" or SafeBox tokens (e.g., ibDAIv2) for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract AlphaHomoraV2SafeBoxLiquidator is IRedemptionStrategy {\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n        // Redeem ibTokenV2 for underlying ERC20 token (and store output as new collateral)\n        ISafeBox safeBox = ISafeBox(address(inputToken));\n        safeBox.withdraw(inputAmount);\n        outputToken = IERC20Upgradeable(safeBox.uToken());\n        outputAmount = outputToken.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/oracles/default/UniswapLpTokenPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/uniswap/IUniswapV2Pair.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title UniswapLpTokenPriceOracle\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice UniswapLpTokenPriceOracle is a price oracle for Uniswap (and SushiSwap) LP tokens.\n * @dev Implements the `PriceOracle` interface used by Fuse pools (and Compound v2).\n */\ncontract UniswapLpTokenPriceOracle is IPriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev wtoken contract address.\n     */\n    address public immutable wtoken;\n\n\n    /**\n     * @dev Constructor to set admin and canAdminOverwrite, wtoken address and native token USD price feed address\n     */\n    constructor (address _wtoken) {\n        wtoken = _wtoken;\n    }\n\n    /**\n     * @notice Get the LP token price price for an underlying token address.\n     * @param underlying The underlying token address for which to get the price (set to zero address for ETH)\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying) external view returns (uint) {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(ICToken cToken) external override view returns (uint) {\n        address underlying = ICErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return _price(underlying).mul(1e18).div(10 ** uint256(ERC20Upgradeable(underlying).decimals()));\n    }\n\n    /**\n     * @dev Fetches the fair LP token/ETH price from Uniswap, with 18 decimals of precision.\n     */\n    function _price(address token) internal view virtual returns (uint) {\n        IUniswapV2Pair pair = IUniswapV2Pair(token);\n        uint totalSupply = pair.totalSupply();\n        if (totalSupply == 0) return 0;\n        (uint reserve0, uint reserve1, ) = pair.getReserves();\n        address token0 = pair.token0();\n        address token1 = pair.token1();\n\n        // Get fair price of non-WETH token (underlying the pair) in terms of ETH\n        uint token0FairPrice = token0 == wtoken ? 1e18 : BasePriceOracle(msg.sender).price(token0).mul(1e18).div(10 ** uint256(ERC20Upgradeable(token0).decimals()));\n        uint token1FairPrice = token1 == wtoken ? 1e18 : BasePriceOracle(msg.sender).price(token1).mul(1e18).div(10 ** uint256(ERC20Upgradeable(token1).decimals()));\n\n        // Implementation from https://github.com/AlphaFinanceLab/homora-v2/blob/e643392d582c81f6695136971cff4b685dcd2859/contracts/oracle/UniswapV2Oracle.sol#L18\n        uint256 sqrtK = sqrt(reserve0.mul(reserve1)).mul(2 ** 112).div(totalSupply);\n        return sqrtK.mul(2).mul(sqrt(token0FairPrice)).div(2 ** 56).mul(sqrt(token1FairPrice)).div(2 ** 56);\n    }\n\n    /**\n     * @dev Fast square root function.\n     * Implementation from: https://github.com/Uniswap/uniswap-lib/commit/99f3f28770640ba1bb1ff460ac7c5292fb8291a0\n     * Original implementation: https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n     */\n    function sqrt(uint x) internal pure returns (uint) {\n        if (x == 0) return 0;\n        uint xx = x;\n        uint r = 1;\n\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}\n"
    },
    "contracts/oracles/default/SushiBarPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/sushi/SushiBar.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title SushiBarPriceOracle\n * @notice Returns prices for SushiBar (xSUSHI).\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract SushiBarPriceOracle is IPriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying) external override view returns (uint) {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(ICToken cToken) external override view returns (uint) {\n        address underlying = ICErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return _price(underlying).mul(1e18).div(10 ** uint256(ERC20Upgradeable(underlying).decimals()));\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint) {\n        SushiBar sushiBar = SushiBar(token);\n        IERC20Upgradeable sushi = sushiBar.sushi();\n        uint256 sushiEthPrice = BasePriceOracle(msg.sender).price(address(sushi));\n        return sushi.balanceOf(token).mul(sushiEthPrice).div(sushiBar.totalSupply());\n    }\n}\n"
    },
    "contracts/external/sushi/SushiBar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nabstract contract SushiBar is IERC20Upgradeable {\n    IERC20Upgradeable public sushi;\n\n    // Enter the bar. Pay some SUSHIs. Earn some shares.\n    function enter(uint256 _amount) public virtual;\n\n    // Leave the bar. Claim back your SUSHIs.\n    function leave(uint256 _share) public virtual;\n}\n"
    },
    "contracts/liquidators/SushiBarLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/sushi/SushiBar.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title SushiBarLiquidator\n * @notice Redeems SushiBar (xSUSHI) for underlying SUSHI for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract SushiBarLiquidator is IRedemptionStrategy {\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n        // Unstake sOHM (and store output OHM as new collateral)\n        SushiBar sushiBar = SushiBar(address(inputToken));\n        sushiBar.leave(inputAmount);\n        outputToken = IERC20Upgradeable(sushiBar.sushi());\n        outputAmount = outputToken.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/oracles/default/FixedTokenPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title FixedTokenPriceOracle\n * @notice Returns token prices using the prices for another token.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract FixedTokenPriceOracle is IPriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev The token to base prices on.\n     */\n    address public immutable baseToken;\n\n    /**\n     * @dev Sets the token to base prices on.\n     */\n    constructor(address _baseToken) {\n        baseToken = _baseToken;\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying) external override view returns (uint) {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(ICToken cToken) external override view returns (uint) {\n        address underlying = ICErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return _price(underlying).mul(1e18).div(10 ** uint256(ERC20Upgradeable(underlying).decimals()));\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint) {\n        return BasePriceOracle(msg.sender).price(baseToken);\n    }\n}\n"
    },
    "contracts/oracles/default/FixedNativePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title FixedEthPriceOracle\n * @notice Returns fixed prices of 1 denominated in the chain's native token for all tokens (expected to be used under a `MasterPriceOracle`).\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract FixedNativePriceOracle is IPriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev Returns the price in native token of `underlying` (implements `BasePriceOracle`).\n     */\n    function price(address underlying) external override view returns (uint) {\n        return 1e18;\n    }\n\n    /**\n     * @notice Returns the price in native token of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in native token of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(ICToken cToken) external override view returns (uint) {\n        // Get underlying token address\n        address underlying = ICErc20(address(cToken)).underlying();\n\n        // Format and return price\n        return uint256(1e36).div(10 ** uint256(ERC20Upgradeable(underlying).decimals()));\n    }\n}\n"
    },
    "contracts/oracles/default/BalancerLpTokenPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/balancer/IBalancerPool.sol\";\nimport \"../../external/balancer/BNum.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title BalancerLpTokenPriceOracle\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice BalancerLpTokenPriceOracle is a price oracle for Balancer LP tokens.\n * @dev Implements the `PriceOracle` interface used by Fuse pools (and Compound v2).\n */\ncontract BalancerLpTokenPriceOracle is IPriceOracle, BasePriceOracle, BNum {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Get the LP token price price for an underlying token address.\n     * @param underlying The underlying token address for which to get the price (set to zero address for ETH).\n     * @return Price denominated in ETH (scaled by 1e18).\n     */\n    function price(address underlying) external override view returns (uint) {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(ICToken cToken) external override view returns (uint) {\n        address underlying = ICErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return _price(underlying).mul(1e18).div(10 ** uint256(ERC20Upgradeable(underlying).decimals()));\n    }\n\n    /**\n     * @dev Fetches the fair LP token/ETH price from Balancer, with 18 decimals of precision.\n     * Source: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BalancerPairOracle.sol\n     */\n    function _price(address underlying) internal view virtual returns (uint) {\n        IBalancerPool pool = IBalancerPool(underlying);\n        require(pool.getNumTokens() == 2, \"Balancer pool must have exactly 2 tokens.\");\n        address[] memory tokens = pool.getFinalTokens();\n        address tokenA = tokens[0];\n        address tokenB = tokens[1];\n        uint256 pxA = BasePriceOracle(msg.sender).price(tokenA);\n        uint256 pxB = BasePriceOracle(msg.sender).price(tokenB);\n        uint8 decimalsA = ERC20Upgradeable(tokenA).decimals();\n        uint8 decimalsB = ERC20Upgradeable(tokenB).decimals();\n        if (decimalsA < 18) pxA = pxA.mul(10 ** (18 - uint256(decimalsA)));\n        if (decimalsA > 18) pxA = pxA.div(10 ** (uint256(decimalsA) - 18));\n        if (decimalsB < 18) pxB = pxB.mul(10 ** (18 - uint256(decimalsB)));\n        if (decimalsB > 18) pxB = pxB.div(10 ** (uint256(decimalsB) - 18));\n        (uint256 fairResA, uint256 fairResB) = computeFairReserves(\n            pool.getBalance(tokenA),\n            pool.getBalance(tokenB),\n            pool.getNormalizedWeight(tokenA),\n            pool.getNormalizedWeight(tokenB),\n            pxA,\n            pxB\n        );\n        // use fairReserveA and fairReserveB to compute LP token price\n        // LP price = (fairResA * pxA + fairResB * pxB) / totalLPSupply\n        return fairResA.mul(pxA).add(fairResB.mul(pxB)).div(pool.totalSupply());\n    }\n\n    /**\n     * @dev Returns fair reserve amounts given spot reserves, weights, and fair prices.\n     * Source: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BalancerPairOracle.sol\n     * @param resA Reserve of the first asset\n     * @param resB Reserev of the second asset\n     * @param wA Weight of the first asset\n     * @param wB Weight of the second asset\n     * @param pxA Fair price of the first asset\n     * @param pxB Fair price of the second asset\n     */\n    function computeFairReserves(uint256 resA, uint256 resB, uint256 wA, uint256 wB, uint256 pxA, uint256 pxB) internal pure returns (uint256 fairResA, uint256 fairResB) {\n        // NOTE: wA + wB = 1 (normalize weights)\n        // constant product = resA^wA * resB^wB\n        // constraints:\n        // - fairResA^wA * fairResB^wB = constant product\n        // - fairResA * pxA / wA = fairResB * pxB / wB\n        // Solving equations:\n        // --> fairResA^wA * (fairResA * (pxA * wB) / (wA * pxB))^wB = constant product\n        // --> fairResA / r1^wB = constant product\n        // --> fairResA = resA^wA * resB^wB * r1^wB\n        // --> fairResA = resA * (resB/resA)^wB * r1^wB = resA * (r1/r0)^wB\n        uint256 r0 = bdiv(resA, resB);\n        uint256 r1 = bdiv(bmul(wA, pxB), bmul(wB, pxA));\n        // fairResA = resA * (r1 / r0) ^ wB\n        // fairResB = resB * (r0 / r1) ^ wA\n        if (r0 > r1) {\n            uint256 ratio = bdiv(r1, r0);\n            fairResA = bmul(resA, bpow(ratio, wB));\n            fairResB = bdiv(resB, bpow(ratio, wA));\n        } else {\n            uint256 ratio = bdiv(r0, r1);\n            fairResA = bdiv(resA, bpow(ratio, wB));\n            fairResB = bmul(resB, bpow(ratio, wA));\n        }\n    }\n}"
    },
    "contracts/external/balancer/IBalancerPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.0;\n\ninterface IBalancerPool {\n    function getFinalTokens() external view returns (address[] memory);\n\n    function getNormalizedWeight(address token) external view returns (uint);\n\n    function getSwapFee() external view returns (uint);\n\n    function getNumTokens() external view returns (uint);\n\n    function getBalance(address token) external view returns (uint);\n\n    function totalSupply() external view returns (uint);\n\n    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn) external;\n\n    function swapExactAmountIn(\n        address tokenIn,\n        uint tokenAmountIn,\n        address tokenOut,\n        uint minAmountOut,\n        uint maxPrice\n    ) external returns (uint tokenAmountOut, uint spotPriceAfter);\n\n    function swapExactAmountOut(\n        address tokenIn,\n        uint maxAmountIn,\n        address tokenOut,\n        uint tokenAmountOut,\n        uint maxPrice\n    ) external returns (uint tokenAmountIn, uint spotPriceAfter);\n\n    function joinswapExternAmountIn(\n        address tokenIn,\n        uint tokenAmountIn,\n        uint minPoolAmountOut\n    ) external returns (uint poolAmountOut);\n\n    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut) external;\n\n    function exitswapExternAmountOut(\n        address tokenOut,\n        uint tokenAmountOut,\n        uint maxPoolAmountIn\n    ) external returns (uint poolAmountIn);\n}\n"
    },
    "contracts/external/balancer/BNum.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.0;\n\nimport \"./BConst.sol\";\n\ncontract BNum is BConst {\n\n    function btoi(uint a)\n        internal pure \n        returns (uint)\n    {\n        return a / BONE;\n    }\n\n    function bfloor(uint a)\n        internal pure\n        returns (uint)\n    {\n        return btoi(a) * BONE;\n    }\n\n    function badd(uint a, uint b)\n        internal pure\n        returns (uint)\n    {\n        uint c = a + b;\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\n        return c;\n    }\n\n    function bsub(uint a, uint b)\n        internal pure\n        returns (uint)\n    {\n        (uint c, bool flag) = bsubSign(a, b);\n        require(!flag, \"ERR_SUB_UNDERFLOW\");\n        return c;\n    }\n\n    function bsubSign(uint a, uint b)\n        internal pure\n        returns (uint, bool)\n    {\n        if (a >= b) {\n            return (a - b, false);\n        } else {\n            return (b - a, true);\n        }\n    }\n\n    function bmul(uint a, uint b)\n        internal pure\n        returns (uint)\n    {\n        uint c0 = a * b;\n        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\n        uint c1 = c0 + (BONE / 2);\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\n        uint c2 = c1 / BONE;\n        return c2;\n    }\n\n    function bdiv(uint a, uint b)\n        internal pure\n        returns (uint)\n    {\n        require(b != 0, \"ERR_DIV_ZERO\");\n        uint c0 = a * BONE;\n        require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\n        uint c1 = c0 + (b / 2);\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\n        uint c2 = c1 / b;\n        return c2;\n    }\n\n    // DSMath.wpow\n    function bpowi(uint a, uint n)\n        internal pure\n        returns (uint)\n    {\n        uint z = n % 2 != 0 ? a : BONE;\n\n        for (n /= 2; n != 0; n /= 2) {\n            a = bmul(a, a);\n\n            if (n % 2 != 0) {\n                z = bmul(z, a);\n            }\n        }\n        return z;\n    }\n\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\n    // of approximation of b^0.w\n    function bpow(uint base, uint exp)\n        internal pure\n        returns (uint)\n    {\n        require(base >= MIN_BPOW_BASE, \"ERR_BPOW_BASE_TOO_LOW\");\n        require(base <= MAX_BPOW_BASE, \"ERR_BPOW_BASE_TOO_HIGH\");\n\n        uint whole  = bfloor(exp);   \n        uint remain = bsub(exp, whole);\n\n        uint wholePow = bpowi(base, btoi(whole));\n\n        if (remain == 0) {\n            return wholePow;\n        }\n\n        uint partialResult = bpowApprox(base, remain, BPOW_PRECISION);\n        return bmul(wholePow, partialResult);\n    }\n\n    function bpowApprox(uint base, uint exp, uint precision)\n        internal pure\n        returns (uint)\n    {\n        // term 0:\n        uint a     = exp;\n        (uint x, bool xneg)  = bsubSign(base, BONE);\n        uint term = BONE;\n        uint sum   = term;\n        bool negative = false;\n\n\n        // term(k) = numer / denom \n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\n        // continue until term is less than precision\n        for (uint i = 1; term >= precision; i++) {\n            uint bigK = i * BONE;\n            (uint c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\n            term = bmul(term, bmul(c, x));\n            term = bdiv(term, bigK);\n            if (term == 0) break;\n\n            if (xneg) negative = !negative;\n            if (cneg) negative = !negative;\n            if (negative) {\n                sum = bsub(sum, term);\n            } else {\n                sum = badd(sum, term);\n            }\n        }\n\n        return sum;\n    }\n\n}\n"
    },
    "contracts/external/balancer/BConst.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.7.0;\n\ncontract BConst {\n    uint public constant BONE              = 10**18;\n\n    uint public constant MIN_BOUND_TOKENS  = 2;\n    uint public constant MAX_BOUND_TOKENS  = 8;\n\n    uint public constant MIN_FEE           = BONE / 10**6;\n    uint public constant MAX_FEE           = BONE / 10;\n    uint public constant EXIT_FEE          = 0;\n\n    uint public constant MIN_WEIGHT        = BONE;\n    uint public constant MAX_WEIGHT        = BONE * 50;\n    uint public constant MAX_TOTAL_WEIGHT  = BONE * 50;\n    uint public constant MIN_BALANCE       = BONE / 10**12;\n\n    uint public constant INIT_POOL_SUPPLY  = BONE * 100;\n\n    uint public constant MIN_BPOW_BASE     = 1 wei;\n    uint public constant MAX_BPOW_BASE     = (2 * BONE) - 1 wei;\n    uint public constant BPOW_PRECISION    = BONE / 10**10;\n\n    uint public constant MAX_IN_RATIO      = BONE / 2;\n    uint public constant MAX_OUT_RATIO     = (BONE / 3) + 1 wei;\n}\n"
    },
    "contracts/liquidators/BalancerPoolTokenLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\nimport \"../external/balancer/IBalancerPool.sol\";\nimport \"../external/uniswap/IUniswapV2Router02.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title BalancerPoolTokenLiquidator\n * @notice Exchanges seized Balancer Pool Token (BPT) collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract BalancerPoolTokenLiquidator is IRedemptionStrategy {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n     */\n    function safeApprove(IERC20Upgradeable token, address to, uint256 minAmount) private {\n        uint256 allowance = token.allowance(address(this), to);\n\n        if (allowance < minAmount) {\n            if (allowance > 0) token.safeApprove(to, 0);\n            token.safeApprove(to, uint256(-1));\n        }\n    }\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n        // Exit Balancer pool\n        IBalancerPool balancerPool = IBalancerPool(address(inputToken));\n        address[] memory tokens = balancerPool.getFinalTokens();\n        uint256[] memory minAmountsOut = new uint256[](tokens.length);\n        balancerPool.exitPool(inputAmount, minAmountsOut);\n\n        // Swap underlying tokens\n        (IUniswapV2Router02 uniswapV2Router, address[][] memory swapPaths) = abi.decode(strategyData, (IUniswapV2Router02, address[][]));\n        require(swapPaths.length == tokens.length, \"Swap paths array length must match the number of underlying tokens in the Balancer pool.\");\n        for (uint256 i = 1; i < swapPaths.length; i++)\n            require((swapPaths[0].length > 0 ? swapPaths[0][swapPaths[0].length - 1] : tokens[0]) == (swapPaths[i].length > 0 ? swapPaths[i][swapPaths[i].length - 1] : tokens[i]), \"All underlying token swap paths must output the same token.\");\n\n        for (uint256 i = 0; i < swapPaths.length; i++) if (swapPaths[i].length > 0 && swapPaths[i][swapPaths[i].length - 1] != tokens[i]) {\n            uint256 swapAmountIn = IERC20Upgradeable(tokens[i]).balanceOf(address(this));\n            safeApprove(IERC20Upgradeable(tokens[i]), address(uniswapV2Router), swapAmountIn);\n            uniswapV2Router.swapExactTokensForTokens(swapAmountIn, 0, swapPaths[i], address(this), block.timestamp);\n        }\n\n        // Get new collateral\n        outputToken = IERC20Upgradeable(swapPaths[0].length > 0 ? swapPaths[0][swapPaths[0].length - 1] : tokens[0]);\n        outputAmount = outputToken.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/liquidators/DolaStabilizerLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\nimport \"../external/inverse/Stabilizer.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title DolaStabilizerLiquidator\n * @notice Buys DOLA using DAI and sells DOLA for DAI using the Anchor Stabilizer contract as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract DolaStabilizerLiquidator is IRedemptionStrategy {\n    using SafeMathUpgradeable for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @dev Anchor's Stabilizer contract for DOLA.\n     */\n    Stabilizer public STABILIZER = Stabilizer(0x7eC0D931AFFBa01b77711C2cD07c76B970795CDd);\n\n    /**\n     * @dev Stabilizer's fee denominator.\n     */\n    uint256 constant public FEE_DENOMINATOR = 10000;\n\n    /**\n     * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n     */\n    function safeApprove(IERC20Upgradeable token, address to, uint256 minAmount) private {\n        uint256 allowance = token.allowance(address(this), to);\n\n        if (allowance < minAmount) {\n            if (allowance > 0) token.safeApprove(to, 0);\n            token.safeApprove(to, uint256(-1));\n        }\n    }\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n        // Approve input token to Stabilizer\n        safeApprove(inputToken, address(STABILIZER), inputAmount);\n\n        // Buy or sell depending on if input is synth or reserve\n        address synth = STABILIZER.synth();\n        address reserve = STABILIZER.reserve();\n\n        if (address(inputToken) == reserve) {\n            // Buy DOLA with DAI\n            outputAmount = inputAmount.mul(FEE_DENOMINATOR).div(FEE_DENOMINATOR.add(STABILIZER.buyFee()));\n            STABILIZER.buy(outputAmount);\n            outputToken = IERC20Upgradeable(synth);\n        } else if (address(inputToken) == synth) {\n            // Sell DOLA for DAI\n            STABILIZER.sell(inputAmount);\n            outputToken = IERC20Upgradeable(reserve);\n            outputAmount = outputToken.balanceOf(address(this));\n        }\n    }\n}\n"
    },
    "contracts/external/inverse/Stabilizer.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity >=0.7.0;\n\ninterface Stabilizer {\n    function buyFee() external view returns (uint256);\n    function synth() external view returns (address);\n    function reserve() external view returns (address);\n    function buy(uint amount) external;\n    function sell(uint amount) external;\n}\n"
    },
    "contracts/liquidators/SOhmLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\nimport \"../external/olympus/sOlympus.sol\";\nimport \"../external/olympus/OlympusStaking.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title SOhmLiquidator\n * @notice Redeems sOHM for underlying assets for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract SOhmLiquidator is IRedemptionStrategy {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n     */\n    function safeApprove(IERC20Upgradeable token, address to, uint256 minAmount) private {\n        uint256 allowance = token.allowance(address(this), to);\n\n        if (allowance < minAmount) {\n            if (allowance > 0) token.safeApprove(to, 0);\n            token.safeApprove(to, uint256(-1));\n        }\n    }\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n        // Unstake sOHM (and store output OHM as new collateral)\n        sOlympus token = sOlympus(address(inputToken));\n        OlympusStaking staking = OlympusStaking(token.stakingContract());\n        safeApprove(inputToken, address(staking), inputAmount);\n        staking.unstake(inputAmount, false);\n        outputToken = IERC20Upgradeable(staking.OHM());\n        outputAmount = inputAmount;\n    }\n}\n"
    },
    "contracts/external/olympus/sOlympus.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.7.0;\n\nabstract contract sOlympus {\n    address public stakingContract;\n}\n"
    },
    "contracts/external/olympus/OlympusStaking.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.7.0;\n\nabstract contract OlympusStaking {\n    address public OHM;\n    function unstake(uint _amount, bool _trigger) external virtual;\n}\n"
    },
    "contracts/liquidators/PoolTogetherLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/pooltogether/ControlledTokenInterface.sol\";\nimport \"../external/pooltogether/PrizePoolInterface.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title PoolTogetherLiquidator\n * @notice Redeems PoolTogether PcTokens for underlying assets for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract PoolTogetherLiquidator is IRedemptionStrategy {\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n        // Redeem PcToken (and store output as new collateral)\n        ControlledTokenInterface token = ControlledTokenInterface(address(inputToken));\n        PrizePoolInterface controller = PrizePoolInterface(token.controller());\n        controller.withdrawInstantlyFrom(address(this), inputAmount, address(token), uint256(-1));\n        outputToken = IERC20Upgradeable(controller.token());\n        outputAmount = inputAmount;\n    }\n}\n"
    },
    "contracts/external/pooltogether/ControlledTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0;\n\n/// @title Controlled ERC20 Token\n/// @notice ERC20 Tokens with a controller for minting & burning\ninterface ControlledTokenInterface {\n  /// @notice Interface to the contract responsible for controlling mint/burn\n  function controller() external view returns (address);\n}\n"
    },
    "contracts/external/pooltogether/PrizePoolInterface.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0;\n\n/// @title Escrows assets and deposits them into a yield source.  Exposes interest to Prize Strategy.  Users deposit and withdraw from this contract to participate in Prize Pool.\n/// @notice Accounting is managed using Controlled Tokens, whose mint and burn functions can only be called by this contract.\n/// @dev Must be inherited to provide specific yield-bearing asset control, such as Compound cTokens\ninterface PrizePoolInterface {\n  /// @notice Withdraw assets from the Prize Pool instantly.  A fairness fee may be charged for an early exit.\n  /// @param from The address to redeem tokens from.\n  /// @param amount The amount of tokens to redeem for assets.\n  /// @param controlledToken The address of the token to redeem (i.e. ticket or sponsorship)\n  /// @param maximumExitFee The maximum exit fee the caller is willing to pay.  This should be pre-calculated by the calculateExitFee() fxn.\n  /// @return The actual exit fee paid\n  function withdrawInstantlyFrom(\n    address from,\n    uint256 amount,\n    address controlledToken,\n    uint256 maximumExitFee\n  ) external returns (uint256);\n\n  /// @dev Returns the address of the underlying ERC20 asset\n  /// @return The address of the asset\n  function token() external view returns (address);\n}"
    },
    "contracts/liquidators/CErc20Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title CErc20Liquidator\n * @notice Redeems seized Compound/Cream/Fuse CErc20 cTokens for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CErc20Liquidator is IRedemptionStrategy {\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n        // Redeem cErc20 for underlying ERC20 token (and store output as new collateral)\n        ICErc20 cErc20 = ICErc20(address(inputToken));\n        uint256 redeemResult = cErc20.redeem(inputAmount);\n        require(redeemResult == 0, \"Error calling redeeming seized cErc20: error code not equal to 0\");\n        outputToken = IERC20Upgradeable(cErc20.underlying());\n        outputAmount = outputToken.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/oracles/1337/SimplePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"../../compound/PriceOracle.sol\";\nimport \"../../compound/CErc20.sol\";\n\ncontract SimplePriceOracle is PriceOracle {\n    mapping(address => uint) prices;\n    event PricePosted(address asset, uint previousPriceMantissa, uint requestedPriceMantissa, uint newPriceMantissa);\n\n    function getUnderlyingPrice(CToken cToken) override public view returns (uint) {\n        if (compareStrings(cToken.symbol(), \"cETH\")) {\n            return 1e18;\n        } else {\n            return prices[address(CErc20(address(cToken)).underlying())];\n        }\n    }\n\n    function setUnderlyingPrice(CToken cToken, uint underlyingPriceMantissa) public {\n        address asset = address(CErc20(address(cToken)).underlying());\n        emit PricePosted(asset, prices[asset], underlyingPriceMantissa, underlyingPriceMantissa);\n        prices[asset] = underlyingPriceMantissa;\n    }\n\n    function setDirectPrice(address asset, uint price) public {\n        emit PricePosted(asset, prices[asset], price, price);\n        prices[asset] = price;\n    }\n\n    // v1 price oracle interface for use as backing of proxy\n    function assetPrices(address asset) external view returns (uint) {\n        return prices[asset];\n    }\n\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n}\n"
    },
    "contracts/compound/CErc20Delegate.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"./CErc20.sol\";\nimport \"./CDelegateInterface.sol\";\n\n/**\n * @title Compound's CErc20Delegate Contract\n * @notice CTokens which wrap an EIP-20 underlying and are delegated to\n * @author Compound\n */\ncontract CErc20Delegate is CDelegateInterface, CErc20 {\n    /**\n     * @notice Construct an empty delegate\n     */\n    constructor() {}\n\n    /**\n     * @notice Called by the delegator on a delegate to initialize it for duty\n     * @param data The encoded bytes data for any initialization\n     */\n    function _becomeImplementation(bytes calldata data) override virtual external {\n\n        require(msg.sender == address(this) || hasAdminRights(), \"!self\");\n\n        // Make sure admin storage is set up correctly\n        __admin = address(0);\n        __adminHasRights = false;\n        __fuseAdminHasRights = false;\n    }\n\n\n    /**\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\n     */\n    function _resignImplementation() virtual internal {\n        // Shh -- we don't ever want this hook to be marked pure\n        if (false) {\n            implementation = address(0);\n        }\n    }\n\n    /**\n     * @dev Internal function to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n     */\n    function _setImplementationInternal(address implementation_, bool allowResign, bytes memory becomeImplementationData) internal {\n        // Check whitelist\n        require(fuseAdmin.cErc20DelegateWhitelist(implementation, implementation_, allowResign), \"!impl\");\n\n        // Call _resignImplementation internally (this delegate's code)\n        if (allowResign) _resignImplementation();\n\n        // Get old implementation\n        address oldImplementation = implementation;\n\n        // Store new implementation\n        implementation = implementation_;\n\n        // Call _becomeImplementation externally (delegating to new delegate's code)\n        _functionCall(address(this), abi.encodeWithSignature(\"_becomeImplementation(bytes)\", becomeImplementationData), \"!become\");\n\n        // Emit event\n        emit NewImplementation(oldImplementation, implementation);\n    }\n\n    /**\n     * @notice Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n     */\n    function _setImplementationSafe(address implementation_, bool allowResign, bytes calldata becomeImplementationData) override external {\n        // Check admin rights\n        require(hasAdminRights(), \"!admin\");\n\n        // Set implementation\n        _setImplementationInternal(implementation_, allowResign, becomeImplementationData);\n    }\n\n    /**\n     * @notice Function called before all delegator functions\n     * @dev Checks comptroller.autoImplementation and upgrades the implementation if necessary\n     */\n    function _prepare() override external payable {\n        if (msg.sender != address(this) && ComptrollerV3Storage(address(comptroller)).autoImplementation()) {\n            (address latestCErc20Delegate, bool allowResign, bytes memory becomeImplementationData) = fuseAdmin.latestCErc20Delegate(implementation);\n            if (implementation != latestCErc20Delegate) _setImplementationInternal(latestCErc20Delegate, allowResign, becomeImplementationData);\n        }\n    }\n}\n"
    },
    "contracts/compound/CDaiDelegate.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0;\n\nimport \"./CErc20Delegate.sol\";\n\n/**\n * @title Compound's CDai Contract\n * @notice CToken which wraps Multi-Collateral DAI\n * @author Compound\n */\ncontract CDaiDelegate is CErc20Delegate {\n    /**\n     * @notice DAI adapter address\n     */\n    address public daiJoinAddress;\n\n    /**\n     * @notice DAI Savings Rate (DSR) pot address\n     */\n    address public potAddress;\n\n    /**\n     * @notice DAI vat address\n     */\n    address public vatAddress;\n\n    /**\n     * @notice Delegate interface to become the implementation\n     * @param data The encoded arguments for becoming\n     */\n    function _becomeImplementation(bytes calldata data) override external {\n        require(msg.sender == address(this) || hasAdminRights(), \"only self or admin may call _becomeImplementation\");\n\n        // Decode data\n        (address daiJoinAddress_, address potAddress_) = abi.decode(data, (address, address));\n        return _becomeImplementation(daiJoinAddress_, potAddress_);\n    }\n\n    /**\n     * @notice Explicit interface to become the implementation\n     * @param daiJoinAddress_ DAI adapter address\n     * @param potAddress_ DAI Savings Rate (DSR) pot address\n     */\n    function _becomeImplementation(address daiJoinAddress_, address potAddress_) internal {\n        // Get dai and vat and sanity check the underlying\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress_);\n        PotLike pot = PotLike(potAddress_);\n        GemLike dai = daiJoin.dai();\n        VatLike vat = daiJoin.vat();\n        require(address(dai) == underlying, \"DAI must be the same as underlying\");\n\n        // Remember the relevant addresses\n        daiJoinAddress = daiJoinAddress_;\n        potAddress = potAddress_;\n        vatAddress = address(vat);\n\n        // Approve moving our DAI into the vat through daiJoin\n        dai.approve(daiJoinAddress, uint(-1));\n\n        // Approve the pot to transfer our funds within the vat\n        vat.hope(potAddress);\n        vat.hope(daiJoinAddress);\n\n        // Accumulate DSR interest -- must do this in order to doTransferIn\n        pot.drip();\n\n        // Transfer all cash in (doTransferIn does this regardless of amount)\n        doTransferIn(address(this), 0);\n    }\n\n    /**\n     * @notice Delegate interface to resign the implementation\n     */\n    function _resignImplementation() override internal {\n        // Transfer all cash out of the DSR - note that this relies on self-transfer\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\n        PotLike pot = PotLike(potAddress);\n        VatLike vat = VatLike(vatAddress);\n\n        // Accumulate interest\n        pot.drip();\n\n        // Calculate the total amount in the pot, and move it out\n        uint pie = pot.pie(address(this));\n        pot.exit(pie);\n\n        // Checks the actual balance of DAI in the vat after the pot exit\n        uint bal = vat.dai(address(this));\n\n        // Remove our whole balance\n        daiJoin.exit(address(this), bal / RAY);\n    }\n\n    /*** CToken Overrides ***/\n\n    /**\n      * @notice Accrues DSR then applies accrued interest to total borrows and reserves\n      * @dev This calculates interest accrued from the last checkpointed block\n      *      up to the current block and writes new checkpoint to storage.\n      */\n    function accrueInterest() override public returns (uint) {\n        // Accumulate DSR interest\n        PotLike(potAddress).drip();\n\n        // Accumulate CToken interest\n        return super.accrueInterest();\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior() override internal view returns (uint) {\n        PotLike pot = PotLike(potAddress);\n        uint pie = pot.pie(address(this));\n        return mul(pot.chi(), pie) / RAY;\n    }\n\n    /**\n     * @notice Transfer the underlying to this contract and sweep into DSR pot\n     * @param from Address to transfer funds from\n     * @param amount Amount of underlying to transfer\n     * @return The actual amount that is transferred\n     */\n    function doTransferIn(address from, uint amount) override internal returns (uint) {\n        // Perform the EIP-20 transfer in\n        EIP20Interface token = EIP20Interface(underlying);\n        require(token.transferFrom(from, address(this), amount), \"unexpected EIP-20 transfer in return\");\n\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\n        GemLike dai = GemLike(underlying);\n        PotLike pot = PotLike(potAddress);\n        VatLike vat = VatLike(vatAddress);\n\n        // Convert all our DAI to internal DAI in the vat\n        daiJoin.join(address(this), dai.balanceOf(address(this)));\n\n        // Checks the actual balance of DAI in the vat after the join\n        uint bal = vat.dai(address(this));\n\n        // Calculate the percentage increase to th pot for the entire vat, and move it in\n        // Note: We may leave a tiny bit of DAI in the vat...but we do the whole thing every time\n        uint pie = bal / pot.chi();\n        pot.join(pie);\n\n        return amount;\n    }\n\n    /**\n     * @notice Transfer the underlying from this contract, after sweeping out of DSR pot\n     * @param to Address to transfer funds to\n     * @param amount Amount of underlying to transfer\n     */\n    function doTransferOut(address payable to, uint amount) override internal {\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\n        PotLike pot = PotLike(potAddress);\n\n        // Calculate the percentage decrease from the pot, and move that much out\n        // Note: Use a slightly larger pie size to ensure that we get at least amount in the vat\n        uint pie = add(mul(amount, RAY) / pot.chi(), 1);\n        pot.exit(pie);\n\n        daiJoin.exit(to, amount);\n    }\n\n    /*** Maker Internals ***/\n\n    uint256 constant RAY = 10 ** 27;\n\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"add-overflow\");\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"mul-overflow\");\n    }\n}\n\n/*** Maker Interfaces ***/\n\ninterface PotLike {\n    function chi() external view returns (uint);\n    function pie(address) external view returns (uint);\n    function drip() external returns (uint);\n    function join(uint) external;\n    function exit(uint) external;\n}\n\ninterface GemLike {\n    function approve(address, uint) external;\n    function balanceOf(address) external view returns (uint);\n    function transferFrom(address, address, uint) external returns (bool);\n}\n\ninterface VatLike {\n    function dai(address) external view returns (uint);\n    function hope(address) external;\n}\n\ninterface DaiJoinLike {\n    function vat() external returns (VatLike);\n    function dai() external returns (GemLike);\n    function join(address, uint) external payable;\n    function exit(address, uint) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}